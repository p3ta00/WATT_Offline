When assessing a web application, researchers use a variety of tools and methodologies. Nevertheless, certain principles should be followed regardless of the tools used. In this module, we will introduce some of the more common tools and demonstrate their use to establish a foundation for the remainder of this course.

Before we get started, it's important to clarify that web application research and exploitation can be conducted from a whitebox,[1](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_132-1) blackbox,[2](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_132-2) or greybox[3](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_132-3) perspective. In a whitebox scenario, the researcher either has access to the original source code or is at least able to recover it in a near-original state. When neither of these scenarios is possible, the researcher must adopt a blackbox approach, in which minimal information about the target application is available. In this case, in order to find a vulnerability, the researcher needs to observe the behavior of the application by inspecting the output and/or the effects generated as result of precisely-crafted input requests. We might also take a greybox approach when we have access to credentials or documentation to the application, but not full access required for a whitebox approach.

When adopting a whitebox perspective, web applications are often easier to research and exploit than traditional compiled applications since web applications are written in interpreted languages, which do not require reverse engineering. In addition, the source code for web applications written in bytecode-based languages such as Java, .NET, or similar can also be trivially recovered into near-original state with the help of specialized tools.

It's worth mentioning that the ability to recover and read the source code of a modern web application does not necessarily reduce the complexity of the required research. However, once the source code is recovered, the researcher can better inspect the internal structure of the application and perform a thorough analysis of the code flow.

As a penetration tester, we can use chained attack methods to exploit a variety or programming oversights.

1

(Wikipedia, 2021), [https://en.wikipedia.org/wiki/White-box_testing](https://en.wikipedia.org/wiki/White-box_testing) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_132-1)

2

(Wikipedia, 2021), [https://en.wikipedia.org/wiki/Black-box_testing](https://en.wikipedia.org/wiki/Black-box_testing) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_132-2)

3

(Wikipedia, 2021), [https://en.wikipedia.org/wiki/Gray_box_testing](https://en.wikipedia.org/wiki/Gray_box_testing) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_132-3)

## 2.1. Web Traffic Inspection

When dealing with an unknown web application, we should always begin with traffic inspection. A web application presents various interface elements and conducts various network transactions.

As researchers, we are always interested in capturing as much information about our targets as possible and in this case, a web application proxy is an indispensable tool. We can use a good proxy to capture relevant client requests and server responses and easily manipulate a chosen request in arbitrary ways.

In this course, we will primarily use the community edition of the Burp Suite (installed in Kali Linux by default), which provides us with everything we need to conduct thorough information gathering and HTTP request manipulation.

### 2.1.1. Burp Suite Proxy

We can launch Burp Suite in Kali via the launcher menu. Once we start it, we may receive a notification indicating that Burp Suite has not been tested with our current Java version (Figure 1).

![Figure 1: Burp Suite Java version warning](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/297927471e93c58d93402e72d1901e3f-tm_burp_01.png)

Figure 1: Burp Suite Java version warning

Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

The first time we run Burp Suite, it will prompt us to accept the Terms and Conditions.

![Figure 2: Burp Suite Terms and Conditions](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/6c87f156f78af369051093dbea7a7512-tm_burp_02.png)

Figure 2: Burp Suite Terms and Conditions

We can accept the Terms and Conditions by clicking _I Accept_ after deciding whether or not to submit anonymous feedback.

The next window offers us the opportunity to start a new project or restore a previously saved one. The ability to use project files is a Burp Suite Professional feature. We do not need to use this feature for this course, so we'll leave _Temporary project_ selected and continue.

![Figure 3: Burp Suite temporary project](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/562132f6db9fd0ac3ba825209fcceb4b-tm_burp_03.png)

Figure 3: Burp Suite temporary project

The final prompt presents the option to load a custom configuration or accept the defaults. Burp Suite allows us to customize and streamline our workflow and settings through these custom configurations. For now we will stick with the Burp Suite default profile and click _Start Burp_.

![Figure 4: Burp Suite configuration settings](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/9a676ef0334145a7a136bafa0defc27d-tm_burp_04.png)

Figure 4: Burp Suite configuration settings

Once Burp Suite has started, we can validate that our proxy service is running by checking the Event log in the lower-lefthand corner of the Dashboard. A message similar to the following will be displayed:

![Figure 5: Burp Suite proxy running](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/a7c19fa161086bec8cb67c124ecaf7b3-tm_burp_05.png)

Figure 5: Burp Suite proxy running

Now that the proxy service is running, we need to configure a browser. Burp Suite includes an embedded Chromium browser that is preconfigured to proxy traffic through Burp Suite's proxy. We can launch it by clicking on the _Proxy_ tab and then the _Intercept_ tab.

![Figure 6: Burp Suite Intercept tab](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/c77e5c6378e4f8ea357ec7ea645ab812-tm_burp_06.png)

Figure 6: Burp Suite Intercept tab

We can launch the embedded Chromium browser by clicking on either of the _Open Browser_ buttons on this tab.

Now that our proxy is set up, we will briefly test it. In this case we will navigate to the lab VM that is hosting a vulnerable version of the _Concord_[1](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_134-1) web application. Please note that for this course, we have made hosts entries in our Kali Linux attacking machine that allow us to refer to the lab machines by name.

```
kali@kali:~$ cat /etc/hosts
127.0.0.1	localhost
127.0.1.1	kali

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
# AWAE lab machines
192.168.121.103 atutor
192.168.121.112 bassmaster
192.168.121.113 manageengine
192.168.121.120 dnn
192.168.121.123 erpnext
192.168.121.126 opencrx
192.168.121.129 openitcockpit
192.168.121.132 concord
192.168.121.135 apigateway
192.168.121.138 chips
192.168.121.247 photog
192.168.121.247 sqeakr
192.168.121.249 docedit
192.168.121.251 answers
192.168.121.253 debugger
```

> Listing 1 - Kali hosts file

Make sure to edit your _/etc/hosts_ file on your Kali Linux box in order to reflect the IP addresses of the vulnerable targets that can be found in your student control panel.

If we now try to browse to the http://concord:8001/ URL, we will notice that the browser is not completing the request since Burp Suite turns on the _Intercept_ feature by default.

![Figure 7: Chromium connecting](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/35bacc3efc6ec225197e4e77bc1ccd1f-tm_burp_07.png)

Figure 7: Chromium connecting

As the name suggests, this feature intercepts requests sent to the proxy. It then allows us to either inspect and forward a request to the target or drop it by using the appropriate buttons as shown in Figure 8.

![Figure 8: Burp Suite Intercept On/Off switch](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/a57deec493e913e25e4c452cb7f3ec42-tm_burp_08.png)

Figure 8: Burp Suite Intercept On/Off switch

For the purposes of this module, we can safely turn this feature off by clicking _Intercept is on_. The text on the button will update to "Intercept is off".

The _HTTP history_ tab is fairly self-explanatory--this is where Burp Suite lists the entire session history, which includes all requests and responses proxied through it.

![Figure 9: Burp Suite history tab](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/53832a7e95b1f4a8262945dba4b036f2-tm_burp_09.png)

Figure 9: Burp Suite history tab

Excellent. We have verified that Burp Suite is capturing our browser traffic.

1

(Walmart, 2021), [https://concord.walmartlabs.com/](https://concord.walmartlabs.com/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_134-1)

### 2.1.2. Using Burp Suite with Other Browsers

Before we move on to some of the other tools in Burp Suite, let's demonstrate how to configure another browser to use Burp Suite as a proxy. In Firefox, we can do this by navigating to about:preferences#advanced, scrolling down to Network Settings, and then clicking _Settings_.

Here we'll choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy and the browser reside on the same host, so we'll use the loopback interface and specify port 8080. However, if we planned on using the proxy to intercept traffic from multiple machines, we would use the public IP address of the machine running the proxy for this setting.

Finally, we also want to check the _Use this proxy server for all protocols_ option in order to make sure that we can intercept every request while testing the target application.

![Figure 10: Firefox network settings](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/5be21d2df4c43d524be69ba0a65f8836-tm_firefox_cfg_01.png)

Figure 10: Firefox network settings

Note that once we configure Firefox in this way, we will need Burp Suite running in order to access any website. To stop using Burp Suite as a proxy we must return to connection settings and select _Use system proxy settings_. Alternatively we could use any of a number of browser add-ons (such as FoxyProxy) to switch between proxy server settings.

### 2.1.3. Burp Suite Scope

Modern web applications generally contain many requests and responses to sites that may not be of any interest to us, such as third party statistics collectors, ad networks, etc. In order to filter this traffic and streamline our workflow, Burp Suite allows us to set a collection scope. We can do this now by right-clicking any Concord request (with a URL ending with a forward slash) and selecting _Add to scope_.

Note that doing this on a top-level domain URL request will add the entire domain to the scope. Alternatively, performing this action against a more-specific page of a given web application will only add that single page to the scope.

![Figure 11: Burp Suite](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/5029a418c1eed040c2fe5a269a7296d0-tm_burp_10.png)

Figure 11: Burp Suite "Add to scope" feature

Once we set the scope, we are given the option to stop capturing items that are not in scope. We will choose _Yes_.

![Figure 12: Burp Suite scope warning](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/b95163e44e0400633e93d663e1f1c629-tm_burp_11.png)

Figure 12: Burp Suite scope warning

Now that we have the Concord server added to our scope, we can change the _HTTP history_ filter settings to display only in-scope items. We'll do this by clicking the filter box, selecting _Show only in-scope items_, and clicking away from the filter box.

![Figure 13: Burp Suite Show only in-scope items](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/ed7507f4d5727ad56aff2e194e72778a-tm_burp_12.png)

Figure 13: Burp Suite Show only in-scope items

Once the filter is updated, the request for content-autofill.googleapis.com is hidden as shown below in Figure 14. Setting scope in Burp Suite can eliminate the "noise" caused by browsers attempting to update themselves or downloading other resources.

![Figure 14: BurpSuite history showing only in-scope items](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/8e7d7c129050e939b2b07994ae167104-tm_burp_13.png)

Figure 14: BurpSuite history showing only in-scope items

We can verify that our scope has been properly set by switching to the _Target_ tab and then selecting the _Scope_ subtab.

![Figure 15: Burp Suite scope listing](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/77605c8231697efbf61f54dae10c88b2-tm_burp_14.png)

Figure 15: Burp Suite scope listing

The Target Scope lists the base URL for the Concord server with a checkmark indicating it is enabled.

### 2.1.4. Burp Suite Repeater and Comparer

While inspecting web applications, we often need to determine how granular changes to our HTTP requests affect the response a web server might return. In those instances, we can use the Burp Suite _Repeater_ tool to make arbitrary and very precise changes to a captured request and then resend it to the target web server.

Let's try it out. We'll switch back to the _Proxy_ > _HTTP history_ tab and use the request to /api/service/console/whoami. Let's right-click on it and choose _Send to Repeater_ (Figure 16).

![Figure 16: Burp Suite Send to Repeater](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/496c96afcba9860f99c1be8ff3c2de6d-tm_burp_repeater_01.png)

Figure 16: Burp Suite Send to Repeater

Once we switch over to the _Repeater_ tab, we will first click _Send_ to resend our original (unmodified) request. The response will establish a baseline against which we can evaluate subsequent arbitrarily-modified requests to the same URL and any corresponding responses.

![Figure 17: Burp Suite Repeater resending request](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/ba6c00636c7fdcb14cad7c5c896c2183-tm_burp_repeater_02.png)

Figure 17: Burp Suite Repeater resending request

Now that we have a baseline response, we will make a slight change to our original request. One interesting aspect of the baseline response is that it includes several _Access-Control_ headers. These headers usually indicate the application supports _Cross-Origin Resource Sharing_[1](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_137-1) (CORS). Our original request did not include an _origin_ header. Let's find out what happens if we send one. We'll add "Origin: hello.world" to the request and then click _Send_.

![Figure 18: Burp Suite sending a modified request](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/679f7af28e71c75f1315995c48e4fb62-tm_burp_repeater_03.png)

Figure 18: Burp Suite sending a modified request

In Figure 18, the response has a different _Access-Control-Allow-Origin_ value, which reflects the value we sent. To better compare the responses, we can use the _Comparer_ feature by right-clicking on the response and selecting _Send to Comparer_.

![Figure 19: Burp Suite send response to Comparer](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/132431bbd1f83b83c4cbcbbbe5a4f769-tm_burp_repeater_04.png)

Figure 19: Burp Suite send response to Comparer

Before we switch to the _Comparer_ tab, let's navigate back to our original request (Figure 20) and _Send to Comparer_ so that we have two different responses we can compare (Figure 19).

![Figure 20: Burp Suite Repeater previous request and response](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/3e4090660326fb1296e39200c6c0c118-tm_burp_repeater_05.png)

Figure 20: Burp Suite Repeater previous request and response

![Figure 19: Burp Suite send second response to Comparer](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/d7ab7aced2eb2d0f3a400c3fdc897db0-tm_burp_repeater_06.png)

Figure 19: Burp Suite send second response to Comparer

We can now switch to the _Comparer_ tab, where Burp Suite has automatically highlighted our different responses in their respective windows. At this point, we have the option of comparing the responses for differences in _Words_ or _Bytes_. We will choose the _Words_ option (Figure 21) since this example does not include a binary response.

![Figure 21: Burp Suite Comparer tab](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/46c523d269268fb5510a9560262e7b1d-tm_burp_comparer_01.png)

Figure 21: Burp Suite Comparer tab

Burp Suite displays the comparison results in a dedicated window (Figure 22), highlighting each change with color-coding for _Modified_, _Deleted_, and _Added_.

![Figure 22: Burp Suite Comparer tab - comparing Words](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/4b38e197d8812c8d2537595342e9cc0a-tm_burp_comparer_02.png)

Figure 22: Burp Suite Comparer tab - comparing Words

In this example, Burp Suite highlighted _Modified_ and _Deleted_ differences between the two responses. We previously identified the change to the _Access-Control-Allow-Origin_ value, but Comparer has also highlighted that the _Vary_ and _Access-Control-Allow-Credentials_ headers are present on the first response but not on the second.

While this is a very simple example, it shows how the _Repeater_ and _Comparer_ tools can be extremely valuable when testing a web application.

1

(Wikipedia, 2021), [https://en.wikipedia.org/wiki/Cross-origin_resource_sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_137-1)

### 2.1.5. Burp Suite Decoder

While inspecting modern web applications, we will often encounter encoded data in HTTP requests and responses. Fortunately, Burp Suite has a versatile decoder tool that is easy to use in our workflow.

As an example, let's switch to our browser and try logging in to the Concord application with "test" as our username and password. This returns "Invalid username and/or password". Let's switch back to Burp Suite. Interestingly, our browser sent a GET request to /api/service/console/whoami. Login requests are usually POSTs. Let's click on the new request.

The new GET request included an _authorization_ header with the value "Basic dGVzdDp0ZXN0". If we select the text "dGVzdDp0ZXN0", the Inspector tool will detect that it is base64-encoded and display the decoded text on the right-hand side of the Burp Suite window.

![Figure 23: Burp Suite login request](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/fba54ae93c9751bfed3f257057259afe-tm_burp_decoder_01.png)

Figure 23: Burp Suite login request

The Inspector tool is useful for quickly decoding common types of encoding within the HTTP history tab. Burp Suite's Decoder tool is a more-powerful version of the Inspector tool. Let's try it out by right-clicking on the highlighted text and selecting _Send to Decoder_.

![Figure 24: Burp Suite Send to Decoder feature](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/72f6805bc8509fc457396a3bd549fc6e-tm_burp_decoder_02.png)

Figure 24: Burp Suite Send to Decoder feature

Now if we switch to the _Decoder_ tab, we can choose the _Decode as_ option to the right and select _Base64_ for the encoding scheme (Figure 25).

![Figure 25: Burp Suite decoding the selected values](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/8bf6f080436cbef5a56cd11f90cb9ce9-tm_burp_decoder_03.png)

Figure 25: Burp Suite decoding the selected values

As a result, a second textbox with the decoded value opens below our original data.

![Figure 26: Burp Suite successfully decoded the selected values](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/90735a5c3c1fe160da6bea7b339a75ad-tm_burp_decoder_04.png)

Figure 26: Burp Suite successfully decoded the selected values

The decoded value matches the output from the Inspector tool, but the Decoder tool enables options for encoding, decoding, and hashing.

So far, we have only demonstrated a few basic, albeit useful, features of Burp Suite. This tool contains many more features that can be very helpful when researching complex modern web applications.

#### Exercises

1. Take some time to familiarize yourself with the Burp Suite proxy and its various capabilities.
2. Spend time learning more about the basic Burp Suite features[1](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_138-1) as this knowledge will improve the efficiency of your workflow.

1

(PortSwigger Ltd., 2020), [https://portswigger.net/burp/documentation](https://portswigger.net/burp/documentation) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_138-1)

## 2.2. Interacting with Web Listeners using Python

In this course, we will be creating complex web application exploits in Python.

If you are already well-versed in a different language and prefer to develop the solutions for the course exercises in that language, you are certainly welcome to do so.

However, Python has undergone a significant change lately. As of January 2020, Python 2 will no longer be supported and will be officially replaced by Python 3. However, many operating systems, including Debian, include Python 2 as the _python_ binary package and Python 3 as _python3_. For this reason, when we use python to run a script in this course, we are using Python 2 and when we use python3, we are using Python 3. In addition, certain libraries provided with Python 2 by default are being removed. To compensate for this, we have provided the _offsec-awae_ package (installed with sudo apt-get install offsec-awae) to install the missing libraries.

When using Python, we'll often use the _requests_ library to interact with our web applications. While there are many well-written _requests_ guides (including the official documentation[1](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_139-1)), we will demonstrate some basic examples in this module.

For example, the following script will issue an HTTP request to the ManageEngine[2](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_139-2) web server in the labs and output the details of the relative response:

```
01: import requests
02: from colorama import Fore, Back, Style
03:
04: requests.packages.urllib3.\
05: disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)
06: def format_text(title,item):
07:   cr = '\r\n'
08:   section_break = cr +  "*" * 20 + cr
09:   item = str(item)
10:   text = Style.BRIGHT + Fore.RED + title + Fore.RESET + section_break + item + section_break
11:   return text
12:
13: r = requests.get('https://manageengine:8443/',verify=False)
14: print(format_text('r.status_code is: ',r.status_code))
15: print(format_text('r.headers is: ',r.headers))
16: print(format_text('r.cookies is: ',r.cookies))
17: print(format_text('r.text is: ',r.text))
```

> Listing 2 - A basic requests library example

On lines 1-2 of Listing 2, we import the _requests_ module as well as a module to display output in different colors. Lines 4-5 disable the display of certificate warnings when requests are made to websites using insecure certificates. This can be useful in scenarios where targeted web applications use self-signed certificates as is the case in the AWAE labs.

Lines 6-11 implement a function to display the response headers and body in an organized way. On line 13, we set _r_ to the result of a GET request to the ManageEngine web server in the labs. Notice that in our request, we set the verify flag to "False". This prevents the library from verifying the SSL/TLS certificate. Finally, lines 14-17 demonstrate how to access a few common components of an HTTP server response.

Let's save this script as manageengine_web_request.py, run it, and check the details of the web server response:

```
kali@kali:~$ python3 manageengine_web_request.py 
r.status_code is: 
********************
200
********************

r.headers is: 
********************
{'Content-Length': '261', 'Set-Cookie': 'JSESSIONID_APM_9090=808639988060D663A797DF8EA8019F67; Path=/; Secure; HttpOnly', 'Accept-Ranges': 'bytes', 'Server': 'Apache-Coyote/1.1', 'Last-Modified': 'Fri, 09 Sep 2016 14:06:48 GMT', 'ETag': 'W/"261-1473430008000"', 'Date': 'Fri, 14 Sep 2018 12:51:15 GMT', 'Content-Type': 'text/html'}
********************

r.cookies is: 
********************
<RequestsCookieJar[<Cookie JSESSIONID_APM_9090=808639988060D663A797DF8EA8019F67 for manageengine.local/>]>
********************

r.text is: 
********************
<!-- $Id$ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- This comment is for Instant Gratification to work applications.do -->
<script>

	window.open("/webclient/common/jsp/home.jsp", "_top");

</script>

</head>
</html>

********************
```

> Listing 3 - Response output generated by our script request

The request was successful and the different parts of the HTTP response can easily be accessed as properties of the Python object (_r_).

We may need to debug the requests that are generated by our proof-of-concept Python scripts. Fortunately, the _requests_ library comes with built-in proxy support. To use it, we only need to add a Python dictionary object to our script containing the proxy IP address, port, and protocol, which will be used in our _requests.get_ function call. Let's update our script to include that.

```
01: import requests
02: from colorama import Fore, Back, Style
03:
04: requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)
05:
06: proxies = {'http':'http://127.0.0.1:8080','https':'http://127.0.0.1:8080'}
07: def format_text(title,item):
08:   cr = '\r\n'
09:   section_break = cr +  "*" * 20 + cr
10:   item = str(item)
11:   text = Style.BRIGHT + Fore.RED + title + Fore.RESET + section_break + item + section_break
12:   return text;
13:
14: r = requests.get('https://manageengine:8443/',verify=False, proxies=proxies)
15: print(format_text('r.status_code is: ',r.status_code))
16: print(format_text('r.headers is: ',r.headers))
17: print(format_text('r.cookies is: ',r.cookies))
18: print(format_text('r.text is: ',r.text))
```

> Listing 4 - Using Python requests proxy support

The updated script generates responses similar to those shown in Listing 3. This time however, we should be able to locate our request/response in the Burp Suite _History_ tab.

![Figure 27: Burp Suite History still shows only requests performed against the Concord server](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/a2921ccc181931c79e8d235e6e854ba9-tm_burp_web_01.png)

Figure 27: Burp Suite History still shows only requests performed against the Concord server

Unfortunately, after running our script, Burp Suite still only list requests to the Concord web server (Figure 27). This is because we forgot to add the ManageEngine target to our scope! This is an easy fix but first, we will need to re-enable the capture of out-of scope items in the _Proxy_ > _HTTP history_ tab where we'll click _Re-enable_ as shown in Figure 28.

![Figure 28: Re-enabling the out-of-scope traffic capture](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/21f5339a6edd92e750205300e1215ee2-tm_burp_web_02.png)

Figure 28: Re-enabling the out-of-scope traffic capture

Now we can re-run our Python script, navigate back to the _Target_ > _Site map_ tab, right-click on the ManageEngine URL, and select _Add to scope_ (Figure 29).

![Figure 29: Adding the ManageEngine server to scope](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/20eb9406e2e67aef88888719fed488c9-tm_burp_web_03.png)

Figure 29: Adding the ManageEngine server to scope

Finally, we can navigate to the _HTTP history_ tab, where we can inspect the captured ManageEngine request.

![Figure 30: Viewing the Python script request in the Proxy tab](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/c45894a9b50c402d848675770617ceb4-tm_burp_web_04.png)

Figure 30: Viewing the Python script request in the Proxy tab

At this point, we could also repeat the step from Figure 13, in order to only show in-scope items in our history.

While the previous example is rather simple in nature, it provides us with a starting point for proof-of-concept scripts we will develop in later modules.

#### Exercises

1. Repeat the steps outlined in this section and make sure you can intercept HTTP requests from the proof-of-concept script.
2. Familiarize yourself with the _requests_ Python library as we will leverage it extensively in the complex scripts we'll create in later modules.

1

(Python Software Foundation, 2017), [http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_139-1)

2

(ManageEngine, 2020), [https://www.manageengine.com/](https://www.manageengine.com/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_139-2)

## 2.3. Source Code Recovery

As we mentioned in the introduction, we must learn how to recover the source code from web applications written in compiled languages. In this course, we will be focusing mainly on Java and .NET source code recovery, as they are directly related to the vulnerable applications we will explore.

### 2.3.1. Managed .NET Code

Later in the course, we will deal with a vulnerable version of the DotNetNuke[1](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_141-1) .NET web application. This also implies that we will need to decompile managed .NET executable files. Once again, there are a number of tools we can use to accomplish this goal, some of which even integrate seamlessly with Visual Studio. Most commonly-used .NET decompilers can also be used as debuggers.

With that said, we will use the freely-available _dnSpy_[2](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_141-2) decompiler and debugger for this purpose, as it provides all we need. Specifically, _dnSpy_ uses the _ILSpy_[3](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_141-3) decompiler engine to extract the source code from a .NET compiled module.

#### Decompilation

Let's use a simple C# program to demonstrate a very basic workflow for decompiling .NET executables. First, we'll connect to the DNN lab machine through remote desktop from Kali. The credentials are listed in the course material.

```
kali@kali:~$ xfreerdp +nego +sec-rdp +sec-tls +sec-nla /d: /u: /p: /v:dnn /u:administrator /p:studentlab /size:1180x708
```

> Listing 5 - Using xfreerdp to connect to the DNN VM

Depending on our version of FreeRDP, we might receive an _ERRCONNECT_TLS_CONNECT_FAILED_ message when attempting to connect to the DNN machine. If so, we need to append **/tls-seclevel:0** to the end of our command to allow for any TLS level on our connection.

Next, let's use Notepad++ to create a text file on the Windows virtual machine Desktop with the following code:

```
using System;

namespace dotnetapp
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("What is your favourite Web Application Language?");
            String answer = Console.ReadLine();
            Console.WriteLine("Your answer was: " + answer + "\r\n");
        }
    }
}
```

> Listing 6 - A basic C# application

We will save this file as test.cs. In order to compile it, we'll use the csc.exe[4](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_141-4) compiler from the .NET framework.

```
c:\Users\Administrator\Desktop>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe test.cs
```

> Listing 7 - Compiling the test executable

![Figure 31: Using CSC.exe to compile](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/4a4e6a1492b02860903aa8a3bf756a21-Picture33.png)

Figure 31: Using CSC.exe to compile

Once our test.exe is created, let's execute it to make sure it works properly.

```
c:\Users\Administrator\Desktop>test.exe
What's your favorite web application language?
C-Sharp
Your answer was: C-Sharp
```

> Listing 8 - Testing the sample executable

We can now open dnSpy and attempt to decompile this executable's code. We'll drag the test.exe file to the dnSpy window, which automatically triggers the decompilation process in dnSpy.

![Figure 32: Test.exe in dnSpy](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/4d0cabad257fc100a68550f34962e633-Picture34_a.png)

Figure 32: Test.exe in dnSpy

To view the source code of this executable, we'll have to expand the _test_ assembly navigation tree and select _test.exe_, _dotnetapp_, and then _Program_, as shown in Figure 33. According to the output, the decompilation process was successful.

![Figure 33: Navigating to the decompiled source code](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/bbe263a5b32921306b5db0d744cfe791-Picture35.png)

Figure 33: Navigating to the decompiled source code

Excellent! We successfully decompiled the executable.

#### Cross-References

When analyzing and debugging more complex applications, one of the most useful features of a decompiler is the ability to find cross-references[5](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_141-5) to a particular variable or function. We can use cross-references to better understand the code logic. For example, we can monitor the execution flow statically or set strategic breakpoints[6](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_141-6) to debug and inspect the target application. We can demonstrate the effectiveness of cross-references in this process with a simple example.

Let's suppose that while studying our DotNetNuke target application, we noticed a few Base64-encoded values in the HTTP requests captured by Burp Suite. Since we would like to better understand where these values are decoded and processed within our target application, we could make the assumption that any functions that handle Base64-encoded values contain the word "base64".

We'll follow this assumption and start searching for these functions in dnSpy. For a thorough analysis we should open all the .NET modules loaded by the web application in our decompiler. However, for the purpose of this exercise, we'll only open the main DNN module, C:\inetpub\wwwroot\dotnetnuke\bin\DotNetNuke.dll, and search for the term "base64" within method names as shown in Figure 34.

![Figure 34: Opening DotNetNuke.dll](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/def3ed93fa7795cf2b6558b5446457ed-Picture44b.png)

Figure 34: Opening DotNetNuke.dll

The search result provides us with a list of method names containing the term "base64"(shown in Figure 35).

![Figure 35: Searching for a base64 string](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/bd0bc1c3c5a54f0bd9cfdcde02466776-Picture43.png)

Figure 35: Searching for a base64 string

Let's pick one of the functions and try to find its cross-references. We'll select the _Base64UrlDecode_ function by right-clicking on it and selecting _Analyze_ from the context menu.

![Figure 36: Analyzing a function](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/be7c1faee9d546eadb07d27020fa4dae-Picture44.png)

Figure 36: Analyzing a function

The results should appear in the _Analyzer_ window. Specifically, expanding the function name reveals two options: _Used By_ and _Uses_ (Figure 37).

![Figure 37: Finding cross-references for a given function](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/fdc5cf54234b6e3e46eebdbf90bf2db4-Picture45.png)

Figure 37: Finding cross-references for a given function

As the name suggests, the _Used By_ node expands to reveal where our example function is called within the target DLL. This is extremely useful when analyzing source code. If we now click on the cross-reference, dnSpy reveals the location of the function call in the source code (Figure 38).

![Figure 38: Showing the cross-reference in the source code](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/ea8784c4970e25af4198b87af95e677f-Picture45a.png)

Figure 38: Showing the cross-reference in the source code

#### Modifying Assemblies

Finally, let's demonstrate how to arbitrarily modify assemblies. We can use this technique to add debugging statements to a log file or alter an assembly's attributes in order to better debug our target application.

In order to demonstrate this technique, we will briefly return to our previous custom executable file and edit it using dnSpy. Let's right-click _Program_ and choose _Edit Class_ (Figure 39).

![Figure 39: Editing a class in dnSpy](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/a8d8a85ac9b2f936553ad996b9749af5-Picture36.png)

Figure 39: Editing a class in dnSpy

Then we'll change "Your answer was: " to "You said: " (Figure 40).

![Figure 40: Modifying code the source code with dnSpy](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/2511ac707a4d3e932e769229deb4e430-Picture38.png)

Figure 40: Modifying code the source code with dnSpy

And finally, we'll click _Compile_, then _File_ > _Save All_ to overwrite the original version of the executable file (Figure 41 and Figure 42).

![Figure 41: Saving our modified assembly](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/9d929b826e6a28a76eeea2bedfa78960-Picture40.png)

Figure 41: Saving our modified assembly

![Figure 42: Replacing our original test.exe file](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/98dc5ab0f81f888b8ea193dcaf4bda47-Picture41.png)

Figure 42: Replacing our original test.exe file

If we return to our command prompt and re-run test.exe, the second print statement is now "You said: " (Figure 43).

![Figure 43: Running an edited executable](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/cf6f17b2c23dd05c2b41f638932736c6-Picture42.png)

Figure 43: Running an edited executable

Using a very basic example application, we have demonstrated how to recover the source code of .NET-based applications and how to find cross-references with the help of our favorite decompiler. We also demonstrated how to modify and save a .NET assembly file. Even if this modification doesn't seem particularly useful, it will come in handy later on in the course when we will have to alter assemblies' attributes in order to better debug our target application.

1

(DNN Corp., 2020), [https://www.dnnsoftware.com/](https://www.dnnsoftware.com/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_141-1)

2

(0xd4d, 2020), [https://github.com/0xd4d/dnSpy](https://github.com/0xd4d/dnSpy) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_141-2)

3

(ICSharpCode , 2020), [https://github.com/icsharpcode/ILSpy](https://github.com/icsharpcode/ILSpy) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_141-3)

4

(MicroSoft, 2021), [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_141-4)

5

(Wikipedia, 2021), [https://en.wikipedia.org/wiki/Cross-reference](https://en.wikipedia.org/wiki/Cross-reference) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_141-5)

6

(Wikipedia, 2019), [https://en.wikipedia.org/wiki/Breakpoint](https://en.wikipedia.org/wiki/Breakpoint) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_141-6)

### 2.3.2. Decompiling Java Classes

While there are many tools that we could use to decompile Java bytecode (with various degrees of success), we will use the _JD-GUI_ decompiler in this course. Java-based web applications primarily consist of compiled Java class files that are compressed into a single file, a Java ARchive, or JAR, file. Using JD-GUI, we can extract the class files and subsequently decompile them back to Java source code.

Let's demonstrate decompilation in JD-GUI with a test JAR file. We'll create JAR/test.java on our Kali machine:

```
import java.util.*;

public class test{
	public static void main(String[] args){
		Scanner scanner = new Scanner(System.in);
		System.out.println("What is your favorite Web Application Language?");
		String answer = scanner.nextLine();
		System.out.println("Your answer was: " + answer);
	}
}
```

> Listing 9 - A simple Java application

This basic Java application prompts for the user's favorite language and prints the answer to the console. As part of the compilation process, we also set the Java source and target versions to 1.8, which is the current long-term suggested version from Oracle (Listing 10).

For this section, we will need a Java Development Kit (JDK) to compile the Java source. If it is not already installed, we can install it in Kali with "sudo apt install default-jdk".

```
kali@kali:~$ javac -source 1.8 -target 1.8 test.java
warning: [options] bootstrap class path not set in conjunction with -source 1.8
1 warning
```

> Listing 10 - Setting the relative Java version during compilation

After compiling the source code, test.class is written to our JAR directory. In order to package our class as a JAR file, we will need to create a manifest file.[1](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_142-1) This is easily accomplished by creating the JAR/META-INF directory and adding our test class to the MANIFEST.MF file as shown below.

```
kali@kali:~$ mkdir META-INF

kali@kali:~$ echo "Main-Class: test" > META-INF/MANIFEST.MF
```

> Listing 11 - Creating the manifest for the JAR test file

We can now create our JAR file by running the following command:

```
kali@kali:~$ jar cmvf META-INF/MANIFEST.MF test.jar test.class
added manifest
adding: test.class(in = 747) (out= 468)(deflated 37%)
```

> Listing 12 - Creating the JAR test file

Let's test our example class to make sure it's working properly:

```
kali@kali:~$ java -jar test.jar
What is your favorite Web Application Language?
Java
Your answer was: Java
```

> Listing 13 - Testing the JAR test file

Great! Now that we know our JAR file works, let's copy it to the machine running JD-GUI. In our lab, this is the ManageEngine virtual machine. One easy way to transfer files is via SMB with an _Impacket_ script. In our JAR directory, we will issue the following command:

![Figure 44: Creating a temporary SMB Server on Kali Linux](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/7778031deb92d473adacb13a9830c172-Picture28.png)

Figure 44: Creating a temporary SMB Server on Kali Linux

With our Samba server running, we need to connect to the ManageEngine server with xfreerdp. Refer to the course materials for the correct RDP credentials.

```
kali@kali:~$ xfreerdp +nego +sec-rdp +sec-tls +sec-nla /d: /u: /p: /v:manageengine /u:administrator /p:studentlab /size:1180x708
```

> Listing 14 - Using xfreerdp to connect to the ManageEngine VM

Depending on our version of FreeRDP, we might receive an _ERRCONNECT_TLS_CONNECT_FAILED_ message when attempting to connect to the ManageEngine machine. If so, we need to append **/tls-seclevel:0** to the end of our command to allow for any TLS level on our connection.

Once connected to the ManageEngine server, we'll use Windows Explorer to navigate to our Kali SMB server using the \\your-kali-machine-ip\test path. We'll then copy test.jar to the desktop of the ManageEngine virtual machine. Finally, we can open JD-GUI using the taskbar shortcut and drag our JAR file on its window.

![Figure 45: Opening a jar file in JD-GUI to decompile it](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/6eb6b46c5bfff2ab61b0d04375ad0154-Picture30.png)

Figure 45: Opening a jar file in JD-GUI to decompile it

At this point, we should be able to use the left navigation pane to navigate to the decompiled code in JD-GUI, as shown in Figure 46.

![Figure 46: Navigating the decompiled source code](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/559b6df0ce7b00de5a995bc1a6f217c2-Picture31.png)

Figure 46: Navigating the decompiled source code

In a manner similar to the cross-reference analysis we performed with dnSpy, we can also search the decompiled classes for arbitrary methods and variables with JD-GUI. However, the user interface is non-intuitive and may be cumbersome when used with large and complex applications.

![Figure 47: Searching for arbitrary strings in JD-GUI](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/59fd1a7e19262441b2bd43b839839485-Picture47.png)

Figure 47: Searching for arbitrary strings in JD-GUI

We will present techniques for overcoming these limitations in a later module.

#### Exercise

Try to decompile and explore additional .NET and Java compiled files in order to become more familiar with the dnSpy and JD-GUI user interfaces. There are many JAR files in the C:\Program Files (x86)\ManageEngine\AppManager12\working\classes directory on the ManageEngine lab machine and .NET managed modules in the C:\inetpub\wwwroot\dotnetnuke\bin directory on the DNN machine.

1

(Oracle, 2020), [https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html](https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_142-1)

## 2.4. Source Code Analysis Methodology

Once we have obtained the source code, we're ready to tackle source code analysis, which is arguably the hardest technique to master in our workflow. This is due to the prolific use of third-party frameworks in modern web applications, which can obscure the flow of data. Our analysis is further complicated by the variety of coding practices and styles.

Because of this, we should spend some time walking through the web application in a browser to familiarize ourselves with its functionality before we dive in to source code analysis. We should proxy our browser traffic through Burp Suite while we are doing this so that we can analyze the HTTP requests and responses generated during normal use of the application. We might be able to learn which technologies are in use and how the application maps routes and passes data based on this information. The information we gather during this walkthrough can help us refine our focus during source code analysis.

An application's attack surface depends on many factors including its intended use cases and its software stack. For example, a web application that hosts user content might have more instances of cross-site scripting than an application that moves files between different servers. Similarly, programming languages and frameworks can also influence the types of vulnerabilities that might exist in the application. However, we should not automatically exclude any types of vulnerabilities from our analysis.

### 2.4.1. An Approach to Analysis

When we are analyzing application source code, we need to be mindful of _sources_ and _sinks_. Data enters an application through a source, and is used (or operated on) in a sink.

Let's consider a typical login flow. We submit a user name and password to the application in a POST request. The code that handles this POST request is a source. The code may then run some input validation on the username and password values and then execute a database query with those values. The call to the database to run the query is the sink in this scenario.

Our approach to manual source code analysis will vary depending on whether we choose to begin with the examination of sources or sinks.

In a "top down" approach, we would identify sources first. If we do not have authenticated access to the web application, we would obviously begin searching for vulnerabilities in unauthenticated resources. Tracing the application flows to their respective sinks, we would then attempt to identify any sensitive functionality and determine what controls are in place (such as input validation).

In a "bottom up" approach, we would first identify sinks. Our goal would be to determine if any sinks contain vulnerabilities and what variables or values the vulnerable code uses. We would then need to determine how the application calls the vulnerable function and trace the application flow back to a source. As with the "top down" approach, we need to be mindful of any filters or input sanitization that might affect the payload needed to exploit the vulnerable function.

A "bottom up" approach is more likely to result in higher-severity vulnerabilities with a lower likelihood of exposure. A "top down" approach, however, is likely to uncover lower-severity vulnerabilities with a higher likelihood of exposure. For example, vulnerabilities discovered during a "bottom up" approach might allow admin users to gain remote code execution. On the other hand, vulnerabilities discovered in a "top down" approach might allow any user to exploit cross-site scripting.

Because of this, we may need to tailor our approach if we are searching for a particular type of vulnerability or we may need to vary our approach based on what we find in a given application. These approaches are not meant to be rigid. With time and practice, we will learn the valuable skill of adapting our methodologies and altering our techniques.

Regardless of which approach we use, our end goals are the same: we want to identify vulnerabilities or logic errors in the application, determine how to call the vulnerable code, and bypass restrictions.

### 2.4.2. Using an IDE

An _integrated development environment_[1](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_145-1) (IDE) is a powerful tool for source code analysis. Most IDEs can perform advanced code search and debugging. The "best" IDE is often a matter of personal preference. In this course, we rely heavily on _Visual Studio Code_[2](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_145-2) since it supports multiple programming languages via extensions. However, we will also leverage specialized tools such as dnSpy. As our personal methodology evolves, the process of choosing the best tool and applying it properly will become more natural.

During a manual source code analysis, we'll spend a great deal of time searching code and refining our searches.

Let's begin with a simple example in which we attempt to review the login functionality of an application. We could begin with a search for "password".

![Figure 48: Searching for password](https://static.offsec.com/offsec-courses/WEB-300/images/sca/d3b5ba1562eedca0f1afabb8631c2b50-sca_search_01.png)

Figure 48: Searching for password

This produces many results from several different types of files, and unfortunately, many of the results are useless.

![Figure 49: Search results](https://static.offsec.com/offsec-courses/WEB-300/images/sca/67684ef06604286533c44c0464abd2c4-sca_search_02.png)

Figure 49: Search results

What we do next depends on our personal methodology. We might choose to review the HTML files to determine how the login or password reset forms are set up. The JavaScript files might contain client-side logic or "secret" values. However, we could start with the application code, which, in this example, means the Java source files.

Either way, we can refine our search by clicking the _Toggle Search Details_ button (represented by three dots).

![Figure 50: Toggle Search Details button](https://static.offsec.com/offsec-courses/WEB-300/images/sca/8d84460e9957dd5111b77e4c8a614f13-sca_search_03.png)

Figure 50: Toggle Search Details button

With Search Details toggled on, we can refine our search to include or exclude certain file types. For example, we could limit our search to only Java files by entering ".java" in the _files to include_ field. As with any search filter, we want to avoid "over-filtering", which may exclude important results, essentially creating false negatives.[3](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_145-3) We can also use regular expressions in Visual Studio Code searches. We'll demonstrate this in a later module.

If a search term returns too many results, we could use unique keywords from the application to narrow the search results. Some sources for keywords include application web pages, requests, and error messages. For example, if the login page of a target application returns an "Incorrect credentials" message, we could search for that text to find where the error is thrown and work backwards to discover the login function.

If we identify a vulnerable function and need to determine where the application uses it, we can search for "references" (in most IDEs) to locate application methods or function calls. To do this in Visual Studio Code, we simply right-click on a function or method name to open a context menu and _Find All References_.

![Figure 51: Find All References](https://static.offsec.com/offsec-courses/WEB-300/images/sca/41f8e3d8c31469be0c3db260b2c6a22a-sca_search_04.png)

Figure 51: Find All References

Visual Studio Code lists the results on the left side of the window.

![Figure 52: Reference Results](https://static.offsec.com/offsec-courses/WEB-300/images/sca/4448fdb32baf2f1d6fe03e5d6486bdd4-sca_search_05.png)

Figure 52: Reference Results

1

(Wikipedia, 2021), [https://en.wikipedia.org/wiki/Integrated_development_environment](https://en.wikipedia.org/wiki/Integrated_development_environment) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_145-1)

2

(Microsoft, 2022), [https://code.visualstudio.com/](https://code.visualstudio.com/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_145-2)

3

(Wikipedia, 2021), [https://en.wikipedia.org/wiki/False_positives_and_false_negatives](https://en.wikipedia.org/wiki/False_positives_and_false_negatives) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_145-3)

### 2.4.3. Common HTTP Routing Patterns

We will spend a lot of time searching through source code to understand how an application receives an HTTP request and determines what code to run to generate the associated HTTP response. This is known as _HTTP Routing_. This information is important regardless of how we approach source code analysis. Our goal is to trace the flow of a request through the application. The web server, programming language, and framework used by an application all influence its HTTP routing configuration. Let's review a few common HTTP routing patterns.

_File System Routing_ maps the URL of a request to a file on the server's filesystem. In this scheme, the web server defines a _document root_ (also known as a web root), where it stores externally accessible files. For example, the Apache HTTP Server on Ubuntu uses /var/www/html as its default document root.[1](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_146-1) When the server receives an HTTP request, the server inspects the path of the URL and tries to find a file that matches the path in the document root. In other words, if we request http://example.com/funnyCats.html, the server would serve the file located at /var/www/html/funnyCats.html. If the server cannot find that file, it will instead respond with a 404 message.

Some Java applications use _Servlet Mappings_ to control how the application handles HTTP requests. In Java web applications, "servlet" is a shorthand for the classes that handle requests, such as HTTP requests. In general, they implement code that accepts a request and returns a response. A web.xml file stores the HTTP routing configuration. While there can be multiple entries in a web.xml file, each route is made up of two entries: one entry to define a servlet and a second entry to map a URL to a servlet.

Let's review an example.

```
<!-- SubscriptionHandler-->
<servlet id="SubscriptionHandler">
  <servlet-name>SubscriptionHandler</servlet-name>
  <servlet-class>org.opencrx.kernel.workflow.servlet.SubscriptionHandlerServlet</servlet-class>
	</servlet>
...
<servlet-mapping>
  <servlet-name>SubscriptionHandler</servlet-name>
	<url-pattern>/SubscriptionHandler/*</url-pattern>
</servlet-mapping>
```

> Listing 15 - Excerpt from a web.xml file for OpenCRX

In this example, the web.xml file defines a servlet with the "SubscriptionHandler" id for the _org.opencrx.kernel.workflow.servlet.SubscriptionHandlerServlet_ class. A "servlet-mapping" entry maps the /SubscriptionHandler/* URL to the SubscriptionHandler. The star character indicates a wildcard. The servlet class is responsible for parsing the URL path and deciding what to do with HTTP requests.

Some programming languages and frameworks include routing information directly in the source code. For example, ExpressJS uses this method of routing:

```
var express = require('express');
var router = express.Router();
...

router.get('/login', function(req, res, next) {
  res.render('login', { title: 'Login' });
});
```

> Listing 16 - Example Express.js routing From DocEdit

A variant of this approach is routing by annotation or attribute. The _Spring MVC_[2](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_146-2) framework for Java and the _Flask_[3](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_146-3) framework for Python, among others, use this approach. The source code declares an annotation or attribute next to the method or function that handles the HTTP request.

```
@GetMapping({"/admin/users"})
public String getUsersPage(HttpServletRequest req, Model model, HttpServletResponse res) {
...
```

> Listing 17 - Example Spring MVC annotation

In this example, the server calls the _getUsersPage()_ method when it receives a GET request to the /admin/users URL path. There are also annotations that handle request mapping for different HTTP methods or more complex URI paths.

These are basic HTTP routing examples. Each programming language and framework offers variations, but most will resemble those covered above. We'll explore additional routing methods in various other modules in this course.

1

(Apache Software Foundation, 2020), [https://httpd.apache.org/docs/2.4/urlmapping.html](https://httpd.apache.org/docs/2.4/urlmapping.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_146-1)

2

(Spring, 2016), [https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-controller](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-controller) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_146-2)

3

(Pallets, 2010), [https://flask.palletsprojects.com/en/1.1.x/quickstart/#routing](https://flask.palletsprojects.com/en/1.1.x/quickstart/#routing) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_146-3)

### 2.4.4. Analyzing Source Code for Vulnerabilities

We believe that there is simply no adequate substitute for a manual code review since many coding nuances and complex code paths to vulnerable functions are often missed by automated tools. While we certainly do not rely solely on automated source code analysis tools, it is important to mention them as they do serve a purpose. Specifically, these tools are generally very capable of identifying "low-hanging fruit" vulnerabilities, which can save time. Generally speaking, although they also identify a large number of false positive results in a given application, even these results can help us identify dead-ends in the code, which once again saves us time.

There is no doubt that manual reviews are very time-consuming but the knowledge gained through this process builds upon itself over time. This knowledge can help us discover more complex vulnerabilities, which may have otherwise gone undetected.

As with most security testing, our goal is to strike a balance between time, effort, and quality. We might miss vulnerabilities in large applications during code reviews and penetration tests due to time constraints and prioritization.

For example, it's common to place external libraries and dependencies lower on the priority list than application source files. This trade-off is usually made on the assumption that an external library might have a vulnerability, but the application being analyzed might never call the vulnerable feature of the dependency. However, in smaller applications, pivoting to analyze external libraries and dependencies may expand our attack surface if the application relies on them heavily.

With this in mind, there are many high-priority items to consider when performing manual source code analysis. This high-level list is presented in no particular order:

- After checking unauthenticated areas, focus on areas of the application that are likely to receive less attention (i.e. authenticated portions of the application).
- Investigate how sanitization of the user input is performed. Is it done using a trusted, open-source library, or is a custom solution in place?
- If the application uses a database, how are queries constructed? Does the application parameterize input or simply sanitize it?
- Inspect the logic for account creation or password reset/recovery routines. Can the functionality be subverted?
- Does the application interact with its operating system? If so, can we modify commands or inject new ones?
- Are there programming language-specific vulnerabilities?

This list could be expanded exponentially. We will cover these items and more throughout the course. A personal methodology and depth of knowledge for manual source code analysis grows over time. Analyzing source code to identify vulnerabilities will help us build our own methodology. By understanding how these vulnerabilities are coded, we can apply our knowledge to other applications, even those that are closed-source.

## 2.5. Debugging

One of the best ways to understand an application is to run it through a debugger, which allows us to inspect application memory and call stacks. This information can be invaluable when crafting an exploit. Some debuggers also support debugging a process running on a remote system. This is known as _remote debugging_.

Debugging reveals the inner-workings of the application at runtime. To get similar information from databases, we can enable database query logging while we are testing an application. We will use database query logging in other modules.

Let's try debugging a simple Java application using Visual Studio Code. We will need to install two plugins: the RedHat _Language Support for Java_[1](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_148-1) and the Microsoft _Debugger for Java_.[2](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_148-2)

Let's create a sample Java application that generates a random number and asks us to guess the number. We will create a new directory named debug and create DebuggerTest.java which contains the following code:

```
import java.util.Random;
import java.util.Scanner;

public class DebuggerTest {

  private static Random random = new Random();
  public static void main(String[] args){
    int num = generateRandomNumber();
		Scanner scanner = new Scanner(System.in);
		System.out.println("Guess a number between 1 and 100.");
		try{
      int answer = scanner.nextInt();
      scanner.close();
      System.out.println("Your guess was: " + answer);
      if(answer == num) {
        System.out.println("You are correct!");
      } else {
        System.out.println("Incorrect. The answer was " + num);
      }
    } catch(Exception e) {
      System.out.println("That's not a number.");
    } finally {
      scanner.close();
    }
    System.exit(0);
  }

  public static int generateRandomNumber() {
    return random.nextInt(100)+1;
  }
}
```

> Listing 18 - Another simple Java Application

We can debug this application right from our IDE, but first we need to set a breakpoint by clicking to the left of line numbers. Let's set one on line 8.

![Figure 53: A breakpoint is set on line eight](https://static.offsec.com/offsec-courses/WEB-300/images/sca/6cd042f7f785d29aa91091dfe6982b52-sca_debug_01.png)

Figure 53: A breakpoint is set on line eight

A red dot will appear next to the line number at the location of our breakpoint. Now that we have set a breakpoint, we can debug the application by clicking on _Run_, then _Run and Debug_.

![Figure 54: Run and Debug](https://static.offsec.com/offsec-courses/WEB-300/images/sca/05777adb8ea137d454cfa0fc8965aa2c-sca_debug_02.png)

Figure 54: Run and Debug

The debugger will start running our code until it hits the breakpoint. Once execution reaches the breakpoint, the program will pause, and our IDE will highlight the line where execution paused.

![Figure 55: Breakpoint is reached](https://static.offsec.com/offsec-courses/WEB-300/images/sca/7f21d47a2dde22aa1f046d4557c89dd3-sca_debug_03a.png)

Figure 55: Breakpoint is reached

We also have a new debugging context menu. The buttons, from left to right, are _Continue_, _Step Over_, _Step Into_, _Step Out_, _Restart_, _Stop_, and _Hot Code Replace_. Let's briefly discuss each of these.

If we click _Continue_, the application will resume execution until it completes or hits another breakpoint. _Step Over_ allows the next method call to execute and will pause execution at the next line in the current method. In our case, it would execute the call to _generateRandomNumber()_ then pause when execution returns to line 9. _Step Into_ would follow the execution flow into _generateRandomNumber()_ and pause on line 28. _Step Out_ allows the current method to run and then pauses when execution is passed back "one level". If we pressed _Step Out_ while execution was paused in the _main()_ method, execution would complete. If we pressed it while in the _generateRandomNumber()_ method, execution would return to _main()_ and then pause again. _Restart_ and _Stop_ are self-explanatory.

_Hot Code Replace_ allows us to modify the source file and push changes to the executing process. However, this feature isn't available in all programming languages.

Let's click _Step Over_.

![Figure 56: The Variables have been updated](https://static.offsec.com/offsec-courses/WEB-300/images/sca/1684451894219167b15cd8d81e26e47d-sca_debug_04.png)

Figure 56: The Variables have been updated

The debugger has now paused execution on line 9 and the Variables window has updated to display the value of the _num_ variable. We can also get the value of a variable by hovering our mouse cursor over it. Let's click _Continue_ to allow the application to run. We can now "predict" the correct number every time we play this game.

1

(Microsoft, 2022), [https://marketplace.visualstudio.com/items?itemName=redhat.java](https://marketplace.visualstudio.com/items?itemName=redhat.java) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_148-1)

2

(Microsoft, 2022), [https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-debug](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-debug) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_148-2)

### 2.5.1. Remote Debugging

Remote debugging allows us to debug a process running on a different system as long as we have access to the source code and the debugger port on the remote system.

Let's try it out on a Java application. The JAR file and a ZIP file containing the source code are available on the Wiki VM which can be started from the _Labs_ page. We will extract the ZIP file, add the files to Visual Studio Code by clicking on _File_ > _Open Folder_, and then select the extracted NumberGame directory.

![Figure 57: NumberGame Explorer view](https://static.offsec.com/offsec-courses/WEB-300/images/sca/a943930ee46e1667263f81f143857561-sca_remote_01.png)

Figure 57: NumberGame Explorer view

Let's open MainController.java and set a breakpoint on line 22. Our IDE might underline some imports or objects in the file because we haven't configured our build path. We should still be able to debug the code despite these warnings. However, if the application executes code from within a source file that we do not have, we wouldn't be able to follow the execution into that file.

Let's add the dependencies to VS Code. We can extract them from the JAR file. The _@SpringBootApplication_ annotation in NumberGameApplication.java indicates this is a Spring Boot application. We can find the dependencies in /BOOT-INF/lib/ inside the JAR file. VS Code should automatically import the dependencies if we place them in a lib directory inside the NumberGame directory.

```
kali@kali:~$ unzip -j NumberGame.jar "BOOT-INF/lib/*" -d NumberGame/lib/ 
Archive:  NumberGame.jar
 extracting: NumberGame/lib/thymeleaf-spring5-3.0.12.RELEASE.jar  
 extracting: NumberGame/lib/thymeleaf-extras-java8time-3.0.4.RELEASE.jar  
 extracting: NumberGame/lib/spring-webmvc-5.3.4.jar  
 extracting: NumberGame/lib/spring-web-5.3.4.jar  
 extracting: NumberGame/lib/spring-boot-autoconfigure-2.4.3.jar  
 extracting: NumberGame/lib/spring-boot-2.4.3.jar  
...
```

> Listing 19 - Using unzip to extract dependencies

Once the dependencies are extracted, VS Code should be able to resolve all the dependencies. We can verify the dependencies were loaded properly by clicking on _Java Project_ in the lower-left section of VS Code.

![Figure 58: Java Projects tab](https://static.offsec.com/offsec-courses/WEB-300/images/sca/eeb15d847231e828a7bf075dff5e4156-sca_remote_10.png)

Figure 58: Java Projects tab

Once the Java Projects pane expands, we can click on _Project and External dependencies_ to expand the list of dependencies and verify that the extracted JARs are listed.

![Figure 59: References Libraries](https://static.offsec.com/offsec-courses/WEB-300/images/sca/87d6f1df9ee46a108def81118d662484-sca_remote_11a.png)

Figure 59: References Libraries

If the JAR files are not listed, we can add them manually by clicking the _+_ button next to Project and External Dependencies and selecting them from the resulting file window.

Now that we have the dependencies added, we will need a launch.json file to perform remote debugging. Visual Studio Code will create one for us if we click on the _Run_ shortcut and then click _create a launch.json file_.

![Figure 60: Create a launch.json file](https://static.offsec.com/offsec-courses/WEB-300/images/sca/6498af699fd49d58a32b19b25e4b7dfc-sca_remote_02.png)

Figure 60: Create a launch.json file

After a few moments, launch.json should open in an Editor window. If the Editor window does not open, we can find the new file in the .vscode directory. We can ignore the default configurations. We will create a new configuration for remote debugging by clicking _Add Configuration..._ and then _Java: Attach to Remote Program_ on the pop-up menu.

![Figure 61: Adding a new configuration](https://static.offsec.com/offsec-courses/WEB-300/images/sca/6cd53b86d7e0d18359f71b64985e515a-sca_remote_03.png)

Figure 61: Adding a new configuration

We need to update the "hostName" value to "127.0.0.1" and the "port" value to 9898. We'll then save the changes.

![Figure 62: Remote debugging configuration](https://static.offsec.com/offsec-courses/WEB-300/images/sca/e5eabc5d844a4a520729dd5813d8653f-sca_remote_04.png)

Figure 62: Remote debugging configuration

Now that we have configured launch.json, we can run the JAR file with debugging enabled. We will include the -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9898 flag to enable debugging on port 9898.[1](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fn-local_id_149-1) Since we are only specifying a port number in the _address_ option, the debugger socket will only listen on localhost.

```
kali@kali:~$ java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9898 -jar NumberGame.jar 
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
Listening for transport dt_socket at address: 9898
...
2021-03-02 14:14:40.887  INFO 11376 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8000 (http) with context path ''
2021-03-02 14:14:40.896  INFO 11376 --- [           main] com.offsec.awae.NumberGameApplication    : Started NumberGameApplication in 2.509 seconds (JVM running for 3.11)
```

> Listing 20 - Starting the NumberGame jar

Now that the application has started, we can access it on port 8000 with our browser.

![Figure 63: Number Guessing Game loaded in browser](https://static.offsec.com/offsec-courses/WEB-300/images/sca/ffab92731839f43b4bf86430e0f67549-sca_remote_05.png)

Figure 63: Number Guessing Game loaded in browser

Before we submit a value, let's start our debugger. In VS Code, we need to click on the _Run_ button if the Run view isn't still open. Then we will click on the dropdown menu next to the green arrow and click _Attach to Remote Program_.

![Figure 64: Selecting a Run configuration](https://static.offsec.com/offsec-courses/WEB-300/images/sca/68e6314b0a0de0558036b121bd3a97ca-sca_remote_06.png)

Figure 64: Selecting a Run configuration

Now that we have selected the configuration we want, we can start the debugger by clicking the _Start Debugging_ button (the green arrow).

Depending on our configuration, we might receive a pop-up asking for us to switch the Java language server to run in Standard mode. We can click _Yes_ on this pop-up.

![Figure 65: Switching Java Language Server to Standard Mode](https://static.offsec.com/offsec-courses/WEB-300/images/sca/393a053a2e1c700e1a93f90fbf7da71b-sca_remote_09.png)

Figure 65: Switching Java Language Server to Standard Mode

Once the debugger has established a connection with the remote program, the debugging context menu should open. We can verify everything is working by submitting a number on the web page and checking if the debugger pauses on our breakpoint.

![Figure 66: Breakpoint has been hit](https://static.offsec.com/offsec-courses/WEB-300/images/sca/eb44779b07b56406b170de56b96a7a0d-sca_remote_07.png)

Figure 66: Breakpoint has been hit

The debugger reached the breakpoint and paused execution. Let's click _Step Over_ twice to break execution on line 26. We'll click on _this: Main Controller_ in the Variables window to find the value of the _answer_ variable.

![Figure 67: Finding the value of](https://static.offsec.com/offsec-courses/WEB-300/images/sca/0dc6e9729f454f9cd90642e482c72c6c-sca_remote_08.png)

Figure 67: Finding the value of "answer"

Now that we have the answer, we can click _Continue_ to let execution resume. We can submit another request with the correct answer. When we are finished with the debugger connection, we can click _Disconnect_. We can then switch to our terminal and press C+c to stop the Java application.

While this application's functionality is trivial, this exercise demonstrates the value of remote debugging when developing exploits for web applications. This section served as an introduction to the remote debugging, and we will use this process extensively throughout the rest of the course.

#### Exercises

1. Repeat the steps outlined in this section and familiarize yourself with remote debugging in VS Code.
2. Start the lab debugger machine and run the NumberGame.jar from that machine. Remote debug the application from your local Kali machine. You'll find the IP address and machine credentials for the debugger in your control panel. Remember to enable remote connections for debugging when running the JAR.

1

(Oracle, 2021), [https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/conninv.html#Invocation](https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/conninv.html#Invocation) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/tools-and-methodologies-32491/wrapping-up-32511/wrapping-up-32573#fnref-local_id_149-1)

## 2.6. Wrapping Up

In this module we covered some of the fundamental tools and techniques used for whitebox web application assessments. We reviewed how to use Burp Suite to inspect and modify HTTP traffic. In addition, we set the groundwork for source code analysis by demonstrating how to recover Java and .NET source code and started creating our own methodology for analyzing that code for vulnerabilities. Now that we have demonstrated these basic techniques, we'll leverage them to examine a variety of vulnerable applications and explore the various vulnerabilities they contain.****