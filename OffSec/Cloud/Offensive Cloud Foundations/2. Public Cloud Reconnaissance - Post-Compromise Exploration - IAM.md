In this Module, we will cover the following Learning Units:

- Initial Reconnaissance
- IAM Resources Enumeration

_Reconnaissance_, also known as _information gathering_, is typically the first stage in a _penetration testing methodology_ or a [_cyber-attack kill chain_](https://en.wikipedia.org/wiki/Kill_chain). This crucial phase involves discovering as much information as possible about the target.

During the reconnaissance phase, _enumeration_ is the process of identifying, categorizing, and listing components and resources within the target.

This stage of discovery is recursive, meaning that once we obtain a new level of access in the environment we'll run the process of reconnaissance and enumeration again from that new perspective to collect more data, if needed, until we accomplish the final objective.

While not a standard feature, most major public Cloud Service Providers (CSPs) offer an API for customers to interact with their cloud services and resources. To use the API, users must create credentials, often referred to as "access keys". The user must manage and secure these credentials properly. If they fall into unauthorized hands, the environment could be compromised, providing an attacker _initial access_.

In this module, part of the _Public Cloud Reconnaissance_ series, we'll work under the premise that we've already compromised credentials on the target public cloud environment. This is a common scenario in pentesting assessments of public clouds, where obtaining credentials from an initial access compromise is beyond the scope.

From this perspective, we will focus on scoping the level of authorization we obtained from the compromised access and we'll gather more information about the identities of the account and what level of access they may have. In other words, we'll be enumerating _Identity and Access Management_ (IAM) data.

We won't delve into advanced attack techniques such as privilege escalation and lateral movement in the labs. However, we will explore a few examples of these when we encounter sensitive information or poor security practices.

We'll use _Amazon Web Services_ (AWS) for the lab exercises in this Module. It's worth noting that while AWS offers a vast array of services, we won't explore all of them. However, our enumeration approach will generally work against other service configurations and even other cloud providers.

If we're not experienced with AWS, it would be beneficial to review the _Introduction to AWS_ module to learn the basics of this public cloud service provider.

## 2.1. About the Public Cloud Labs

Before we jump in, let's run through a standard disclaimer.

This module uses OffSec's Public Cloud Labs for challenges and walkthroughs. **OffSec's Public Cloud Labs** are a type of lab environment that will complement the learning experience with hands-on practice. In contrast to our more common VM labs found elsewhere in OffSec Learning materials (in which learners will connect to the lab through a VPN), learners using the Public Cloud Labs will interact directly with the cloud environment through the Internet.

OffSec believes strongly in the advantages of learning and practicing in a hands-on environment, and we believe that the OffSec Public Cloud Labs represent an excellent opportunity for both new learners and practitioners who want to stay sharp.

Please note the following:

1. The lab environment should not be used for activities not described or requested in the learning materials you encounter. It is not designed to serve as a playground to test additional items that are out of the scope of the learning module.
    
2. The lab environment should not be used to take action against any asset external to the lab. This is specifically noteworthy because some modules may describe or even demonstrate attacks against vulnerable cloud deployments for the purpose of describing how those deployments can be secured.
    
3. Existing rules and requirements against sharing OffSec training materials still apply. Credentials and other details of the lab are not meant to be shared. OffSec monitors activity in the Public Cloud Labs (including resource usage) and monitors for abnormal events that are not related to activities described in the learning modules.
    

Activities that are flagged as suspicious will result in an investigation. If the investigation determines that a student acted outside of the guidelines described above, or otherwise intentionally abused the OffSec Public Cloud Labs, OffSec may choose to rescind that learner's access to the OffSec Public Cloud Labs and/or terminate the learner's account.

Progress between sessions is not saved. Note that a Public Cloud Lab that is restarted will return to its original state. After an hour has elapsed, the Public Cloud Lab will prompt to determine if the session is still active. If there is no response, the lab session will end. Learners can continue to manually extend a session for up to ten hours. The learning material is designed to accommodate the limitations of the environment. No learner is expected or required to complete all of the activities in a module within a single lab session. Even so, learners may choose to break up their learning into multiple sessions with the labs. We recommend making a note of the series of commands and actions that were completed previously to facilitate the restoration of the lab environment to the state it was in when the learner left. This is especially important when working through complex labs that require multiple actions.

## 2.2. Initial Reconnaissance

This Learning Unit covers the following Learning Objectives:

- Examining Compromised Credentials
- Scoping IAM permissions

After gaining an initial compromise, an attacker will often leverage _footprinting_ techniques within the compromised environment. They will identify which accounts or access keys have been affected, and attempt to determine their level of access within the compromised environment. This process will often highlight potential attack vectors that may lead to the fulfillment of the attack's ultimate objectives.

Public cloud platforms typically log events of user activity by default. However, the level of monitoring, detection, and alerting varies based on an organization's configuration. Access attempts to restricted resources or unauthorized actions are more likely to trigger alerts. Skilled attackers keep their activity within the range of the compromised credentials' authorized actions to lower the chances of detection in these early stages.

At this stage, we won't begin enumerating resources. Instead, we'll focus on gathering initial information from the compromised credentials, including understanding the scope of access within the AWS environment. We'll explore various techniques for this, some stealthy and others less so.

## 2.2.1. Accessing the Lab

For the hands-on experience in this module, we'll assume the role of an attacker that achieved an _initial compromise_ against the target, who gained access to credentials allowing them to run actions within the AWS cloud environment.

We'll interact with the AWS infrastructure with [_AWS CLI_](https://aws.amazon.com/cli/), a unified tool used to manage AWS services directly from the command line. Although AWS CLI can run on several operating systems, we'll run it on _Kali Linux_. Since AWS CLI is included in Kali's official repositories, we'll install it with the package manager by running **sudo apt install awscli**.

After deploying the lab we'll receive credentials to interact with AWS as three different users.

The _target user_ will simulate the compromised access to the cloud environment. This is the user we'll use most often while learning techniques to get information from this initial access.

The _challenge user_ is an auxiliary user with very limited access that we'll use to test concepts and execute additional tasks, validating our newly learned skills.

The _monitor user_ will simulate an operator with access to _Cloudtrail_, the AWS logging service.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/31a8022fa652b4f8fd3ac869dd847c3b_MD5.jpg]]

Figure 1: Obtaining Lab Information

For the moment let's start the lab deployment and take note of this information. We can organize the data as follows:

- Credentials access as the _target user_.
    - Target ACCESS KEY ID
    - Target SECRET ACCESS KEY
- Credentials access as the _challenge user_.
    - Challenge ACCESS KEY ID
    - Challenge SECRET ACCESS KEY
- Credentials to access as the _monitor user_.
    - Management Console login URL
    - Username
    - Password

We'll configure and use these credentials in the upcoming section.

## 2.2.2. Examining Compromised Credentials

We begin our scenario with the assumption that we have obtained compromised credentials to interact with the target's cloud environment.

First, let's run **aws configure** to configure AWS CLI with these compromised credentials. We'll also include **--profile target** to create a profile named _target_. While this step is optional, it will help us easily identify when we are executing commands as the target user. If we acquire new credentials, we can seamlessly switch between users by specifying the profile instead of reconfiguring AWS CLI each time.

We won't need the exact region in this initial stage so we'll simply choose **us-east-1** as the _default region_.

The default output format is **json**. We can specify it or leave it blank, either of which will work for our purposes.

```
kali@kali:~$ aws configure --profile target
AWS Access Key ID []: AKIAVXWRNA7HUYFERLHS...
AWS Secret Access Key []: u1CmqAO9QR...
Default region name []: us-east-1
Default output format []: json
```

> Listing 1 - Configuring AWS CLI with profiles

This configuration command won't return any output. Moving on, the next priority as an attacker would be to determine if the account is valid.

One way to do this is with the **aws sts get-caller-identity** command, which will provide us with two pieces of information about the IAM identity whose credentials are used to call the operation. These include the account ID, the identity type (IAM user or role) and the name of the identity.

Let's try running this command with our compromised credentials.

Unless otherwise specified, we'll use the target profile we configured in AWS CLI throughout this section. This means we need to include **--profile target** in every command we run.

```
kali@kali:~$ aws --profile target sts get-caller-identity
{
    "UserId": "AIDAQOMAIGYUYNMOIF46I",
    "Account": "123456789012",
    "Arn": "arn:aws:iam::123456789012:user/support/clouddesk-plove"
}
```

> Listing 2 - Getting details from the compromised credentials by running get-caller-identity.

This output reveals quite a bit of information about our current IAM user (or role). First, the UserID of the account we compromised is "AIDAQOMAIGYUYNMOIF46I". This is the unique identifier of this IAM user. We also learned the AWS account ID number of the account that controls this IAM User. We can use this Account ID to help identify our target or to confirm if the credentials correspond to the target we're focusing on. Finally, we determined the _Amazon Resource Name_ (ARN) associated with the calling entity. The ARN uniquely identifies AWS resources and in this case, the IAM user name is _clouddesk-plove_. It is associated with the [_path_](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) _/support/_.

Paths are optional identifiers used for grouping related identities to align with the company's organization structure.

The _get-caller-identity_ subcommand is a good way to identify the account and identity of the credentials, and this action will never return an _AccessDenied_ error. However, we should be aware that this action is logged in Cloudtrail's event history. As defenders, we should establish alerts for these types of calls as they are typically executed by attackers once they've compromised credentials.

No permissions are required to perform this operation. If an administrator attaches a policy to an identity that explicitly denies access to the _sts:GetCallerIdentity_ action, we can still perform this operation. Permissions are not required because the same information is returned when access is denied.

Alternatively, we could use the more-stealthy **aws iam get-access-key-info** command technique to gather this information. This will return the account identifier for the access key ID we specify with the **--access-key-id** flag. Executing this command from an external account ensures that the event logs within the attacker's account instead of the target's.

We'll run this command using the _challenge_ user to simulate an attack from an external account. We'll specify the _Access Key ID_ of the target's credentials. Be aware that this value will change every time we start the lab.

We'll configure AWS CLI to use the challenge user credentials by creating a profile and then include the **--profile challenge** to interact with AWS as the challenge user.

```
kali@kali:~$ kali@kali:~$ aws configure --profile challenge
AWS Access Key ID []: AKIAVXW...
AWS Secret Access Key []: KlnPvlFhvrrxg...
Default region name []: us-east-1
Default output format []: json

kali@kali:~$ aws --profile challenge sts get-access-key-info --access-key-id AKIAQOMAIGYUVEHJ7WXM
{
    "Account": "123456789012"
}
```

> Listing 3 - Getting the account ID from access keys with the get-access-key-info command.

Penetration testers can also use the _get-access-key-info_ subcommand to determine whether or not a compromised credential is inside the scope of the assessment.

Another stealthy approach is to abuse error messages that aren't logged by default in the Cloudtrail event history. For example, let's try invoking a nonexistent _Lambda_ function using the compromised credentials.

In general, we can execute a function with **aws lambda invoke --function-name <function_name_or_arn> <outfile>**, in which _--function-name_ specifies the name of the function and **outfile** is the name of the output file. Let's craft an ARN for a nonexistent lambda function.

```
kali@kali:~$ aws --profile target lambda invoke --function-name arn:aws:lambda:us-east-1:123456789012:function:nonexistent-function outfile

An error occurred (AccessDeniedException) when calling the Invoke operation: User: arn:aws:iam::123456789012:user/support/clouddesk-plove is not authorized to perform: lambda:InvokeFunction on resource: arn:aws:lambda:us-east-1:123456789012:function:nonexistent-function because no resource-based policy allows the lambda:InvokeFunction action
```

> Listing 4 - Getting information from error messages

We encountered an authentication error, which was anticipated since we are attempting to interact with a nonexistent resource. However, the error message offers us valuable information, including the account ID, the type of identity (IAM user or role), and the name of the identity executing this operation.

We obtained the same information from running **sts get-caller-identity**, and even though the command generated an error, it should not have generated a log event which could potentially alert an administrator.

There isn't a "list" of actions that aren't logged in the Cloudtrail event history. However, [_Cloudtrail's Documentation_](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/view-cloudtrail-events.html) states that _data events_ and _insights events_ are not displayed. Since invoking a _Lambda_ function is considered a _data event_, it is not displayed in the event history. It's important to note that while these events might not be logged by default in the event history, they can indeed be captured (if configured) using [_trails_](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/tutorial-trail.html).

One final consideration is that attackers may attempt to discern which AWS regions the account operates in and execute these commands in a different region. This increases the likelihood of evading detection.

AWS let us locate our resources in one or more [regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/) spread throughout the world. By default, many regions are enabled in the account even if we're only using one or two.

Let's take on the role of an administrator for a moment to validate that this technique works. We'll log in to the _Management Console_ using the _monitoring_ user credentials we received when we started the lab. Then we'll navigate to the _CloudTrail_ service page. We can find this page in the _Services Menu_ or through the _Search Box_.

When we first open the CloudTrail Service page, an _AccessDenied_ error will appear at the top of the page stating "The option to create an organization trail is not available for this AWS account". We can safely ignore this error as it doesn't affect what we'll do with this user.

On the Cloudtrail page, we'll click on the _Event History_ option from the menu located on the left side of the page. If the Cloudtrail menu doesn't appear, we can open it by clicking the hamburger icon located on the top left-hand side.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/09ae1e3fc9796edb1e561a3eac34bf8b_MD5.gif]]

Figure 2: Navigating to Cloudtrail Event History

Next, as the attacker, we'll use the compromised credentials to check if these events are recorded in the Cloudtrail page.

Let's execute **sts get-caller-identity** once more, but this time we'll specify a different region with **--region us-east-2**.

```
kali@kali:~$ aws --profile target sts get-caller-identity --region us-east-2
{
    "UserId": "AIDAQOMAIGYUYVDBXFNVF",
    "Account": "123456789012",
    "Arn": "arn:aws:iam::123456789012:user/support/clouddesk-plove"
}
```

> Listing 5 - Executing an API request to another region.

Within a few minutes, a log entry from the us-east-2 region appears in the Cloudtrail event history. However, there is no entry from us-east-1. We may need to adjust the filter parameters to query the logs for _Event Name_ and the _GetCallerIdentity_ value. We can also use the quick access links below which already contain the region and the filter we desire.

Quick access link to [_Cloudtrail Page in Region us-east-1 filtering by Event Name_](https://us-east-1.console.aws.amazon.com/cloudtrail/home?region=us-east-1#/events?EventName=GetCallerIdentity&CustomTime=1800000).

Quick access link to [_Cloudtrail Page in Region us-east-2 filtering by Event Name_](https://us-east-2.console.aws.amazon.com/cloudtrail/home?region=us-east-2#/events?EventName=GetCallerIdentity&CustomTime=1800000).

The following animated figure shows this process of comparing the logs in Cloudtrail swapping between two different regions. The log entry of the of the _GetCallerIdentity_ event is not visible in the default region _us-east-1_, but appears when we switch to the _us-east-2_ region.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/83fb726034d921874b4fcd926e82b720_MD5.gif]]

Figure 3: Comparing CloudTrail Events Between Regions in the AWS Management Console

One way to avoid this is to [specify which AWS regions your account can use](https://docs.aws.amazon.com/accounts/latest/reference/manage-acct-regions.html) and monitor all activity in these regions.

In this initial stage, regardless of the cloud service provider we are assessing, it's essential to identify and use services and actions that provide valuable information about the compromised user's cloud environment. If maintaining stealth is important, we should first focus on activities that aren't recorded by default to discreetly gather information about the compromised target.

#### Labs

1. In AWS CLI, what sts _subcommand_ returns details about the IAM user or role whose credentials are used to call the operation? (Write only the name of the subcommand)

Answer

2. In AWS CLI, what sts _subcommand_ returns the account identifier for the specified access key ID? (Write only the name of the subcommand)

Answer

3. In AWS CLI, what is the _name_ of the option flag that specifies the region to use overlapping the default region? (Write your answer in this format: --name)

Answer

## 2.2.3. Scoping IAM permissions

All cloud providers implement some kind of authentication and authorization mechanisms to ensure that users can only interact with the provider's API within their designated permissions and cannot act on behalf of other users or accounts. All these mechanisms are commonly grouped under the umbrella term _Identity and Access Management_ (IAM).

The _Principle of Least Privilege_ (PoLP) is generally followed as a best practice for any cloud deployment. This principle suggests granting users only the permissions they need to perform their tasks, and nothing more. This will reduce actions that can be performed and limit potential attack vectors that an attacker can exploit from a compromised account. However, overly-permissive identities are still a common finding and the major cause of breaches in cloud environments.

Continuing in the lab, we'll again take on the role of an attacker to determine the extent of permissions associated with the compromised credentials in the target environment.

We've already uncovered some valuable information from the previous _get-caller-identity_ subcommand which revealed that the compromised identity is an _IAM User_ with a username of _clouddesk-plove_. We also identified the _support_ path:

```
kali@kali:~$ aws --profile target sts get-caller-identity
{
    "UserId": "AIDAQOMAIGYUYNMOIF46I",
    "Account": "123456789012",
    "Arn": "arn:aws:iam::123456789012:user/support/clouddesk-plove"
}
```

> Listing 6 - Running the get-caller-identity command

This suggests the purpose of the user and what permissions they likely have. For example, "clouddesk" and "support" may tell us that the user has some IAM-related privileges to grant access or reset credentials. This type of hypothesis is helpful as it's extra information we've gained while maintaining a low profile.

We could also take a more direct approach. Let's try to list the policies associated with the compromised identity by interacting directly with the provider API. An identity is an IAM resource that can be authorized to perform actions and access resources. Identities include users, groups, and roles. Within AWS IAM, there are two primary ways policies can be associated to an _Identity_. **Inline Policies** are directly linked to a single identity and exist only in that identity space. **Managed Policies** stand as distinct, reusable policies that can be associated with multiple identities.

An identity can also inherit policies from other identities. For example, an IAM user that is a member of a User Group will inherit that group's policies.

We can list inline policies and managed policies associated with the user by running **list-user-policies** and **list-attached-user-policies** respectively. Both commands will require the **--user-name** flag to specify the target user.

```
kali@kali:~$ aws --profile target iam list-user-policies --user-name clouddesk-plove

{
    "PolicyNames": []
}

kali@kali:~$ aws --profile target iam list-attached-user-policies --user-name clouddesk-plove
{
    {
    "AttachedPolicies": [
        {
            "PolicyName": "deny_challenges_access",
            "PolicyArn": "arn:aws:iam::123456789012:policy/deny_challenges_access"
        }
    ]
}
}
```

> Listing 7 - Listing inline and managed policies associated with an IAM user

Since we did not receive an error message, we know that the IAM user has permission to run the _iam:ListAttachedUserPolicies_ action. However, we still have not discovered any useful policies associated with the IAM user. The _deny_challenges_access_ policy is related to a later challenge. We'll ignore it for now.

Let's try to run more IAM commands and prioritize retrieving the policy for this user.

First, we'll try to determine if the IAM user inherits any policies from assigned groups. To do this, we'll need to determine if the user is a member of any groups with the **list-groups-for-user** subcommand specifying the name of the user with **--user-name clouddesk-plove**.

```
kali@kali:~$ aws --profile target iam list-groups-for-user --user-name clouddesk-plove

{
    "Groups": [
        {
            "Path": "/support/",
            "GroupName": "support",
            "GroupId": "AGPAQOMAIGYUSHSVDSYIP",
            "Arn": "arn:aws:iam::123456789012:group/support/support",
        }
    ]
}
```

> Listing 8 - Listing the groups to which the user belongs.

We discovered that the IAM user belongs to only one group, named _support_.

Next, we'll check for policies associated with the _support_ group. We'll search for inline and managed policies in a search similar to one we ran previously. Let's use **list-group-policies** to list inline policies linked to the group and **list-attached-group-policies** to list managed policies attached to the group. We'll specify the group name for both commands with **--group-name**.

```
kali@kali:~$ aws --profile target iam list-group-policies --group-name support

{
    "PolicyNames": []
}

kali@kali:~$ aws --profile target iam list-attached-group-policies --group-name support
{
    "AttachedPolicies": [
        {
            "PolicyName": "SupportUser",
            "PolicyArn": "arn:aws:iam::aws:policy/job-function/SupportUser"
        }
    ]
}
```

> Listing 9 - Listing inline and managed policies associated with an IAM group

From the output, we learn that the group doesn't have any inline policy, but it does have an attached managed policy. This particular policy is classified as an [_AWS Managed Policy_](https://docs.aws.amazon.com/aws-managed-policy/latest/reference/about-managed-policy-reference.html), a special set of policies provided by AWS with pre-defined permissions to quickly attach to IAM Identities. However, a word of caution: these policies often grant broader permissions than might be desired. Ideally, they should be paired with other more-restrictive policies to ensure fine-grained permission control.

While _AWS Managed Policies_ offer flexibility for IAM management, they tend to be overly-permissive and there is an inherent security risk when they are used alone.

We discovered this user possesses [_SupportUser_](https://docs.aws.amazon.com/aws-managed-policy/latest/reference/SupportUser.html), which is a special type of _AWS managed policy_ that is based on [_Job Functions_](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_job-functions.html). We can identify this from the keyword _job-function_ in the policy's ARN highlighted in the Listing above.

We'll note the ARN string, as we'll need it in a moment.

The documentation suggests that the _SupportUser_ policy permits many read-only actions for several AWS services. Let's validate this in the lab.

First, we'll need to determine the current version of the policy since policies support versioning. We'll use **aws iam list-policy-versions** for this and specify the policy by its ARN with **--policy-arn**.

```
kali@kali:~$ aws --profile target iam list-policy-versions --policy-arn "arn:aws:iam::aws:policy/job-function/SupportUser"

{
    "Versions": [
        {
            "VersionId": "v8",
            "IsDefaultVersion": true
        },
        {
            "VersionId": "v7",
            "IsDefaultVersion": false,
        },
...
```

> Listing 10 - Listing a policy version

We'll take note of the most recent version ID, _v8_.

We can now retrieve the policy document with **aws iam get-policy-version**. Again, we'll specify the ARN of the policy and we'll also specify the version Id (_v8_) with **--version-id**.

```
kali@kali:~$ aws --profile target iam get-policy-version --policy-arn arn:aws:iam::aws:policy/job-function/SupportUser --version-id v8

{
    "PolicyVersion": {
        "Document": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": [
                        "support:*",
                        "acm:DescribeCertificate",
                        "acm:GetCertificate",
                        "acm:List*",
                        "acm-pca:DescribeCertificateAuthority",
                        "autoscaling:Describe*",
...
                        "workdocs:Describe*",
                        "workmail:Describe*",
                        "workmail:Get*",
                        "workspaces:Describe*"
                    ],
                    "Effect": "Allow",
                    "Resource": "*"
                }
            ]
        },
        "VersionId": "v8",
        "IsDefaultVersion": true,
...
    }
}
```

> Listing 11 - Listing a policy definition by its version

In summary, the policy defines a list of _Actions_ for many AWS services. Some of these elements define a specific action. For example, _acm:DescribeCertificate_ defines the _DescribeCertificate_ action for the AWS Certificate Manager service. Other elements use the _"*"_ wildcard to describe any action that starts with read-only keywords such as _Get_, _Describe_ and, _List_. These actions are allowed to run against any resource of the given services as stated in the _"Resource": "*"_ line.

At this point, we do not have the ability to create or modify new cloud resources, we do have permission to read information about several resources.

Finally, let's suppose that our compromised credentials don't have the privileges to query for IAM-related information. In this case, we need to adopt a _brute-force_ approach, meaning we'll run several actions on services in hopes of finding one that doesn't produce an authorization error.

We can build a script to automate this brute-force approach or leverage popular AWS tools such as _pacu_ (Module: _iam__bruteforce_permissions_), _awsenum_ or _enumerate-iam_. We can use any of these approaches to discover permissions in compromised credentials.

Just like many brute-force attacks, these tools will generate a lot of _ActionDenied_ account events that could trigger alarms within the target. This may not be a problem in some pentesting assessments which do not require stealth. In red-teaming assessments which prioritize stealth, we could adopt a manual approach, which will generate fewer errors and sound less alarms. We should always leverage information from our reconnaissance to help with this. For example, if we determined a list of services the account is using, we can target those services first, reducing the amount of noise we generate.

In this stage, we used the CSP APIs to attempt to scope the level of access that we obtained from the compromised credentials. With access to IAM-related actions, we learned that we can query directly for this information. Otherwise, depending on the assessment, we can try to enumerate the privileges by running an automated or manual approach to scope the level of access.

#### Labs

1. Use the _challenge_ Profile in AWS CLI to scope the level of actions allowed to run in the EC2 service. Run the permitted actions to list or describe Resources. You will find a Tag Key named **proof** in one of the resources you can list. Enter the value of the Tag Key.

Answer

## 2.3. IAM Resources Enumeration

At the start of this module, we set the stage of this scenario from the perspective of an attacker that compromised a target and obtained credentials to interact with the provider's API. We then conducted footprinting of the compromised environment, tried to identify which accounts or access keys we had access to, and determined our level of access within the compromised environment. By combining our findings with information gathered from external probing, we established a foundational understanding of some services that the account had access to.

Next, we'll gather more data from the target. There's no one-size-fits-all approach to this task. The data we're hoping to obtain will vary based on many factors and the techniques we'll use depend on the target's cloud environment and providers.

In the following sections, we will enumerate more IAM resources within an AWS environment but many of the tactics and procedures apply to other cloud service providers as well.

This Learning Unit covers the following Learning Objectives:

- Choosing Between a Manual or Automated Enumeration Approach
- Enumerating IAM Resources
- Processing API Response data with JMESPath
- Running Automated Enumeration with Pacu
- Extracting Insights from Enumeration Data

## 2.3.1. Choosing Between a Manual or Automated Enumeration Approach

Several commercial and open-source tools have been developed to perform information gathering against cloud-based infrastructures. Some of these tools are tailored specifically towards specific cloud providers, while others support multiple providers. Some are GUI-based and some run from the command line. Some are automated and some require manual intervention.

Most tools generate significant log events and may trigger monitoring systems. This may not be a significant consideration when performing a red team assessment or a penetration test in which stealth is not a requirement, but when stealth is a factor, we must test our tools to determine the potential impact prior to an engagement.

Given the variety of available tools, varied assessment goals, user preference, budget requirements and other factors, there is rarely ever a "best tool" for the job. Generally speaking, we should train with multiple tools so that we understand their capabilities and limitations and can rely on them in any given situation, in the best possible combination as needed. It is important, however, that we always understand the technologies in use with any tool we rely on so that we don't develop a bad habit of simply running multiple tools for any given situation which can be dangerous and inefficient.

## 2.3.2. Enumerating IAM Resources

As we begin to enumerate IAM resources, we'll start our scenario in possession of an already-compromised account. Let's summarize what we have already learned from the compromised credentials.

|Resource Type|Name|ARN|
|---|---|---|
|IAM::User|clouddesk-plove|arn:aws:iam::123456789012:user/support/clouddesk-plove|
|IAM:Group|support|arn:aws:iam::123456789012:group/support/support|
|IAM::Policy|SupportUser|arn:aws:iam::aws:policy/job-function/SupportUser|

The compromised credentials we possess belong to the _clouddesk-plove_ IAM user, which is a member of the _support_ group and inherits the policy attached to the group. The policy is an AWS custom-managed policy based on the _Support Users_ job function.

AWS custom-managed policies allow users to define a set of permissions that can be reused and associated with multiple IAM users, groups, or roles. While these policies offer flexibility for IAM management, there is an inherent security risk if they are crafted to be overly permissive.

_SupportUser_ is an AWS custom-managed policy that grants permissions to troubleshoot and resolve issues in an AWS account. This policy grants read-only access to explore several services.

Let's check what actions this policy grants to enumerate IAM resources. To do this we'll run **iam get-policy-version** to show the policy definition. We'll pipe the output to **grep** to filter and display only the lines that contain the string **iam**.

```
kali@kali:~$ aws --profile target iam get-policy-version --policy-arn arn:aws:iam::aws:policy/job-function/SupportUser --version-id v8 | grep "iam"

                        "iam:GenerateCredentialReport",
                        "iam:GenerateServiceLastAccessedDetails",
                        "iam:Get*",
                        "iam:List*",
```

> Listing 12 - Getting the permissions related to IAM service of the SupportUser policy

With this policy, we can run any _iam_ subcommand that starts with _get_ and _list_ and two other specific actions. To list the available subcommands in AWS CLI we can use the _help_ option.

Let's run **aws iam help** to display a description of the command usage including a list of all available subcommands. We'll also add **| grep -E "list-|get-|generate-"** to filter all the lines that include the words "list-", "get-" and "generate-".

```
kali@kali:~$ aws --profile target iam help | grep -E "list-|get-|generate-"

       o generate-credential-report
       o generate-organizations-access-report
       o generate-service-last-accessed-details
       o get-access-key-last-used
       o get-account-authorization-details
       o get-account-password-policy
       o get-account-summary
       o get-context-keys-for-custom-policy
       o get-context-keys-for-principal-policy
       o get-credential-report
       o get-group
       o get-group-policy
       o get-instance-profile
       o get-login-profile
       o get-open-id-connect-provider
       o get-organizations-access-report
       o get-policy
       o get-policy-version
       o get-role
       o get-role-policy
       o get-saml-provider
       o get-server-certificate
       o get-service-last-accessed-details
       o get-service-last-accessed-details-with-entities
       o get-service-linked-role-deletion-status
       o get-ssh-public-key
       o get-user
       o get-user-policy
       o list-access-keys
       o list-account-aliases
       o list-attached-group-policies
       o list-attached-role-policies
       o list-attached-user-policies
       o list-entities-for-policy
       o list-group-policies
       o list-groups
       o list-groups-for-user
       o list-instance-profile-tags
       o list-instance-profiles
       o list-instance-profiles-for-role
       o list-mfa-device-tags
       o list-mfa-devices
       o list-open-id-connect-provider-tags
       o list-open-id-connect-providers
       o list-policies
       o list-policies-granting-service-access
       o list-policy-tags
       o list-policy-versions
       o list-role-policies
       o list-role-tags
       o list-roles
       o list-saml-provider-tags
       o list-saml-providers
       o list-server-certificate-tags
       o list-server-certificates
       o list-service-specific-credentials
       o list-signing-certificates
       o list-ssh-public-keys
       o list-user-policies
       o list-user-tags
       o list-users
       o list-virtual-mfa-devices
```

> Listing 13 - Getting available IAM subcommands

IAM is a critical component of AWS that manages all actions related to the authentication and authorization of identities. Having this level of access, even though it's read-only access, is a big deal.

We won't cover the entire list of subcommands in this lab. We could, however, learn about any of them by running **aws iam _command_ help**. This will show details about the subcommand and its basic usage including the required and optional parameters.

Let's start by getting a summary of the IAM-related information in the account. We'll run **aws iam get-account-summary** with no additional arguments.

To limit our noise level, we'll redirect the output to a standard file. This way, we can review the output later without interacting with the AWS API again. We'll use **tee** to display the output to the console while also redirecting the content to a file.

```
kali@kali:~$ aws --profile target iam get-account-summary | tee account-summary.json

aws --profile target iam get-account-summary
{
    "SummaryMap": {
        "GroupPolicySizeQuota": 5120,
        "InstanceProfilesQuota": 1000,
        "Policies": 8,
        "GroupsPerUserQuota": 10,
        "InstanceProfiles": 0,
        "AttachedPoliciesPerUserQuota": 10,
        "Users": 18,
        "PoliciesQuota": 1500,
        "Providers": 1,
        "AccountMFAEnabled": 0,
        "AccessKeysPerUserQuota": 2,
        "AssumeRolePolicySizeQuota": 2048,
        "PolicyVersionsInUseQuota": 10000,
        "GlobalEndpointTokenVersion": 1,
        "VersionsPerPolicyQuota": 5,
        "AttachedPoliciesPerGroupQuota": 10,
        "PolicySizeQuota": 6144,
        "Groups": 8,
        "AccountSigningCertificatesPresent": 0,
        "UsersQuota": 5000,
        "ServerCertificatesQuota": 20,
        "MFADevices": 0,
        "UserPolicySizeQuota": 2048,
        "PolicyVersionsInUse": 27,
        "ServerCertificates": 0,
        "Roles": 20,
        "RolesQuota": 1000,
        "SigningCertificatesPerUserQuota": 2,
        "MFADevicesInUse": 0,
        "RolePolicySizeQuota": 10240,
        "AttachedPoliciesPerRoleQuota": 10,
        "AccountAccessKeysPresent": 0,
        "GroupsQuota": 300
    }
}
```

> Listing 14 - Getting the IAM Account Summary

The output shows some information that is more relevant for administrators such as resource quotas, but it also shows some insights about the number of IAM resources created in the account such as _Users_, _Roles_, _Groups_, and _Policies_.

This data also highlights some poor practices in the configuration that could lead to further exploitation. Notably, **"MFADevices": 0** and **"MFADevicesInUse": 0,** indicate that none of the eighteen IAM users use Multi-Factor Authentication (MFA). This lack of a secondary authentication layer makes the account more vulnerable if its credentials are compromised. In addition, **"AccountMFAEnabled": 0** reveals that MFA is not enabled for the account's most critical user: root.

It is important to mention additional elements, although they fall outside the scope of this module. [_InstanceProfiles_](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#ec2-instance-profile) are essential for authorizing EC2 instances. They manage permissions and roles for instances in a secure manner. _Providers_ refers to [_Identity Providers_](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers.html) which are crucial for managing identities outside of AWS. They enable external identities to access AWS resources in the account. Lastly, _ServerCertificates_ are necessary for services that require SSL/TLS encryption.

Let's continue enumerating all the IAM identities (users, user groups, and roles) in the account. We'll use the **list-users**, **list-groups**, and **list-roles** subcommands respectively.

```
kali@kali:~$ aws --profile target iam list-users | tee  users.json

{
    "Users": [
        {
            "Path": "/admin/",
            "UserName": "admin-alice",
            "UserId": "AIDAQOMAIGYU3FWX3JOFP",
            "Arn": "arn:aws:iam::123456789012:user/admin/admin-alice",
        },
...


kali@kali:~$ aws --profile target iam list-groups | tee groups.json

{
    "Groups": [
        {
            "Path": "/admin/",
            "GroupName": "admin",
            "GroupId": "AGPAQOMAIGYUXBR7QGLLN",
            "Arn": "arn:aws:iam::123456789012:group/admin/admin",
        },
...


kali@kali:~$ aws --profile target iam list-roles | tee roles.json

{
    "Roles": [
        {
            "Path": "/",
            "RoleName": "aws-controltower-AdministratorExecutionRole",
            "RoleId": "AROAQOMAIGYU6PUFJYD7W",
            "Arn": "arn:aws:iam::123456789012:role/aws-controltower-AdministratorExecutionRole",
...
```

> Listing 15 - Listing IAM identities

The three commands will output an array of all the users, groups, and roles in the account, providing detailed information about each identity, including its name, ARN, and path. These attributes can help us identify valuable identities for further analysis. For instance, we may find some identities with the "admin" keyword in both their names and paths. While these require further verification, they could be particularly significant for exploitation.

Up to this point, we have saved the data into their respective files so we can later parse these files to extract valuable insights from the account. Before we dig through this data, let's continue to gather more information.

We can list all managed policies with **list-policies**. We'll use **--scope Local** to display only the _Customer Managed Policies_ and omit the _AWS Managed Policies_, and we'll use **--only-attached** to list only the policies that are attached to an IAM identity.

```
kali@kali:~$ aws --profile target iam list-policies --scope Local --only-attached | tee policies.json

{
    "Policies": [
        {
            "PolicyName": "manage-credentials",
            "PolicyId": "ANPAQOMAIGYU3LK3BHLGL",
            "Arn": "arn:aws:iam::123456789012:policy/manage-credentials",
            "Path": "/",
            "DefaultVersionId": "v1",
            "AttachmentCount": 1,
            "PermissionsBoundaryUsageCount": 0,
            "IsAttachable": true,
            "UpdateDate": "2023-10-19T15:45:59+00:00"
        },
...
```

> Listing 16 - Listing policies.

Next, to get the inline policies for every identity associated with the compromised credentials, we could run the following subcommands:

- **list-user-policies**
- **get-user-policy**
- **list-group-policies**
- **get-group-policy**
- **list-role-policies**
- **get-role-policy**

Similarly, we can check for all managed policies with the following subcommands:

- **list-attached-user-policies**
- **list-attached-group-policies**
- **list-attached-role-policies**

After that, we'll need to run the **get-policy-version** subcommand to read the policy document for each of the managed policies we found.

Notice that this manual information gathering approach can be quite tedious. Automated tools would excel at processing all of this information and presenting it in a summarized format.

We could also adopt a simpler approach by running the **iam get-account-authorization-details** subcommand. This retrieves information about all IAM users, groups, roles, and policies in an AWS account, including their relationships with one another.

In order to execute _get-account-authorization-details_, the account running the command must have the _GetAccountAuthorizationDetails_ permission attached to its policy. While it's not common to find this permission exclusively on a policy, it is included when a wildcard is used for all get permissions (_iam:Get*_) which is common.

We can filter the results using the **--filter** and a list of space-separated elements which may include **User**, **Role**, **Group**, **LocalManagedPolicy**, and **AWSManagedPolicy**. We are not interested in AWS custom-managed policies so we'll omit this value.

```
kali@kali:~$ aws --profile target iam get-account-authorization-details --filter User Group LocalManagedPolicy Role | tee account-authorization-details.json

{
    "UserDetailList": [
        {
            "Path": "/admin/",
            "UserName": "admin-alice",
            "UserId": "AIDAQOMAIGYU3FWX3JOFP",
            "Arn": "arn:aws:iam::123456789012:user/admin/admin-alice",
            "GroupList": [
                "amethyst_admin",
                "admin"
            ],
    ...
    "GroupDetailList": [
        {
            "Path": "/admin/",
            "GroupName": "admin",
            "GroupId": "AGPAQOMAIGYUXBR7QGLLN",
            "Arn": "arn:aws:iam::123456789012:group/admin/admin",
            "GroupPolicyList": [],
    ...
    "RoleDetailList": [
        {
            "Path": "/",
            "RoleName": "aws-controltower-AdministratorExecutionRole",
            "RoleId": "AROAQOMAIGYU6PUFJYD7W",
            "Arn": "arn:aws:iam::123456789012:role/aws-controltower-AdministratorExecutionRole",
    ...
    "Policies": [
        {
            "PolicyName": "ruby_admin",
            "PolicyId": "ANPAQOMAIGYU3I3WDCID3",
            "Arn": "arn:aws:iam::123456789012:policy/ruby/ruby_admin",
            "Path": "/ruby/",
...
```

> Listing 17 - Retrieving a snapshot of the IAM configuration with the get-account-authorization-details subcommand

This command returned a great deal of information about the identities and policies in the account. Notably, it's the same information previously gathered, but obtained through a single request, meaning we have generated fewer events in the events history logs. When we build our own tools to query this information, we should start with this command, given its lower profile.

Next, let's check something curious about the the authorization details we discovered.

The _clouddesk-plove_ IAM user is associated with a policy that denies access to certain resources. We observed this while scoping the IAM permissions of the compromised user, but we disregarded it at that time. Let's rerun that command and review the list of managed policies associated with this user.

```
kali@kali:~$ aws --profile target iam list-attached-user-policies --user-name clouddesk-plove
{
    "AttachedPolicies": [
        {
            "PolicyName": "deny_challenges_access",
            "PolicyArn": "arn:aws:iam::12345678912:policy/deny_challenges_access"
        }
    ]
}
```

> Listing 18 - Listing the managed policies of the clouddesk-plove IAM user

We identified one managed policy (named _deny_challenges_access_) associated with the user. To understand the policy's function, we need to read its policy document. Let's take the ARN of this policy and attempt to list its policy versions to gain further insights.

```
kali@kali:~$ aws --profile target iam list-policy-versions --policy-arn arn:aws:iam::12345678912:policy/deny_challenges_access

An error occurred (AccessDenied) when calling the ListPolicyVersions operation: User: arn:aws:iam::12345678912:user/support/clouddesk-plove is not authorized to perform: iam:ListPolicyVersions on resource: policy arn:aws:iam::12345678912:policy/deny_challenges_access with an explicit deny in an identity-based policy
```

> Listing 19 - Getting an AccessDenied error when trying to list the policy versions of the deny_challenges_access policy

The error message, indicating that the operation is "explicitly denied" suggests that the administrator restricted this user's access to certain resources.

This is about to get very interesting. Let's run **get-account-authorization-details --filter LocalManagedPolicy** to retrieve all the custom managed policies of the account and browse the list until we find the details of the deny_challenges_access policy.

```
kali@kali:~$ aws --profile target iam get-account-authorization-details --filter LocalManagedPolicy
...
        {
            "PolicyName": "deny_challenges_access",
            "PolicyId": "ANPATV2ULYL4RBGWQT5SE",
            "Arn": "arn:aws:iam::253043131129:policy/deny_challenges_access",
            "Path": "/",
            "DefaultVersionId": "v1",
            "AttachmentCount": 1,
            "PermissionsBoundaryUsageCount": 0,
            "IsAttachable": true,
            "CreateDate": "2023-12-11T23:25:03+00:00",
            "UpdateDate": "2023-12-11T23:25:03+00:00",
            "PolicyVersionList": [
                {
                    "Document": {
                        "Statement": [
                            {
                                "Action": "*",
                                "Condition": {
                                    "StringEquals": {
                                        "aws:ResourceTag/challenge": "true"
                                    }
                                },
                                "Effect": "Deny",
                                "Resource": "*",
                                "Sid": "DenyAllIAMActionsOnChallengedResources"
                            }
                        ],
                        "Version": "2012-10-17"
                    },
                    "VersionId": "v1",
                    "IsDefaultVersion": true,
                    "CreateDate": "2023-12-11T23:25:03+00:00"
                }
            ]
        }
    ]
}
```

> Listing 20 - Getting the list of policy versions from the output of the get-account-authorization-details command

After checking the details and the **PolicyVersionList** attribute we realize that we obtained the previously-denied policy document of the _deny_challenges_access_ policy. This policy denies all actions on all resources tagged with "challenge: true". This policy prevented this user from reading the content of that policy directly. However, we managed to view it through the output of another permitted action, effectively circumventing the intended protection.

Understanding IAM policies is beyond the scope of this module, so it's okay if this statement is not fully clear at the moment. We will delve deeper into authorization and policies in a different module.

This was an example of abusing permitted actions to obtain information that is supposed to be denied in the IAM policies. In this case, we bypassed the protection using an action from the same IAM service but the same can happen using actions from other services, for example, listing resources by reading logs in Cloudtrail. As defenders, it's important to understand all the actions authorized to the identities and the scope of resources they can access.

#### Labs

1. Which IAM subcommand retrieves information about _IAM entity usage_ and _IAM quotas_ in the Amazon Web Services account? (Write only the subcommand)

Answer

2. Which one of the following is not a valid value for the --filter flag of the IAM **get-account-authorization-detail** subcommand? User, Group, Credential, Role, AWSManagedPolicy, LocalManagedPolicy?

Answer

3. What is the _path_ and _name_ of the group that the IAM user _dev-ballen_ belongs to? (Format: /path/group_name. Example: /amethyst/admin_group)

Answer

## 2.3.3. Processing API Response data with JMESPath

As previously mentioned, we have been using the aws client which produces JSON output by default. In this section, we will process the JSON output with JMESPath to filter our results.

[_JMESPath_](https://jmespath.org/) is a query language for JSON. It is used to extract and transform elements from a JSON document. There's no need to learn all the language at once. We just need to know that we can use it to create more advanced queries to process the information we gather during the enumeration phase.

In this section, we'll learn some basic querying using JMESPath by running some examples against the output of the **iam get-account-authorization-details** subcommand.

First, let's use **--filter User** to show user-related data.

```
kali@kali:~$ aws --profile target iam get-account-authorization-details --filter User

{
    "UserDetailList": [
        {
            "Path": "/admin/",
            "UserName": "admin-alice",
            "UserId": "AIDAQOMAIGYUSSOCFCREC",
            "Arn": "arn:aws:iam::123456789012:user/admin/admin-alice",
            "GroupList": [
                "admin"
            ],
            "AttachedManagedPolicies": [],
            "Tags": []
        },
        {
            "Path": "/amethyst/",
            "UserName": "admin-cbarton",
            "UserId": "AIDAQOMAIGYUTHT4D5YLG",
            "Arn": "arn:aws:iam::123456789012:user/amethyst/admin-cbarton",
            "GroupList": [
                "amethyst_admin"
            ],
            "AttachedManagedPolicies": [],
            "Tags": []
        },
...
```

> Listing 21 - Running get-account-authorization-details subcommand to get all IAM users information

The output shows a JSON document with the _UserDetailList_ element. This is an [array](https://www.w3schools.com/js/js_json_arrays.asp) of _Users objects_ with some key-value pairs representing properties of the object. For example, the listing above shows the **UserName** key with its corresponding **admin-alice** value (both highlighted).

Now, let's query only for the _UserName_ keys for all the objects. This is a perfect opportunity to use a **"UserDetailList[].UserName"** JMESPath expression. This will retrieve all the objects of the _UserDetailList_ array and output the value of the _UserName_ key. We'll use the **--query** argument to specify the JMESPath expression.

The AWS CLI tool allows us to **--filter** the displayed output. One key difference is that the **--filter** argument runs on the server side while the **--query** filtering runs on the client side using JMESPath expressions.

```
kali@kali:~$ aws --profile target iam get-account-authorization-details --filter User --query "UserDetailList[].UserName"

[
    "admin-alice",
    "admin-cbarton",
    "admin-srogers",
    "admin-tstark",
    "clouddesk-bob",
...
```

> Listing 22 - Querying the UserName key from the JSON document.

We obtained all the objects but filtered them to display only the value of the _UserName_ key. However, we can select more than one key. Let's query for the _UserName_, _Path_, and _GroupList_ keys.

There are two ways to accomplish this. We could use an array like _[key1, key2, key3]_ or an object like _{Identifier1: key1, Identifier2: key2, IdentifierN: keyN}_ where "Identifier" is just a name we choose to name the key. The Listing below shows both outputs.

We'll use the **"UserDetailList[0]"** expression to choose only the first object of the array.

```
kali@kali:~$ aws --profile target iam get-account-authorization-details --filter User --query "UserDetailList[0].[UserName,Path,GroupList]"

[
    "admin-alice",
    "/admin/",
    [
        "admin"
    ]
]


kali@kali:~$ aws --profile target iam get-account-authorization-details --filter User --query "UserDetailList[0].{Name: UserName,Path: Path,Groups: GroupList}"

{
    "Name": "admin-alice",
    "Path": "/admin/",
    "Groups": [
        "admin"
    ]
}
```

> Listing 23 - Quering for more than one key values

Both expressions accomplish the same result, so choosing an approach is just a matter of preference.

In the previous example, we used the expression _"UserDetailList[0]"_ to select only the first object of the array. We can correctly infer that _[1]_ will select the second object and so on. However, we can use the powerful _Filter Projections_ feature that allows us to build more-advanced queries.

For example, let's list all the _IAM Users_ whose usernames contain the word admin. We would use the **UserDetailList[?contains(UserName, 'admin')]** expression. Let's run that now.

```
kali@kali:~$ aws --profile target iam get-account-authorization-details --filter User --query "UserDetailList[?contains(UserName, 'admin')].{Name: UserName}"

[
    {
        "Name": "admin-alice"
    },
    {
        "Name": "admin-cbarton"
    },
    {
        "Name": "admin-srogers"
    },

...
```

> Listing 24 - Filtering all IAM Users whose names contain admin

We received a filtered response with the name of several potentially high-privileged users.

As a final example, we'll build an expression that selects elements from different objects. In this case, let's gather all the names of the IAM _Users_ and _Groups_ which contain "/admin/" in their _Path_ key.

If the two expressions are written separately the expressions would be **UserDetailList[?Path=='/admin/'].UserName** and **GroupDetailList[?Path=='/admin/'].GroupName**. Let's build a JSON object with the desired elements. The Listing below shows the JSON object. Notice that we must use the **--filter User Group** argument to also obtain the Group objects.

```
kali@kali:~$ aws --profile target iam get-account-authorization-details --filter User Group --query "{Users: UserDetailList[?Path=='/admin/'].UserName, Groups: GroupDetailList[?Path=='/admin/'].{Name: GroupName}}"

{
   "Users": [
       "admin-alice"
   ],
   "Groups": [
       {
           "Name": "admin"
       }
   ]
}
```

> Listing 25 - Constructing more advanced queries.

This shows that we can build custom JSON objects by filtering any information we want from the original JSON response.

We can find more examples on this topic on the [_JMESPath Examples_](https://jmespath.org/examples.html) page and in the [_AWS CLI Filter Output_](https://docs.aws.amazon.com/cli/v1/userguide/cli-usage-filter.html) documentation.

In a subsequent section, we'll extract some valuable insights from this environment.

As a final recommendation, we should always try to reduce the number of requests we send by saving all output to a local file and then using an external tool like [_jp_](https://github.com/jmespath/jp) to filter that output with JMESPath expressions.

In summary, the _--query_ parameter is a great AWS CLI feature that leverages JMESPath expressions. Azure CLI also implements a similar feature with JMESPath expressions. Other CSPs like Google Cloud don't implement this directly but they support displaying output in JSON so we can use external tools to process the data.

#### Labs

1. What JMESPath expression will filter and display all users that contain the word "admin" in the Username and the Path fields? (Write only the JMESPath expression starting with "?". Use the _contains_ function for both conditions. Example: ?contains(Path,'admin') ... )

Answer

## 2.3.4. Running Automated Enumeration with Pacu

_Pacu_ is an open-source AWS exploitation framework, specifically designed for penetration testers and security researchers. It streamlines AWS security assessments and is modular in design, allowing developers to enhance the tool's capabilities by writing and integrating their own modules.

In this section, we'll explore some of _Pacu's_ enumeration modules as a case study for automated AWS enumeration. The goal of automation is to not only streamline our work, but more importantly to help us better understand the process and even build our own tools and workflows.

Let's start by installing pacu (if it's not already installed). The package is in the Kali repositories so we can install it by running **sudo apt install pacu** in the terminal.

```
kali@kali:~$ sudo apt update

kali@kali:~$ sudo apt install pacu
```

> Listing 26 - Installing pacu on Kali Linux using the package manager

Next, we'll run **pacu** without any arguments to start Pacu in interactive mode. Pacu organizes assessments into _sessions_. The first time we run pacu it will prompt for a session name and create a session.

Let's create a session and name it _enumlab_.

```
kali@kali:~$ pacu

....
Database created at /root/.local/share/pacu/sqlite.db

What would you like to name this new session? enumlab
Session enumlab created.

...

Pacu (enumlab:No Keys Set) >
```

> Listing 27 - Starting pacu in interactive mode

Once the session is created, pacu displays a list of available commands and produces a new command prompt showing that we are in interactive mode inside the _enumlab_ section.

Notice the _No Keys Set_ message shown in the prompt. We can quickly set keys from the AWS CLI credentials file with the **import-keys** command followed by a profile name configured in AWS CLI. Let's import the **target** profile.

```
Pacu (enumlab:No Keys Set) > import_keys target
  Imported keys as "imported-target"
Pacu (enumlab:imported-target) > 

```

> Listing 28 - Importing the target profile credentials in pacu.

The command prompt now indicates that we are using the keys imported from the _target_ profile.

Before we run any commands, it's important that we monitor the Cloudtrail event history using the _monitoring_ user credentials. This helps us study the actions the module is executing, further understand what an actual attack might look like and determine the amount of log noise our actions generate. We can also use this knowledge as a foundation for our own tools. If you have closed the Cloudtrail event history window, go ahead and open that now before we continue.

We are now ready to explore the enumeration modules. We can use **ls** to list all available modules.

```
Pacu (enumlab:imported-target) > ls
...
[Category: ENUM]

  enum__secrets
  codebuild__enum
  ecs__enum
  dynamodb__enum
  aws__enum_spend
  iam__enum_permissions
  aws__enum_account
  route53__enum
  ec2__download_userdata
  lightsail__enum
  ecs__enum_task_def
  ecr__enum
  rds__enum
  ebs__enum_volumes_snapshots
  cloudformation__download_data
  inspector__get_reports
  guardduty__list_findings
  guardduty__list_accounts
  iam__detect_honeytokens
  iam__bruteforce_permissions
  lambda__enum
  apigateway__enum
  ec2__check_termination_protection
  iam__enum_users_roles_policies_groups
  ec2__enum
  iam__get_credential_report
  glue__enum
  acm__enum
  systemsmanager__download_parameters
...
```

> Listing 29 - Listing all Modules in Pacu

Now let's run **help iam__enum_users_roles_policies_groups** to learn about this module.

```
Pacu (enumlab:imported-target) > help iam__enum_users_roles_policies_groups

iam__enum_users_roles_policies_groups written by Spencer Gietzen of Rhino Security Labs.

usage: pacu [--users] [--roles] [--policies] [--groups]

This module requests the info for all users, roles, customer-managed
policies, and groups in the account. If no arguments are supplied, it
will enumerate all four, if any are supplied, it will enumerate those
only.

options:
  --users     Enumerate info for users in the account
  --roles     Enumerate info for roles in the account
  --policies  Enumerate info for policies in the account
  --groups    Enumerate info for groups in the account
```

> Listing 30 - Getting usage help for a Module in Pacu.

This module works similarly to the **get-account-authorization-details** subcommand. It returns all the information related to IAM identities and policies. Let's run the module without any arguments so that it will return all info.

```
Pacu (enumlab:imported-target) > run iam__enum_users_roles_policies_groups
  Running module iam__enum_users_roles_policies_groups...
[iam__enum_users_roles_policies_groups] Found 18 users
[iam__enum_users_roles_policies_groups] Found 20 roles
[iam__enum_users_roles_policies_groups] Found 8 policies
[iam__enum_users_roles_policies_groups] Found 8 groups
[iam__enum_users_roles_policies_groups] iam__enum_users_roles_policies_groups completed.

[iam__enum_users_roles_policies_groups] MODULE SUMMARY:

  18 Users Enumerated
  20 Roles Enumerated
  8 Policies Enumerated
  8 Groups Enumerated
  IAM resources saved in Pacu database.
```

> Listing 31 - Running the iam__enum_users_roles_policies_groups Module in Pacu

The module found resources but note that the data was saved in Pacu's database as highlighted above. To display a list of services that have collected data in the current session we'll run the **services** command. Then we can run the **data <service>** command to display all data for the specified service in the session. Note that running the **data** command without any arguments will print all the data stored in the current session.

```
Pacu (enumlab:imported-target) > services
  IAM

Pacu (enumlab:imported-target) > data IAM
{
  "Groups": [
    {
      "Arn": "arn:aws:iam::123456789012:group/admin/admin",
      "GroupId": "AGPAQOMAIGYUZQMC6G5NM",
      "GroupName": "admin",
      "Path": "/admin/"
    },
    {
      "Arn": "arn:aws:iam::123456789012:group/amethyst/amethyst_admin",
      "GroupId": "AGPAQOMAIGYUYF3JD3FXV",
      "GroupName": "amethyst_admin",
      "Path": "/amethyst/"
    },
...
```

> Listing 32 - Reviewing the data collected in Pacu

According to the output, pacu collects the attributes that the tool's author considers relevant, which align with those we highlighted earlier: name, ARN and path.

Tools like Pacu abstract the process of collecting data, eliminating the need to learn specific AWS CLI commands. However, it's important to note that if the compromised credentials belong to an identity without authorization to access this information, no data will be received.

In this section, we presented another way to gather IAM information from a compromised account. In the next section, we'll analyze the data to extract valuable insights.

#### Labs

1. Which services are supported by the _iam__bruteforce_permissions_ module? (Write a comma-separated list of services in alphabetical order. Answer in lowercase. Example: acm,iam,s3)

Answer

2. Which Pacu command will let us change the currently active AWS key to another key that has previously been set for this session? (Write only the name of the command. Example: import_keys)

Answer

## 2.3.5. Extracting Insights from Enumeration Data

After collecting data, the next critical step is to sift through the data to extract valuable information and insights. This phase is crucial because raw enumeration data can be lengthy and it contains various information, some of which may be redundant, irrelevant, or benign. Proper analysis helps us identify the critical aspects of the data that can provide meaningful and actionable intelligence.

To correctly identify valuable insights we need to have clear objectives and understand what we are trying to achieve. Are we searching for vulnerabilities, business insights or system inefficiencies? Do we need to escalate privileges to obtain more insights? Having a clear goal helps us to focus on relevant data.

For example, let's assume that after gaining an initial compromise to our lab cloud environment, the attacker's goal is to escalate their current privileges to _Administrator_ access. We won't delve into privilege escalation attacks and exploiting the environment, as that's beyond the scope of this module. Instead, we'll focus on analyzing and discovering potential attack paths.

From the information collected so far after scoping IAM permissions we learned that with the current compromised access, we can execute many read-only actions but we can't change anything in the environment. However, the scope of actions we can execute is wide and we were able to collect the whole IAM configuration and list other resources. This is enough to define some escalation paths to accomplish the goal.

Let's start with an obvious path. We'll analyze the _admin-alice_ IAM user's data from the output of the **get-account-authorization-details** IAM subcommand.

```
kali@kali:~$ aws --profile target iam get-account-authorization-details --filter User Group --query "UserDetailList[?UserName=='admin-alice']"

[
    {
        "Path": "/admin/",
        "UserName": "admin-alice",
        "UserId": "AIDAQOMAIGYU3FWX3JOFP",
        "Arn": "arn:aws:iam::123456789012:user/admin/admin-alice",
        "GroupList": [
            "amethyst_admin",
            "admin"
        ],
        "AttachedManagedPolicies": [],
        "Tags": [
            {
                "Key": "Project",
                "Value": "amethyst"
            }
        ]
    }
]
```

> Listing 33 - Getting the "admin-alice" IAM user details

Several details indicate this might be a fully-privileged user. For instance, the username contains "admin", and it's also a member of the _admin_ User Group. There is another indicator that we can identify but we'll leave that as an exercise for later.

Also, notice that this IAM resource has a [_tag_](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html), a custom attribute label that we can assign to identify and organize AWS resources. Administrators often use tags to authorize access and operations. Each tag has two parts: a _tag key_ and an optional field known as a _tag value_. In this case, the tag has a _key_ set to _Project_ and a _value_ set to _amethyst_. We should pay attention to tags as they can reveal more about a resource.

Attribute-Based Access Control (ABAC) is an authorization strategy in which a subject's permission to perform a set of operations is determined by evaluating attributes associated with that subject. Tags are commonly used as attributes to implement ABAC in public cloud environments.

We also observe that the IAM user doesn't have any associated inline or managed policies, suggesting that the user probably inherits policies from its groups. Let's check the information of the two groups that the user belongs to.

```
kali@kali:~$ aws --profile target iam get-account-authorization-details --filter User Group --query "GroupDetailList[?GroupName=='admin']"

[
    {
        "Path": "/admin/",
        "GroupName": "admin",
        "GroupId": "AGPAQOMAIGYUXBR7QGLLN",
        "Arn": "arn:aws:iam::123456789012:group/admin/admin",
        "GroupPolicyList": [],
        "AttachedManagedPolicies": [
            {
                "PolicyName": "AdministratorAccess",
                "PolicyArn": "arn:aws:iam::aws:policy/AdministratorAccess"
            }
        ]
    }
]


kali@kali:~$ aws --profile target iam get-account-authorization-details --filter User Group --query "GroupDetailList[?GroupName=='amethyst_admin']"

[
    {
        "Path": "/amethyst/",
        "GroupName": "amethyst_admin",
        "GroupId": "AGPAQOMAIGYUX23CDL3AN",
        "Arn": "arn:aws:iam::123456789012:group/amethyst/amethyst_admin",
        "GroupPolicyList": [],
        "AttachedManagedPolicies": [
            {
                "PolicyName": "amethyst_admin",
                "PolicyArn": "arn:aws:iam::123456789012:policy/amethyst/amethyst_admin"
            }
        ]
    }
]
```

> Listing 34 - Getting the "admin" and "amethyst_admin" User Groups details

The _AdministratorAccess_ policy is an _AWS managed policy_ that grants full access to all AWS services and resources. The simplest way to obtain the policy document of any AWS managed policy, including the AdministratorAccess policy, is from the documentation, available at the [_AdministratorAccess Policy Document_](https://docs.aws.amazon.com/aws-managed-policy/latest/reference/AdministratorAccess.html)

From the documentation page, we get the following policy document. Let's analyze it.

```
{
  "Version" : "2012-10-17",
  "Statement" : [
    {
      "Effect" : "Allow",
      "Action" : "*",
      "Resource" : "*"
    }
  ]
}
```

> Listing 35 - Analyzing the AdminitratorAccess Policy Document

Notice that the JSON policy document uses the _"*"_ wildcard in both _Action_ and _Resource_ elements. This is overly-permissive, since any user in the _admin_ group, such as _admin-alice_, becomes a potential target for privilege escalation in the environment.

Let's pause for a moment to analyze the situation. So far we have identified two paths to full-privileged access.

One path might be to find a way to run actions with the _admin-alice_ user privileges. One external approach might be to social engineer Alice's password to enter the management console, especially because we previously confirmed that there is no multi-factor authentication configured for any user. Another approach would be to search for other credentials that have permission to modify the _admin-alice_ credentials. In this case, we could look for policies with _iam:"*"_, or _iam:CreateAccessKey_ allowed actions.

A second path would include obtaining credentials for another member of the _admin_ user group or find a user that has permission to add users to the _admin_ group. To accomplish this, we could search for policies with _iam:"*"_, or _iam:AddUserToGroup_ allowed actions.

To continue the analysis let's display the policies associated with the _amethyst_admin_ user group to learn what actions the _admin-alice_ user inherits from it. We'll continue using the **get-account-authorization-details** IAM subcommand to get this information.

```
kali@kali:~$ aws --profile target iam get-account-authorization-details --filter LocalManagedPolicy --query "Policies[?PolicyName=='amethyst_admin']"

[
    {
        "PolicyName": "amethyst_admin",
        "PolicyId": "ANPAQOMAIGYUUA3PZUK57",
        "Arn": "arn:aws:iam::123456789012:policy/amethyst/amethyst_admin",
        "Path": "/amethyst/",
        "DefaultVersionId": "v7",
        "AttachmentCount": 1,
        "PermissionsBoundaryUsageCount": 0,
        "IsAttachable": true,
        "PolicyVersionList": [
            {
                "Document": {
                    "Statement": [
                        {
                            "Action": "iam:*",
                            "Effect": "Allow",
                            "Resource": [
                                "arn:aws:iam::123456789012:user/amethyst/*",
                                "arn:aws:iam::123456789012:group/amethyst/*",
                                "arn:aws:iam::123456789012:role/amethyst/*",
                                "arn:aws:iam::123456789012:policy/amethyst/*"
                            ],
                            "Sid": "AllowAllIAMActionsInUserPath"
                        },
                        {
                            "Action": "iam:*",
                            "Condition": {
                                "StringEquals": {
                                    "aws:ResourceTag/Project": "amethyst"
                                }
                            },
                            "Effect": "Allow",
                            "Resource": "arn:aws:iam::*:user/*",
                            "Sid": "AllowAllIAMActionsInGroupMembers"
                        },
                        {
                            "Action": [
                                "ec2:*",
                                "lambda:*"
                            ],
                            "Condition": {
                                "StringEquals": {
                                    "aws:ResourceTag/Project": "amethyst"
                                }
                            },
                            "Effect": "Allow",
                            "Resource": "*",
                            "Sid": "AllowAllActionsInTaggedResources"
                        },
                        {
                            "Action": [
                                "ec2:*",
                                "lambda:*"
                            ],
                            "Condition": {
                                "StringEquals": {
                                    "aws:RequestTag/Project": "amethyst"
                                }
                            },
                            "Effect": "Allow",
                            "Resource": "*",
                            "Sid": "AllowAllActionsInTaggedResources2"
                        },
                        {
                            "Action": "s3:*",
                            "Effect": "Allow",
                            "Resource": [
                                "arn:aws:s3:::amethyst*",
                                "arn:aws:s3:::amethyst*/*"
                            ],
                            "Sid": "AllowAllS3ActionsInPath"
                        }
                    ],
                    "Version": "2012-10-17"
                },
                "IsDefaultVersion": true,
            },
    }
]
```

> Listing 36 - Getting the "amethyst_admin" policy statements

This provides details about the _amethyst_admin_ policy. Let's focus on the **PolicyVersionList** section which holds the _Policy Statements_, essentially the permission definitions.

The _Policy Document_ contains a few _Statements_: _AllowAllIAMActionsInUserPath_, _AllowAllIAMActionsInGroupMembers_, _AllowAllActionsInTaggedResources_, _AllowAllActionsInTaggedResources2_, and _AllowAllS3ActionsInPath_. These statements are designed to permit actions for IAM, as well as other compute and storage services. However, these actions are constrained to only those resources associated with the _amethyst_ project either by tag or path. It's safe to assume that these statements are potentially over-permissive.

The use of the "*" wildcard in a policy often raises concerns regarding the potential over-permissiveness of that policy.

Let's analyze the _AllowAllIAMActionsInGroupMembers_ statement. This rule allows any IAM action to run on any resource that has a tag with a key-value pair equal to "Project:amethyst". This would prevent the administrator users of this project from modifying users from other projects.

For some reason, the _admin-alice_ user, which is highly-privileged, is a member of the _amethyst_admin_ group and the user is also tagged with the project name. The main problem is the tag, because any user who is a member of the _amethyst_admin_ group can run dangerous actions like creating new access keys (_iam:CreateAccessKey_) for the _admin-alice_ user, granting access with the privileges of this user. So, getting credentials from the _admin-cbarton_ IAM user could lead to privilege escalation.

The following figure describes a path an attacker may take to escalate the _admin-cbarton_ user to an **Effective Admin**. This image was created by [_Awspx_](https://github.com/WithSecureLabs/awspx), a graph-based tool for visualizing effective access and resource relationships within AWS.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/c89e5a94c18951a0452ee208c538934e_MD5.jpg]]

Figure 4: Drawing the path to privilege escalation from the admin-cbarton IAM user

The path reveals that the user admin-cbarton, positioned at the bottom-left, is a member of the amethyst_admin group and thereby inherits the amethyst_admin policy. At the top, we find admin-alice, a member of the admin group, linked to the AdministratorAccess policy, which makes this user an Effective Admin. The path indicates that the admin-cbarton user has permission to impersonate the higher-privileged admin-alice user.

This is an example of extrapolating valuable insights from the enumerated data. We have discovered a new attack path. Although this is not a direct path within our current level of access, identifying these insights can guide our subsequent strategic decisions and actions to accomplish the goal.

In the lab, we can experiment with attack vectors using the IAM user _challenge_. This user is granted the _iam:CreateAccessKey_ action, enabling it to generate credentials to interface with any other user within the lab environment. For example, we can create access keys for the _admin-cbarton_ IAM user and validate that we can escalate privileges as we learned before.

In this lab, we worked through a simplified environment focusing primarily on IAM resources. But in the real world, sifting through the potentially large volume of enumeration data in search of actionable insights can be highly labor-intensive.

Automated tools can help manage this data. They are typically designed to present the data in a more organized and visual manner, making it easier to understand the details. For example, [_Cloudmapper_](https://github.com/duo-labs/cloudmapper) provides visual representations of AWS configurations, helping identify potential issues. We also mentioned _Awspx_ which is useful for analyzing how IAM resources interlink. The selection of a particular tool often depends on the type of assessment and the desired outcomes.

#### Labs

1. Run an analysis, like we did in the example for this section, to find a user in another group that has dangerous permissions that could lead to privilege escalation in the environment. Write the username as the answer.

Answer

## 2.4. Wrapping Up

In this module, we discussed reconnaissance methods that often follow an initial compromise of a public cloud environment. We focused on collecting important information about the scope of access we gained in the environment.

Occasionally, we can determine the level of authorization by directly querying for that information with the compromised credentials. However, if we lack permissions to access this data, we must resort to some guesswork or using an automated tool that scopes the level of access through brute force, though this approach is not advisable if our goal is to remain undetected.

We then enumerated additional IAM resources in the compromised account and discussed the differences between manual and automated enumeration. To conclude, we analyzed the information gathered to identify potential paths for gaining administrative access in the compromised environment.