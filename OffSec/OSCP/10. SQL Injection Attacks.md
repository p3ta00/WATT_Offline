# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer

# 10\. SQL Injection Attacks

In this Learning Module, we will cover the following Learning Units:

-   SQL Theory and Database Types
-   Manual SQL Exploitation
-   SQL Attack Automation

_SQL injection_ (SQLi) is a major web application vulnerability class prevalent in many web applications. It is currently ranked third among [_OWASP's Top 10_](https://owasp.org/www-project-top-ten/) Application Security Risks. It is listed as: [_A03:2021-Injection_](https://owasp.org/Top10/A03_2021-Injection/)

In general, SQLi vulnerabilities enable attackers to meddle with SQL queries exchanged between the web application and database. SQL vulnerabilities typically allow the attacker to extend the original application query to include database tables that would normally be inaccessible.

In this Learning Module, we are going to demonstrate both SQL enumeration and database fingerprinting, along with manual and automated exploitation of SQLi.

## 10.1. SQL Theory and Databases

This Learning Unit covers the following Learning Objectives:

-   Refresh SQL Theory Fundamentals
-   Learn About Different DB Types
-   Understand the Different SQL Syntax

## 10.1.1. SQL Theory Refresher

_Structured Query Language_ (SQL) has been developed specifically to manage and interact with data stored inside [_relational databases_](https://en.wikipedia.org/wiki/Relational_database). SQL can be employed to query, insert, modify, or even delete data, and, in some cases, execute operating system commands. Since the SQL instance offers so many administrative privileges, we'll soon observe how arbitrary SQL queries can pose a significant security risk.

Modern web applications are usually designed around a user-facing interface referred to as the _frontend_, which is typically created using different code blocks written in HTML, CSS, and JavaScript.

After the client interacts with the frontend, it sends data to the _backend_ application layer that is running on the server. Several different frameworks can be used to construct a backend application, written in various languages including PHP, Java, and Python.

Next, the backend code interacts with the data residing in the database in various ways, such as retrieving the password associated with a given username.

SQL syntax, commands, and functions vary based on which relational database they were made for. _MySQL_, _Microsoft SQL Server_, _PostgreSQL_, and _Oracle_ are the most popular database implementations, and we are going to inspect each variant's characteristics.

As an example, let's build a simple MySQL query to parse the _users_ table and retrieve a specific user entry.

We can use the **SELECT** statement to instruct the database that we want to retrieve all (**\***) the records from a specific location defined via the **FROM** keyword and followed by the target, in this case, the **users** table. Finally, we'll direct the database to filter only for records belonging to the user **leon**.

```
SELECT * FROM users WHERE user_name='leon'
```

> Listing 1 - SQL query that parses the users table

To automate functionality, web applications often embed SQL queries within their source code.

We can better understand this concept by examining the following backend PHP code portion that is responsible for verifying user-submitted credentials during login:

```
<?php
$uname = $_POST['uname'];
$passwd = $_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

> Listing 2 - SQL Query Embedded in PHP Login Source Code

Highlighted above is a semi-precompiled SQL query that searches the users table for the provided username and its respective password, which are saved into the _$uname_ and _$passwd_ variables. The query string is then stored in _sql\_query_ and used to perform the query against the local database through the [_mysqli\_query_](https://www.php.net/manual/en/mysqli.query.php) function, which saves the result of the query in _$result_.

Please note that the _i_ inside the _mysqli\_query_ PHP function stands for _improved_ and should not be confused with the vulnerability (as the _i_ in SQLi stands for _injection_).

So far, we've described a very basic interaction between backend PHP code and the database. Reviewing the above code snippet, we'll notice that both the _user\_name_ and _password_ variables are retrieved from the user _POST_ request and inserted directly in the _sql\_query_ string, without any prior check. This means that an attacker could modify the final SQL statement before it is executed by the SQL database.

An attacker could insert an SQL statement inside the _user_ or _password_ field to subvert the intended application logic.

Let's consider an example. When the user types **leon**, the SQL server searches for the username "leon" and returns the result. To search the database, the SQL server runs the query **SELECT \* FROM users WHERE user\_name= leon**. If, instead, the user enters "leon '+!@#$", the SQL server will run the query **SELECT \* FROM users WHERE user\_name= leon'+!@#$**. Nothing in our code block checks for these special characters, and it's this lack of filtering that causes the vulnerability.

We'll discover how these types of scenarios can be abused in the next sections.

## 10.1.2. DB Types and Characteristics

When testing a web application, we sometimes lack prior knowledge of the underlying database system, so we should be prepared to interact with different SQL database variants.

Many DB variants differ in syntax, function, and features. In this section, we are going to focus on two of the most common database variants, MySQL and Microsoft SQL Server (MSSQL).

The two SQL variants we're exploring in this Learning Module are not limited to on-premise installations, as they can often be found in cloud deployments.

[_MySQL_](https://www.mysql.com/) is one of the most deployed database variants, along with [_MariaDB_](https://mariadb.org), an open-source fork of MySQL.

To explore MySQL basics, we can connect to the remote MySQL instance from our local Kali machine.

Using the **mysql** command, we'll connect to the remote SQL instance by specifying **root** as username and password, along with the default MySQL server port **3306**.

```
kali@kali:~$ mysql -u root -p'root' -h 192.168.50.16 -P 3306

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]>
```

> Listing 3 - Connecting to the remote MySQL instance

From the MySQL console shell, we can run the _version()_ function to retrieve the version of the running SQL instance.

```
MySQL [(none)]> select version();
+-----------+
| version() |
+-----------+
| 8.0.21    |
+-----------+
1 row in set (0.107 sec)
```

> Listing 4 - Retrieving the version of a MySQL database

We can also verify the current database user for the ongoing session via the _system\_user()_ function, which returns the current username and hostname for the MySQL connection.

```
MySQL [(none)]> select system_user();
+--------------------+
| system_user()      |
+--------------------+
| root@192.168.20.50 |
+--------------------+
1 row in set (0.104 sec)
```

> Listing 5 - Inspecting the current session's user

The database query we ran confirmed that we are logged in as the database root user through a remote connection from 192.168.20.50.

The _root_ user in this example is the database-specific root user, not the system-wide administrative root user.

We can now collect a list of all databases running in the MySQL session by issuing the **show** command, followed by the **databases** keyword.

```
MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
5 rows in set (0.107 sec)
```

> Listing 6 - Listing all Available Databases

As an example, let's retrieve the password of the _offsec_ user present in the _mysql_ database.

Within the mysql database, we'll filter using a **SELECT** statement for the **user** and **authentication\_string** value belonging to the **user** table. Next, we'll filter all the results via a **WHERE** clause that matches only the **offsec** user.

```
MySQL [mysql]> SELECT user, authentication_string FROM mysql.user WHERE user = 'offsec';
+--------+------------------------------------------------------------------------+
| user   | authentication_string                                                  |
+--------+------------------------------------------------------------------------+
| offsec | $A$005$?qvorPp8#lTKH1j54xuw4C5VsXe5IAa1cFUYdQMiBxQVEzZG9XWd/e6|
+--------+------------------------------------------------------------------------+
1 row in set (0.106 sec)
```

> Listing 7 - Inspecting user's encrypted password

To improve its security, the user's password is stored in the _authentication\_string_ field as a [_Caching-SHA-256 algorithm_](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html).

A password hash is a ciphered representation of the original plain-text password. In later Learning Modules, we'll learn how password hashing is performed and how a hash can be reversed or cracked to obtain the original password.

Having covered the basics of MySQL, let's explore MSSQL.

[_MSSQL_](http://www.microsoft.com/sqlserver) is a database management system that natively integrates into the Windows ecosystem.

Windows has a built-in command-line tool named [_SQLCMD_](https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility), that allows SQL queries to be run through the Windows command prompt or even remotely from another machine.

Kali Linux includes [_Impacket_](https://github.com/SecureAuthCorp/impacket), a Python framework that enables network protocol interactions. Among many other protocols, it supports [_Tabular Data Stream_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tds/893fcc7e-8a39-4b3c-815a-773b7b982c50/) (TDS), the protocol adopted by MSSQL that is implemented in the _impacket-mssqlclient_ tool.

We can run **impacket-mssqlclient** to connect to the remote Windows machine running MSSQL by providing a username, a password, and the remote IP, together with the **\-windows-auth** keyword. This forces NTLM authentication (as opposed to Kerberos). We'll explore Windows authentication in more depth in upcoming Learning Modules.

```
kali@kali:~$ impacket-mssqlclient Administrator:Lab123@192.168.50.18 -windows-auth
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] Encryption required, switching to TLS
[*] ENVCHANGE(DATABASE): Old Value: master, New Value: master
[*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english
[*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed database context to 'master'.
[*] INFO(SQL01\SQLEXPRESS): Line 1: Changed language setting to us_english.
[*] ACK: Result: 1 - Microsoft SQL Server (150 7208)
[!] Press help for extra shell commands
SQL (SQLPLAYGROUND\Administrator  dbo@master)>
```

> Listing 8 - Connecting to the Remote MSSQL instance via Impacket

To begin, let's inspect the current version of the underlying operating system by selecting the **@@version**.

Every database management system has its own syntax that we should take into consideration when enumerating a target during a penetration test.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT @@version;
...

Microsoft SQL Server 2019 (RTM) - 15.0.2000.5 (X64)
Sep 24 2019 13:48:23
Copyright (C) 2019 Microsoft Corporation
Express Edition (64-bit) on Windows Server 2022 Standard 10.0 <X64> (Build 20348: ) (Hypervisor)
```

> Listing 9 - Retrieving the Windows OS Version

Our query returned valuable information about the running version of the MSSQL server along with the Windows Server version, including its build number.

When using an SQL Server command line tool like sqlcmd, we must submit our SQL statement ending with a semicolon followed by _GO_ on a separate line. However, when running the command remotely, we can omit the GO statement since it's not part of the MSSQL TDS protocol.

To list all the available databases, we can select all names from the system catalog.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT name FROM sys.databases;
name
...
master

tempdb

model

msdb

offsec

SQL>
```

> Listing 10 - Inspecting the Available Databases

Since _master_, _tempdb_, _model_, and _msdb_ are default databases, we want to explore the custom _offsec_ database because it might contain data belonging to our target. We can review this database by querying the _tables_ table in the corresponding _information\_schema_.

```
SQL (SQLPLAYGROUND\Administrator  dbo@master)> SELECT * FROM offsec.information_schema.tables;
TABLE_CATALOG   TABLE_SCHEMA   TABLE_NAME   TABLE_TYPE   
-------------   ------------   ----------   ----------   
offsec          dbo            users        b'BASE TABLE'   

SQL (SQLPLAYGROUND\Administrator  dbo@master)> 
```

> Listing 11 - Inspecting the Available Tables in the offsec Database

Our query returned the _users_ table as the only one available in the database, so let's inspect it by selecting all of its records. We'll need to specify the _dbo_ table schema between the database and the table names.

```
SQL>select * from offsec.dbo.users;
username     password     
----------   ----------   
admin        lab        

guest        guest 
```

> Listing 12 - Exploring Users Table Records

The users table contains the columns, _user_, and _password_, and two rows. Our query returned the clear text password for both usernames.

Having covered the basic syntax peculiarities for MySQL and MSSQL databases, next, we'll learn how to manually exploit SQL injection vulnerabilities.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #1

SQL Injections Attacks - SQL Theory and Databases - MSSQL - VM #2

SQL Injections Attacks - SQL Theory and Databases - MySQL - VM #3

#### Labs

1.  From your Kali Linux VM, connect to the remote MySQL instance on VM 1 and replicate the steps to enumerate the MySQL database. Then explore all values assigned to the user _offsec_. Which _plugin_ value is used as a password authentication scheme?

Answer