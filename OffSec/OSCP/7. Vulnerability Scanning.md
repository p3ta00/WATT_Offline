In this Learning Module, we will cover the following Learning Units:

- Vulnerability Scanning Theory
- Vulnerability Scanning with Nessus
- Vulnerability Scanning with Nmap

The discovery of vulnerabilities is an integral part of any security assessment. The process of identifying the attack surface of a piece of software, system, or network is called [*Vulnerability Scanning*](https://en.wikipedia.org/wiki/Vulnerability_scanner).

Vulnerability scanners come in many different forms, from individual scripts that identify a single vulnerability to complex commercial solutions that scan a broad variety of vulnerabilities. Automated vulnerability scanners can be invaluable for penetration testers as they help quickly establish a baseline on the target network before performing a more thorough manual testing analysis to get adequate coverage. Common types of vulnerability scanners are web application and network vulnerability scanners.

In this Module, we will analyze automated network vulnerability scanning. We'll begin with the theory behind vulnerability scanning and then use [*Nessus*](https://www.tenable.com/products/nessus) and [*Nmap*](https://nmap.org/) to perform different kinds of vulnerability scans.

## 7.1. Vulnerability Scanning Theory

This Learning Unit covers the following Learning Objectives:

- Gain a basic understanding of the vulnerability scanning process
- Learn about the different types of vulnerability scans
- Understand the considerations of a vulnerability scan

In this Learning Unit, we'll discuss the theory behind vulnerability scanning. Before inspecting our tools, we need to outline the basic workflow of a vulnerability scanner and understand how it finds vulnerabilities. We will also review the different types and considerations of a vulnerability scan.

## 7.1.1. How Vulnerability Scanners Work

Every vulnerability scanner has its own customized workflow but the basic process behind vulnerability scanning is implementation independent. The basic process of an automated vulnerability scanner can be described as:

1. Host discovery
2. Port scanning
3. Operating system, service, and version detection
4. Matching the results to a vulnerability database

[*Host Discovery*](https://capec.mitre.org/data/definitions/292.html) tells the scanner if the target is up and responding. The scanner then uses various techniques to identify all open ports on the system and detect all remotely accessible services with corresponding versions. In addition, operating system detection will be done in this step.

Based on all gathered information, the vulnerability scanner will then query a vulnerability database to match the found data to vulnerabilities. Examples of vulnerability databases are the [*National Vulnerability Database*](https://nvd.nist.gov/) and the [*Common Vulnerabilities and Exposures*](https://cve.mitre.org/cve/search_cve_list.html) (CVE) program.

Most commercial vulnerability scanners also have the functionality to verify found vulnerabilities by attempting to partially or fully exploit them. This can significantly reduce missed vulnerabilities but can impact the stability of the service or system.

Vulnerabilities are identified by the [CVE system](https://cve.mitre.org/). While this allows us to identify and find verified vulnerabilities, the CVE identifier provides no information about the severity of a vulnerability.

The [*Common Vulnerability Scoring System*](https://nvd.nist.gov/vuln-metrics/cvss) (CVSS) is a framework for addressing the characteristics and severity of vulnerabilities. Each CVE has a CVSS score assigned. The two major versions are [CVSS v2](https://www.first.org/cvss/v2/guide) and [CVSS v3](https://www.first.org/cvss/user-guide). Both versions use a range from 0 to 10 to rate vulnerabilities with different severity labels. The following figure from the [*National Institute of Standards and Technology*](https://www.nist.gov/) (NIST) lists the range of the base score and associated severity for CVSS v2.0 and CVSS v3.0.

![[OffSec/OSCP/z. images/c5c84511455f898ab6fd8849ac8a49c2_MD5.jpg]]

Figure 1: CVSS Ratings

To obtain a CVSS score, we can review the CVE in a vulnerability database, or if there is no CVE assigned, we can use a [*CVSS calculator*](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator). In 2019, CVSS v3.1 was released, which clarified and improved the existing version.

We need to be aware that the results of a vulnerability scan can be incomplete or contain wrongfully detected vulnerabilities.

A [*false positive*](https://www.cgisecurity.com/questions/falsepositive.shtml) occurs when a vulnerability is detected but the target is not vulnerable. This can happen through a wrong service and version detection or a configuration that makes the target unexploitable. False positives can also occur when patches or updates are [*backported*](https://access.redhat.com/security/updates/backporting), meaning that security fixes are applied to an older version of software.

[*False negative*](https://www.cgisecurity.com/questions/falsenegative.shtml) is another important term. It occurs when a vulnerability is missed by the vulnerability scanner.

In a penetration test, we often need to find the right balance between manual and automated vulnerability scanning. Let's explore both options briefly.

A manual vulnerability scan will inevitably be very resource-intensive and time-consuming. When there is a huge amount of data to analyze, we often reach our cognitive limit quickly and overlook vital details. On the other hand, manual vulnerability scanning allows for the discovery of complex and logical vulnerabilities that are rather difficult to discover using any type of automated scanner.

Automated vulnerability scans are invaluable when working on engagements for a multitude of reasons. First, in nearly all types of assessments, we have time constraints. Therefore, when we have a big enterprise network to scan, we cannot manually review every system. This is especially true when thinking about new or complex vulnerabilities. Second, by using automated scanners, we can quickly identify easily detected vulnerabilities and other low-hanging fruit.

We should take the time to explore the inner workings of every automated tool we plan to use in a security assessment. This will not only assist us in configuring the tool and digesting the results properly but doing that will help us understand the limitations that must be overcome with manually applied expertise.

#### Labs

1. Is this a false positive or a false negative? A vulnerability scanner identifies a vulnerability for a Linux web server. The target runs on Windows and the vulnerability is only exploitable on Linux.

Answer

2. Is this a false positive or a false negative? A vulnerability scanner detects the wrong version of an FTP service. The detected version has no vulnerabilities, but the running FTP service is vulnerable.

Answer

## 7.1.2. Types of Vulnerability Scans

In this section, we will examine *internal* and *external* as well as *unauthenticated* and *authenticated* vulnerability scans.

The location where we perform the vulnerability scan determines the target visibility. If a client tasks us with an external vulnerability scan, they mean to analyze one or more systems that are accessible from the internet. Targets in an external vulnerability scan are often web applications, systems in the [*demilitarized zone*](https://en.wikipedia.org/wiki/DMZ_\(computing\))(DMZ), and public-facing services.

The client intends to get an overview of the security status of all systems that are accessible by an external attacker. In most cases, we get a list of IP addresses the client wants us to scan but occasionally, they want us to map all external accessible systems and services by ourselves. While a company should always know which of their systems are publicly accessible, it's not always the case. As a result, we will often find externally exposed sensitive systems and services that the company is not aware of.

On the other hand, there is the internal vulnerability scan where we have direct access to either a part of or the complete internal network of a client. When a client tasks us with this kind of vulnerability scan, we either get [*VPN*](https://en.wikipedia.org/wiki/Virtual_private_network) access or perform the scan on-site. The intention is to get an overview of the security status of the internal network. It is important to analyze which vectors an attacker can use after breaching the perimeter.

The next two scan types we will examine are authenticated and unauthenticated vulnerability scans. When we perform a vulnerability scan on a system without providing credentials, it is called an unauthenticated vulnerability scan. Unauthenticated scans are made to find vulnerabilities in remotely accessible services on a target. Therefore, they map the system with all open ports and provide us with an attack surface by matching the information to vulnerability databases as mentioned before.

However, we get no information about local security flaws, such as missing patches, outdated software, or configuration vulnerabilities on the system itself. For example, in an unauthenticated vulnerability scan on a Windows target, we cannot determine if the system is patched against the [*HiveNightmare*](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-36934) vulnerability, which allows an unprivileged user to read sensitive system files. This is where authenticated scans come into play.

Most scanners can be configured to run authenticated scans, in which the scanner logs in to the target with a set of valid credentials. In most instances, authenticated scans use a privileged user account to have the best visibility into the target system. The goal of authenticated vulnerability scans is to check for vulnerable packages, missing patches, or configuration vulnerabilities.

We will perform both authenticated and unauthenticated scans in the next Learning Unit, but first, let's discuss how to obtain accurate and conclusive results.

#### Labs

1. Do you need to perform an authenticated or an unauthenticated vulnerability scan in the following scenario? You want to determine if all current patches on a Linux system are installed.

Answer

2. Do you need to perform an authenticated or an unauthenticated vulnerability scan in the following scenario? You want to analyze the perimeter of a server on the internet from the perspective of a malicious actor.

Answer

## 7.1.3. Things to consider in a Vulnerability Scan

In this section, we will cover a few things we need to consider when planning and performing a vulnerability scan. In large engagements, we need to configure the vulnerability scanner carefully to get meaningful and relevant results.

The first consideration we'll discuss is the scanning duration. Depending on the scanning type and number of targets, the duration of an automated scan can vary greatly. Because external scans over the internet can be time-consuming due to the number of hops and intermediate systems on the network route, we must plan accordingly if we have a large list of IP addresses.

We also need to discuss target visibility. While it is easy to input an IP address and start the vulnerability scan, we often have to properly consider our targets. It's important to determine if our targets are accessible without the need for any VPNs or permissions in a firewall. In most cases, a client providing a list of IP addresses for an external scan isn't a cause for concern. But if we are single-handedly determining the attack surface of a client's publicly accessible infrastructure, we need to understand that firewalls and other access restriction mechanisms, which could make systems and services inaccessible, might be in place.

For example, an international client has several systems in multiple countries. They restrict access from all IP addresses outside of the country where each system is located. From our location, we are only able to access the systems located in our country while all others are inaccessible to us.

Let's also consider target visibility in an internal engagement. We need to think about our positioning in the network to get meaningful results, especially when we want to scan systems from other subnets. Keep in mind that firewalls, [*intrusion prevention systems*](https://www.vmware.com/topics/glossary/content/intrusion-prevention-system.html) (IPS), and intermediate network devices (such as routers), can filter or alter our traffic. One example of this is when a vulnerability scanner sends ICMP packets in the Host Discovery step and the intermediate device does not forward them. Hence, the scanner marks the target as offline.

In addition, our scan can be affected by [*rate limiting*](https://en.wikipedia.org/wiki/Rate_limiting), which is used to limit the amount of traffic on a network. When our scan exceeds thresholds like throughput, packet count, or connection count, the source system of our vulnerability scan can be drastically restricted in the context of networking capabilities. When the host discovery and service detection probes are rate-limited and therefore slowed down, the vulnerability scanner may miss live hosts or services. Most vulnerability scanners can address this by specifying delays, timeouts, and limiting parallel connections.

Finally, let's review the network and system impact of vulnerability scans. A vulnerability scanner produces a lot of network traffic in most configurations, especially if we want to scan multiple targets in a parallel way. This can easily render a network unusable. To address this, we could reduce the number of parallel scans or the scanning speed. An even bigger problem is the potential impact of our vulnerability scan on the stability of a system. We need to consider that every vulnerability scan can bring instability to any system or service we scan.

#### Labs

1. Is the following statement true or false? A vulnerability scan can never impact the stability of a target system or service.

Answer

2. Is the following statement true or false? Rate limiting can be the reason that a vulnerability scanner can flag a live target system as offline.

Answer

## 7.2. Vulnerability Scanning with Nessus

This Learning Unit covers the following Learning Objectives:

- Install Nessus
- Understand the different Nessus components
- Configure and perform a vulnerability scan
- Understand and work with the results of a vulnerability scan with Nessus
- Provide credentials to perform an authenticated vulnerability scan
- Gain a basic understanding of Nessus plugins

In this Learning Unit, we'll focus on Nessus, which is one of the most popular vulnerability scanners, containing over 67000 [CVEs](https://cve.mitre.org/) and [168000 plugins](https://www.tenable.com/plugins).

[Nessus](https://www.tenable.com/products/nessus) is available as *Nessus Essentials* and *Nessus Professional*. We will use the free version, Nessus Essentials, which comes with some restrictions and constraints. For example, we can only scan 16 different IP addresses, and some templates and functions are not available. However, Nessus Essentials will give us insight into how to use the full commercial version and the general concepts discussed in this section will also apply to most commercial scanners.

## 7.2.1. Installing Nessus

For this Learning Unit, we'll need to install Nessus on the Kali Linux VM, which is used to connect to the PEN-200 lab environment. An internet connection and a business email address will be necessary to download and activate Nessus. The minimum hardware requirements [*Tenable* recommends](https://docs.tenable.com/generalrequirements/Content/NessusScannerHardwareRequirements.htm) are 4 CPU cores and 8GB of RAM. However, we don't need to meet those requirements for our exercises. 2 CPU cores and 4GB of RAM are sufficient for our needs.

Nessus is not available in the Kali repositories and needs to be installed manually. We can download the current version of Nessus as a 64-bit [*.deb*](https://en.wikipedia.org/wiki/Deb_\(file_format\)) file for Kali from the [Tenable website](https://www.tenable.com/downloads/nessus). There, we also get the [*SHA256*](https://en.wikipedia.org/wiki/SHA-2) and [*MD5*](https://en.wikipedia.org/wiki/MD5) checksums for the installer.

Learners using an Apple system with an ARM-based chip can install Nessus on a Kali VM by downloading the installer for the **Linux - Ubuntu - arch64** platform.

Let's select **Linux - Debian - amd64** as the platform and download the installer.

![[OffSec/OSCP/z. images/97cbfdd48a2389158513d65a86656e58_MD5.jpg]]

Figure 2: Download Nessus for Kali

After downloading the installer, we'll check the SHA256 checksum to validate it. To do this, we click the *Checksum* button and copy the SHA256 checksum to the clipboard via the copy icon.

We then **echo** the copied checksum together with the filename of the installer into a file with the name **sha256sum\_nessus**. Since the button next to the SHA256 checksum only copies the checksum itself, we need to enter the file name manually. The resulting **sha256sum\_nessus** file needs to be in the same directory as the Nessus installer. We will then use [**sha256sum**](https://man7.org/linux/man-pages/man1/sha256sum.1.html) with the **\-c** parameter to verify the checksum.

```
kali@kali:~$ cd ~/Downloads

kali@kali:~/Downloads$ echo "4987776fef98bb2a72515abc0529e90572778b1d7aeeb1939179ff1f4de1440d Nessus-10.5.0-debian10_amd64.deb" > sha256sum_nessus

kali@kali:~/Downloads$ sha256sum -c sha256sum_nessus
Nessus-10.5.0-debian10_amd64.deb: OK
```

> Listing 1 - Verifying the checksum

The output shows that the checksums match, which means we can install the package. If there is an updated version of Nessus, the checksum from the previous listing will be different and needs to be adapted.

To install the Nessus package, we'll use [**apt**](https://en.wikipedia.org/wiki/APT_\(software\)) with the **install** option.

```
kali@kali:~/Downloads$ sudo apt install ./Nessus-10.5.0-debian10_amd64.deb
...
Preparing to unpack .../Nessus-10.5.0-debian10_amd64.deb ...
Unpacking nessus (10.5.0) ...
Setting up nessus (10.5.0) ...
...
Unpacking Nessus Scanner Core Components...
 - You can start Nessus Scanner by typing /bin/systemctl start nessusd.service
 - Then go to https://kali:8834/ to configure your scanner
```

> Listing 2 - x64 Nessus installation

After the installation is complete, we can start the *nessusd* service via [**systemctl**](https://en.wikipedia.org/wiki/Systemd).

```
kali@kali:~/Downloads$ sudo systemctl start nessusd.service
```

> Listing 3 - Starting Nessus

Once Nessus is running, we can launch a browser and navigate to **https://127.0.0.1:8834**. We will be presented with a warning indicating an unknown certificate issuer, which is expected due to the use of a self-signed certificate. To accept and trust the self-signed certificate, we can click on *Advanced...* and then *Accept the Risk and Continue*.

![[OffSec/OSCP/z. images/e5667989bceb0eac7da8e6114ef1b212_MD5.jpg]]

Figure 3: Nessus Presenting a Certificate Warning

After the page loads, we are prompted to configure pre-installation settings. Let's click on *Continue* to start the installation with the default settings.

![[OffSec/OSCP/z. images/e5ee3ff48333a05ff55dab0979e6ee98_MD5.jpg]]

Figure 4: Configuring Pre-Installation Settings

Now, we can select a Nessus product. For this Learning Unit, we'll choose *Register for Nessus Essentials* and click *Continue*.

![[OffSec/OSCP/z. images/fd9c116c0936b7861b740b4482634891_MD5.jpg]]

Figure 4: Selecting Nessus Essentials

Next, we are prompted to request an activation code for Nessus Essentials. We'll provide the required information and click *Register*.

![[OffSec/OSCP/z. images/861c26469ac62c33b427f0ed1fb85f98_MD5.jpg]]

Figure 5: Requesting an Activation Code

Once we have registered, the activation code is shown in the next window.

![[OffSec/OSCP/z. images/cc6ce8d060010d240110b5b178ceb823_MD5.jpg]]

Figure 6: Activating Nessus

Next, we'll create a local Nessus user account. We'll choose the username *admin* with a strong password to protect our vulnerability scan results. We'll use these credentials to log in to the Nessus application.

![[OffSec/OSCP/z. images/bff2ddc36c72cba2a0ba8785b3f8b721_MD5.jpg]]

Figure 7: Creating a Local Nessus Account

Finally, Nessus downloads and compiles all plugins. This can take a significant amount of time to complete.

![[OffSec/OSCP/z. images/3225f8be1164f0cb7d32e0b309e8f1a5_MD5.jpg]]

Figure 8: Downloading Nessus Plugins

After the plugins are downloaded and installed, we have a working instance of Nessus Essentials.

#### Labs

1. Follow the steps above to install Nessus Essentials. What is the command to start the nessusd service after a successful installation from an unprivileged account?

Answer

## 7.2.2. Nessus Components

Before we start our first vulnerability scan with Nessus, we'll take some time to get familiar with the core components. When we log in for the first time, we find a welcome window that allows us to enter targets. We can close it without entering anything for now.

First, let's investigate the tabs in the Nessus dashboard. In the Essentials version of Nessus, we have two tabs called *Scans* and *Settings*.

![[OffSec/OSCP/z. images/14fd8cce37f70fea1863a7ee89b10696_MD5.jpg]]

Figure 9: Exploring Nessus Settings

The *Settings* tab allows us to configure the application. For example, we can enter information for an [*SMTP server*](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol) to get scan results via email. The advanced menu allows us to configure global settings ranging from user interface, scan, and log behavior to security and performance-related options.

As shown in Figure 9, the *About* menu lists basic information for Nessus, our license, and how many hosts we have left. For further information on how we can customize and configure Nessus, we can consult the [Nessus documentation](https://docs.tenable.com/nessus/Content/Settings.htm).

Next, let's examine policies and templates, by clicking on the *Scan* tab, and then *Policies*. A policy is a set of predefined configuration options in the context of a Nessus scan. When we save a policy, we can use it as a template for a new scan.

Let's now click on *Scan Templates*. Nessus already provides a broad variety of [scanning templates](https://docs.tenable.com/nessus/Content/ScanAndPolicyTemplates.htm) for us to use. These templates are grouped into the three categories *Discovery*, *Vulnerabilities*, and *Compliance*.

![[OffSec/OSCP/z. images/00a71f0c4b00cb5df4debcc03e0da8f6_MD5.jpg]]

Figure 10: Nessus Policy Templates

The *Compliance* category is only available in the enterprise version as well as the *Mobile Device Scan* template. The only template in the *Discovery* category is *Host Discovery*, which can be used to create a list of live hosts and their open ports.

The *Vulnerabilities* category consists of templates for critical vulnerabilities or vulnerability groups e.g. [*PrintNightmare*](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34527) or [*Zerologon*](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2020-1472) as well as templates for common scanning areas e.g. *Web Application Tests* or *Malware Scans*.

Nessus also provides three general vulnerability scanning templates:

1. The *Basic Network Scan* performs a full scan with the majority of settings predefined. It will detect a broad variety of vulnerabilities and is therefore the recommended scanning template by Nessus. We also have the option to customize these settings and recommendations.
2. The *Advanced Scan* is a template without any predefined settings. We can use this when we want to fully customize our vulnerability scan or if we have specific needs.
3. The last general scanning template, *Advanced Dynamic Scan*, also comes without any predefined settings or recommendations.

The biggest difference between the two templates is that in the Advanced Dynamic Scan, we don't need to select plugins manually. The template allows us to configure a [*dynamic plugin filter*](https://docs.tenable.com/nessus/Content/DynamicPlugins.htm) instead.

Nessus Plugins are programs written in the [*Nessus Attack Scripting Language*](https://en.wikipedia.org/wiki/Nessus_Attack_Scripting_Language) (NASL) that contain the information and the algorithm to detect vulnerabilities. Each plugin is assigned to a [*plugin family*](https://www.tenable.com/plugins/families/about), which covers different use cases. We will work with the Advanced Dynamic Scan template and plugins in the last section of this Learning Unit.

#### Labs

1. What is the third group of template categories: DISCOVERY, COMPLIANCE and \_\_\_\_\_\_\_\_\_\_?

Answer

2. Go to the *Settings* tab in Nessus then click on the *Advanced* settings. Find how many concurrent web users are allowed with the default settings.

Answer

## 7.2.3. Performing a Vulnerability Scan

In this section, we will perform our first vulnerability scan. To begin, let's click on the *New Scan* button on the dashboard in the *Scans* tab.

![[OffSec/OSCP/z. images/cf5177253642932d333c7dddee8cbf29_MD5.jpg]]

Figure 11: Creating a Scan

Nessus provides a list of the different templates. For this section, we will use the *Basic Network Scan*, which we can launch by clicking on it.

![[OffSec/OSCP/z. images/f7621879eba25bfe44beebe4c1394def_MD5.jpg]]

Figure 12: Selecting a Basic Network Scan

This will present the scan [configuration settings](https://docs.tenable.com/nessus/Content/TemplateSettings.htm) screen containing the *BASIC*, *DISCOVERY*, *ASSESSMENT*, *REPORT*, and *ADVANCED* settings.

![[OffSec/OSCP/z. images/ea8848c1d969badf922391dd89584df2_MD5.jpg]]

Figure 13: Different Settings in Scan Configuration

The default screen is the *General* settings page with the two required arguments: a name for our scan and a list of targets. Nessus supports [multiple target specifications](https://docs.tenable.com/nessus/Content/ScanTargets.htm), including a single IP address, an IP range, and a comma-delimited *Fully-Qualified Domain Name* (FQDN), or an IP address list.

For this example, we will scan the following machines: POULTRY, JENKINS, WK01, and SAMBA. We will enter "Basic Vulnerability Scan" into the *Name* field and the IP addresses of the machines into the *Targets* field.

![[OffSec/OSCP/z. images/3055532bfe88b101e5b5d1b7e0733f03_MD5.jpg]]

Figure 14: Configuring Scan Name and Target List

Since we chose the Basic Network Scan template, Nessus has already configured most of the settings for us. However, the default configuration might not be exactly what we need. Depending on the scanning type, the environment, time constraints, and the targets, we may need to adapt the settings to fit our needs.

In the default settings of this template, Nessus scans a list of common ports. For this demonstration, we only want to scan ports 80 and 443. To do this, let's click on the *Discovery* settings and select *Custom* in the dropdown menu.

![[OffSec/OSCP/z. images/f3cec7e6cc175c4c234e9dbcae67f59b_MD5.jpg]]

Figure 15: Selecting Custom Discovery Settings

The dropdown menu shown in Figure 15 provides us with several predefined options. To scan specific ports, we'll need to select *Custom*.

After we click on *Custom*, additional configuration menus appear under the *DISCOVERY* menu. We can now customize the Basic Network Scan template in the same way as the Advanced Scan template in the context of the *DISCOVERY* menu. Within the *Port Scanning* section, we will set the *Port scan range* to "80,443". Additionally, we'll enable the option the *Consider unscanned ports as closed* so that Nessus treats other ports as closed\` since we are only interested in ports 80 and 443.

![[OffSec/OSCP/z. images/71112f257e96035d08a4a5fd226b2f02_MD5.jpg]]

Figure 16: Specifying Ports 80 and 443

In this demonstration, we've customized the Basic Network Scan template to only scan two specific TCP ports. But even in the default settings of this template, Nessus does not scan UDP ports. If we want to activate UDP port scanning, we need to manually configure it. We may miss crucial information on UDP services when it's disabled during assessments, but we need to understand that activating UDP port scanning will vastly increase the scan duration. Due to the nature of UDP, it is not often possible to tell the difference between an open and a filtered port.

To save time and scan the targets more quietly, we will turn off *Host Discovery* because we know the hosts are available. We do this by navigating to *Discovery* > *Host Discovery* where we toggle *Ping the remote host* to *Off*.

![[OffSec/OSCP/z. images/afd8390024ae0d0f5e1dc855dd2c0625_MD5.jpg]]

Figure 17: Disable Host Ping in Discovery Settings

During the configuration of the scan definition, we did not configure any credentials, which implies that this scan will run unauthenticated.

We also didn't change the default settings of the *ASSESSMENT* menu in the Basic Network Scan template. This means the brute forcing of user credentials will not be done. Even though brute forcing is disabled, our scan creates a lot of network traffic and because we're scanning multiple hosts, will be highly noticeable.

Now that we have a basic understanding of how we can customize templates to fit our needs, we can launch our first scan. We can do this by clicking on the arrow next to *Save* and selecting *Launch*.

![[OffSec/OSCP/z. images/e83912eaceec6abea3261e83dfa6bb9a_MD5.jpg]]

Figure 18: Launching the Scan

Initially, the scan will have a status of *Running* in the Nessus dashboard under *My Scans*.

![[OffSec/OSCP/z. images/090a816119dc0b792ca85ac27a8f7bc5_MD5.jpg]]

Figure 19: Running Scan in the Nessus Dashboard

Figure 19 shows the running scan and provides the options to stop or pause it. Once the scan is finished, the status will change to *Completed*.

![[OffSec/OSCP/z. images/c9c50a144fa56eb84f64f038f103b0d5_MD5.jpg]]

Figure 20: Completed Scan in the Nessus Dashboard

This concludes our first vulnerability scan with Nessus. In the next Learning Unit, we'll examine the results of the scan.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Vulnerability Scanning - Performing a Vulnerability Scan - VM Group 1

#### Labs

1. Follow the steps above to create your own unauthenticated vulnerability scan on ports 80 and 443 on the machines from VM Group
2. Review the *REPORT* menu of the scan configuration, which is shown in Figure 13 and check what is the only enabled option in the *Output* section. Enter the name of the activated checkbox.

Answer

## 7.2.4. Analyzing the Results

In this section, we will analyze the results of our first vulnerability scan.

Warning

The VM group required for this section is different than the previous VM group. Please make sure to start and use the VM group at the bottom of this section.

Due to the continuous updates of Nessus and its plugins, the scan results can differ slightly. We can click on the scan in the *My Scans* list to get to the results dashboard.

![[OffSec/OSCP/z. images/fc7fc338df92180be967c63d0620a5bf_MD5.jpg]]

Figure 21: Result Dashboard

The initial view displays the *Hosts* page, which lists all scanned hosts and provides a visual representation of the vulnerability data. This allows us to identify important findings in one glance and gives us an overview of the security status of each system. On the bottom right, Nessus displays a visual representation of the distribution of all targets' vulnerability information. Above it, we can find general information about the vulnerability scan.

Nessus plugins are frequently updated. Therefore, the findings, groupings, and information presented in this Learning Unit may differ slightly from the results of your vulnerability scans.

To get the list of findings from a specific host, we can click on a list entry. This shows us the list of vulnerabilities from the selected host. Let's click on the entry for *192.168.50.124*.

![[OffSec/OSCP/z. images/71959fe32ca4b0ff7b5fcc351bd4c1f4_MD5.jpg]]

Figure 22: Vulnerability Result Dashboard of 192.168.50.124

The *Severity* column gives us a quick indicator if this is a critical finding or not. Figure 22 also shows us that there are three findings with the *MIXED* severity. Nessus uses this severity when it groups findings. The *Count* column shows us how many findings the corresponding group contains. We can click on a grouped finding to display a list of all findings in this group. Let's click on *Apache Httpd (Multiple Issues)*, which is listed as *Web Servers* under the *Family* column.

![[OffSec/OSCP/z. images/3da78ecaf6b2c2fd25828afd33179ff6_MD5.jpg]]

Figure 23: List of Grouped Findings

Figure 23 shows us information on the findings, which were previously grouped. We can get more information by clicking on a finding. Let's click on *Apache 2.4.49 < 2.4.51 Path Traversal Vulnerability*.

![[OffSec/OSCP/z. images/c12b12fc1313b85dac52ac85b3e08e3c_MD5.jpg]]

Figure 24: Detailed Information of a Finding

Each finding contains a huge amount of information about the vulnerability itself, as well as the plugin that detected it. Furthermore, we get a lot of information about the associated risk, status of exploits, and other references.

Next, let's navigate back to the results dashboard shown in Figure 21 to explore our scan further.

Analyzing the findings of a single target provides us with a lot of detailed information. However, we often want to get an overview of the most important vulnerabilities of all targets. To achieve this, Nessus provides a handy feature to get a prioritized overview of vulnerabilities named *VPR Top Threats*, which utilizes the [*Vulnerability Priority Rating*](https://www.tenable.com/blog/what-is-vpr-and-how-is-it-different-from-cvss) (VPR). The findings in the VPR list consist of the top ten vulnerabilities of the scan.

![[OffSec/OSCP/z. images/1fe88a0129529e486c6b7d7fa6a6b972_MD5.jpg]]

Figure 25: VPR List of Vulnerabilities

In our example, the list only contains six vulnerabilities as Nessus didn't find more with our configuration.

Depending on the version of Nessus, the tab *VPR Top Threats* may be missing while following along. However, each vulnerability finding still contains the Vulnerability Priority Rating.

The next page we'll examine is *Remediations*. If Nessus detects a vulnerability, the plugins often contain a remediation strategy or information on how to mitigate the vulnerability. In the case of the Apache vulnerabilities from Figure 22, we get the following information.

![[OffSec/OSCP/z. images/3ae025632a7c14f85078d2da72cb8fd3_MD5.jpg]]

Figure 26: Remediation of Vulnerabilities

The last report page is *History*. This page lists all vulnerability scans with this configuration. We can use it to review or compare the results of previous scans.

We now understand how to view the results of a Nessus scan. Next, let's create a PDF report of our vulnerability scan. We can do this by using the functions in the *Report* dashboard. Apart from the creation of a report, the functions also cover the change of the scan configuration, the launch of another scan, or exporting data. We can also configure an [*Audit Trail*](https://community.tenable.com/s/article/Analyzing-the-Audit-Trail), which allows us to analyze why a specific plugin behaved in a certain way. It can be used to reduce the number of false negatives.

Let's create a PDF report for our first vulnerability scan by clicking *Report*.

![[OffSec/OSCP/z. images/9f4fce93587fa10e102e82f024ab99ec_MD5.jpg]]

Figure 27: Create a Report

Once we click on the button, a new window allows us to use different report templates. Each template generates a report with a different structure, focus, and content.

For this example, we'll use the *Detailed Vulnerabilities By Host* template, which presents detailed findings grouped by each host. We'll then select *PDF* as the format and click *Generate Report*.

![[OffSec/OSCP/z. images/6aa940a66658bacfd55efcdc3f67a740_MD5.jpg]]

Figure 28: Select the Report Format and Template

After this, we can download or open the PDF report.

We could also use the *Complete List of Vulnerabilities by Host* template to create a summary of the vulnerabilities instead of including detailed information.

For more information on how to customize the reports, consult the scan exports and reports section on the [*Tenable Documentation*](https://docs.tenable.com/nessus/Content/ScanReportFormats.htm) page.

In the last two sections, we performed a vulnerability scan, reviewed the results, and generated a PDF report with detailed information for all hosts. We can get more familiar with Nessus by customizing the scan configurations and analyzing how the scanning behavior and results differ.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Vulnerability Scanning - Analyzing the Results - VM Group 1

Vulnerability Scanning - Performing a Vulnerability Scan - VM #5

#### Labs

1. In the section "Performing a Vulnerability scan" we launched a vulnerability scan on four target machines. Follow the steps outlined in this section to review the results of this scan and analyze the *Apache 2.4.49 < 2.4.51 Path Traversal Vulnerability* finding. The finding contains a field named *Exploit Code Maturity*. Enter the value of this field as an answer to this exercise.

Answer

2. Perform an unauthenticated vulnerability scan on the same four machines (VM Group 1) as in the previous exercise, but only scan port 8080. Once the scan finishes, review the scan results and identify a host with the grouped finding *HTTP (Multiple Issues)*. Find *HTTP Server Type and Version* and enter the *Jetty* version found.

Answer

3. Nessus can build a *Sitemap* of a target web server. A Sitemap provides information about the content of a web server (e.g. pages). Nessus builds it by crawling through links it identifies on pages. Scan the four target machines ( VM Group 1) on port 9999 with the *Basic Network Scan* template. To configure Nessus to build a Sitemap, click on the *Assessment* settings in the scan configuration and select *Custom* in the dropdown menu. Next, click on *Web Applications* and activate *Scan web applications*. After this, launch the scan. Once it is finished, review the results and analyze the findings on the *Web Application Sitemap* . The output provides a list of found pages. On one of these pages, you will find the flag.

Answer

4. The victim machine VM #5 is running a server that contains several vulnerabilities. One vulnerability allows for directory traversal and arbitrary file access on the target system. Use Nessus to perform a *Basic Network Scan* of the victim. Make sure to configure the scan to assess *all ports*. Once the scan is completed, examine the discovered vulnerability in the results. As a part of the scan, Nessus was able to read the file *C:\\Windows\\win.ini* as a proof of concept of this exploit. Expand the vulnerability results to view the full content of the retrieved file and locate the embedded flag.

Answer

## 7.2.5. Performing an Authenticated Vulnerability Scan

In this section, we will perform an authenticated vulnerability scan by providing credentials to Nessus. As we discussed previously, authenticated scans produce more detailed information and reduce the number of false positives. To demonstrate this, we will use an authenticated vulnerability scan against the target *DESKTOP*.

We need to consider that an authenticated scan not only creates a lot of traffic on the network but also a huge amount of noise on the system itself, such as log entries and AV notifications.

To begin, we'll click *New Scan* on the Nessus dashboard.

![[OffSec/OSCP/z. images/cf5177253642932d333c7dddee8cbf29_MD5.jpg]]

Figure 29: Creating a new Scan

Even though all Nessus templates accept user credentials, we'll use the *Credentialed Patch Audit* scan template, which comes preconfigured to execute local security checks against the target.

The difference between this and the Basic Network Scan template with provided credentials is that the Credentialed Patch Audit scan only uses local security checks and will not do a regular vulnerability check from an external perspective. The Credentialed Patch Audit template will not only scan for missing operating system patches but also for outdated applications, which may be vulnerable to [*privilege escalation attacks*](https://en.wikipedia.org/wiki/Privilege_escalation).

![[OffSec/OSCP/z. images/b2842a0f937cea9477850f3d60356732_MD5.jpg]]

Figure 30: Select Credentialed Patch Audit

Once again, we will provide a name for the scan and set the target to DESKTOP.

![[OffSec/OSCP/z. images/9666e74306c9d422918d28c0c91670b4_MD5.jpg]]

Figure 31: Basic Settings for the Authenticated Scan

Next, let's click on the *Credentials* tab and select [*SSH*](https://en.wikipedia.org/wiki/Secure_Shell) in the *Host* category. On the *Authentication method* dropdown, we'll select *password* and enter "offsec" as the username and "lab" as the password. We'll select *sudo* for the *Elevate privileges with* option and enter "root" as the sudo user and "lab" as the password.

![[OffSec/OSCP/z. images/f16ef12066d231e917bf40e481b11f08_MD5.jpg]]

Figure 32: SSH and Sudo Credentials for the Authenticated Scan

While we will use the SSH configuration for this example, there are several other authentication mechanisms available. To get a list of all available mechanisms, we can click the *Categories* dropdown menu and select *All*. We can consult the [*Tenable Documentation*](https://docs.tenable.com/nessus/Content/Credentials.htm) for a complete list of supported authentication mechanisms.

For Linux and macOS targets, SSH is used. While we can also use SSH on Windows, in most cases, we will use [*Server Message Block*](https://en.wikipedia.org/wiki/Server_Message_Block) (SMB) and [*Windows Management Instrumentation*](https://en.wikipedia.org/wiki/Windows_Management_Instrumentation) (WMI) to perform authenticated vulnerability scans against Windows targets. Both methods allow us to use local or domain accounts and different authentication options.

To get meaningful results in an authenticated vulnerability scan, we need to ensure that our target system is configured correctly. Depending on the authentication method we want to use, we need to make sure that there is no firewall blocking connections from our scanner. Furthermore, we often find *antivirus* (AV) programs installed on both Linux and Windows targets. AV may flag the vulnerability scan as malicious and therefore, terminate our connection or render the results useless. Depending on the AV program, we can add an [*exception*](https://community.tenable.com/s/article/Symantec-Endpoint-Protection-interfering-with-Nessus-authenticated-scans) for the authenticated scan or temporarily disable it.

Another Windows security technology we need to consider is [*User Account Control*](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC). UAC is a security feature for Windows that allows users to use standard privileges instead of administrator privileges. An administrative user will run most applications and commands with standard privileges and receive administrator privileges only when needed.

Due to the nature of UAC, it can also interfere with our scan. [We can configure UAC to allow Nessus or temporarily disable it](https://docs.tenable.com/nessus/Content/EnableWindowsLoginsForLocalAndRemoteAudits.htm). We should consult the [*Tenable Documentation*](https://docs.tenable.com/nessus/Content/CredentialedChecksOnWindows.htm), especially for Windows targets before we start our first authenticated scan.

Our scan target is a Linux system without AV. Therefore, we can click the arrow next to *Save* and launch the scan. After the scan has finished, we can review the results. On the *Vulnerabilities* page, we get a list of the findings for the authenticated scan. In the last section, we had already grouped findings with the *MIXED* severity. For our authenticated scan, let's disable the grouping of findings by clicking on the wheel and selecting *Disable Groups*.

![[OffSec/OSCP/z. images/6b684f88967135680db3fadcbbdfeddb_MD5.jpg]]

Figure 33: Disable Grouped Results

After we disable groups, each finding is listed separately.

![[OffSec/OSCP/z. images/2f632fc5a552cf394fa1500100de1b43_MD5.jpg]]

Figure 34: Authenticated Scan Results

We get a list of vulnerabilities from Ubuntu where they have a [*Ubuntu Local SecurityChecks*](https://www.tenable.com/plugins/nessus/families/Ubuntu%20Local%20Security%20Checks) and in that, there is a [*plugin family*](https://www.tenable.com/plugins/nessus/families).

Plugins grouped into plugin families check for vulnerabilities in the same context. For example, there are separate plugin families for checking vulnerabilities in databases, firewalls, or web servers. The Ubuntu Local Security Checks plugin family contains a multitude of plugins that check for local vulnerabilities and missing patches for Ubuntu.

The *Name* column provides us with the vulnerable Ubuntu versions and a brief description as well as the patch number for the vulnerabilities.

![[OffSec/OSCP/z. images/1aee512c00464771a0ec68836d950ff7_MD5.jpg]]

Figure 35: Vulnerability data of Firefox and curl

The list also contains vulnerability data of locally exposed applications such as [*Firefox*](https://www.mozilla.org/en-US/firefox/new/) or [*cURL*](https://en.wikipedia.org/wiki/CURL).

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Vulnerability Scanning - Authenticated Scan - VM #1

#### Labs

1. Follow the steps above to perform an authenticated vulnerability scan on VM #1. Review the results of the scan and analyze the "Patch Report" finding. The report identifies missing patches, with one listed as Critical, specifically related to the *Heimdal* package. Can you provide the corresponding *Ubuntu Security Notice* (USN) number?

Answer

2. Additionally, analyze the "OS Identification and Installed Software Enumeration over SSH v2 (Using New SSH Library)" finding. The finding includes the output of the **uname -a** command. What is the kernel version of the *DESKTOP* system?

Answer

## 7.2.6. Working with Nessus Plugins

By default, Nessus will enable several plugins behind the scenes when running a default template. While this is certainly useful in many scenarios, we can also fine-tune our options to quickly run a single plugin. We can use this feature to validate a previous finding or to quickly discover all the targets in an environment that are at risk of a specific vulnerability.

For this example, we will set a plugin filter to identify if the *DESKTOP* machine is vulnerable to [*CVE-2021-3156*](https://www.tenable.com/cve/CVE-2021-3156). This is a locally exploitable vulnerability that allows an unprivileged user to elevate privileges to root.

To leverage the dynamic plugin filter, we will once again begin with a *New Scan*.

![[OffSec/OSCP/z. images/cf5177253642932d333c7dddee8cbf29_MD5.jpg]]

Figure 36: Creating a new Scan

This time, we will use the Advanced Dynamic Scan template. This template allows us to use a dynamic plugin filter instead of manually enabling or disabling plugins.

To use this template, we click on *Advanced Dynamic Scan*.

![[OffSec/OSCP/z. images/08e0a333627cdd656b24c192124acdef_MD5.jpg]]

Figure 37: Select Advanced Dynamic Scan

Once again, we'll configure the name and target.

![[OffSec/OSCP/z. images/24f5b93bb4167baae2b0fd52552cbe03_MD5.jpg]]

Figure 38: Enter Name and Target

Next, we'll provide the same SSH and sudo credentials we used in the last example, meaning we'll also be conducting an authenticated scan.

Now we can select the plugins we want to use in our vulnerability scan. As stated before, the Advanced Dynamic Scan allows us to use a filter instead of enabling or disabling groups or individual plugins.

To do so, let's click on the *Dynamic Plugins* tab. In the left dropdown menu, we'll select *CVE* to filter for a specific CVE. In the middle dropdown menu, we can choose from different filter arguments to specify the matching behavior. On the right dropdown menu, we can specify a CVE number. After entering "CVE-2021-3156", we can click on *Preview Plugins*. This may take a few minutes to complete.

![[OffSec/OSCP/z. images/540ff0b12a4b55ce074438073549e768_MD5.jpg]]

Figure 39: Filter for specific Plugins

Once *Preview Plugins* is finished running, we get a list of found plugin families that cover this CVE.

![[OffSec/OSCP/z. images/280c03fc11793f77846a9a3a0da85c13_MD5.jpg]]

Figure 40: Select Family of Plugins covering CVE-2021-3156

One very handy feature of the dynamic plugin filter is the ability to combine multiple filters. In this example, we know that the target is an Ubuntu Linux system, and we can therefore use a second filter to specify the related plugin family. Let's add a new filter by clicking on the *plus* button next to the first filter.

![[OffSec/OSCP/z. images/3baebea03cdfb232e3c1d3a5daf05675_MD5.jpg]]

Figure 41: Add Filter

A new plugin filter appears. To restrict the plugin family to specific checks for Ubuntu, let's select *Plugin Family* on the left dropdown and *Ubuntu Local Security Checks* on the right dropdown.

![[OffSec/OSCP/z. images/0469f17d579090c1de716bf82897e079_MD5.jpg]]

Figure 42: Combined Plugin Filters

Depending on the version of Nessus, the dropdown menu on the right may not display any values. In this case, we can remove the second plugin filter and proceed without it.

We can then click on *Preview Plugins* again to list the plugins determined by our filters. After it completes, let's click on the dropdown and choose *Ubuntu Local Security Checks*. Nessus displays information about the plugin, including affected Ubuntu versions, a short description, and patch number, as well as the Plugin ID.

![[OffSec/OSCP/z. images/5fea76d451fbac5e8210ae0816c6e210_MD5.jpg]]

Figure 43: Ubuntu Local Security Check Plugin for CVE-2021-3156

We can get more information by clicking on the plugin. Figure 44 shows the detailed information of the specified plugin.

![[OffSec/OSCP/z. images/d06d7794cb809463c4239bd5d8573726_MD5.jpg]]

Figure 44: Detailed Information of Plugin 145463

After closing this window, we can launch the vulnerability scan as we did before.

Once the scan is finished, let's review the results by clicking on the *Vulnerabilities* tab.

![[OffSec/OSCP/z. images/f1ffe809899740de3556061203d8a56b_MD5.jpg]]

Figure 45: Listed Findings of the Advanced Dynamic Scan

The output lists one finding with a *HIGH* severity, which was found by the plugin we specified with our dynamic plugin filter. Figure 46 shows the detailed information of the finding, confirming that the target is vulnerable to CVE-2021-3156.

![[OffSec/OSCP/z. images/381d7b9acace6818719886ea997be6ba_MD5.jpg]]

Figure 46: Detailed Information about the Findings of the specified Plugins

The plugin output also contains information stating that Nessus only used the reported version number of the affected application and that it did not try to confirm the vulnerability by exploiting it in any way. In an assessment, we should verify these kinds of results to check if it is indeed an exploitable vulnerability.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Vulnerability Scanning - Working with Nessus Plugins - VM #1

Vulnerability Scanning - Working with Nessus Plugins - VM #2

#### Labs

1. Follow the steps above to perform the vulnerability scan on VM #1 with the specified plugin filter. Click on the vulnerability provided by the plugin on the *Vulnerabilities* result page and enter the date when a patch for this vulnerability was published. The information can be found in the *Vulnerability Information* area under the *Patch Pub Date* on the right sidebar.

Answer

2. The target machine VM #2 is running an IIS web server. Perform an *Advanced Dynamic Scan* on this system with the default settings of this template and specify the Plugin ID *11714* in a Plugin Filter. Once the scan completes, examine the discovered information and locate the flag embedded in the disclosed path. Keep in mind, that Nessus shows some special characters like "{" or "}" as *Unicode Hex characters*. To provide the correct flag, you will need to substitute these characters.

Answer

## 7.3. Vulnerability Scanning with Nmap

This Learning Unit covers the following Learning Objectives:

- Understand the basics of the Nmap Scripting Engine (NSE)
- Perform a lightweight Vulnerability Scan with Nmap
- Work with custom NSE scripts

In this Learning Unit, we will explore the *Nmap Scripting Engine* (NSE) and how to leverage Nmap as a lightweight vulnerability scanner. In addition, we will learn about the NSE script categories, how to use NSE scripts in Nmap, and how to work with custom NSE scripts.

## 7.3.1. NSE Vulnerability Scripts

As an alternative to Nessus, we can also use the [NSE](https://nmap.org/book/man-nse.html) to perform automated vulnerability scans. NSE scripts extend the basic functionality of Nmap to do a variety of networking tasks. These tasks are grouped into categories around cases such as vulnerability detection, brute forcing, and network discovery. The scripts can also extend the version detection and information-gathering capabilities of Nmap.

An NSE script can have more than one category. For example, it can be categorized as *safe* and *vuln*, or *intrusive* and *vuln*. Scripts categorized as "safe" have no potential impact to stability, while scripts in the "intrusive" category might crash a target service or system. To avoid any stability issues, it's imperative to check how the scripts are categorized, and we should never run an NSE script or category without understanding the implications. We can determine the categories of a script by browsing the [*NSE Documentation*](https://nmap.org/nsedoc) or locally in the NSE scripts directory.

In this section, we will focus on the *vuln* category to leverage Nmap as a lightweight vulnerability scanner.

On our Kali VM, the NSE scripts can be found in the **/usr/share/nmap/scripts/** directory with the **.nse** filetype. This directory also contains the **script.db** file, which serves as an index to all currently available NSE scripts. We can use it to get a list of scripts in the *vuln* category.

```
kali@kali:~$ cd /usr/share/nmap/scripts/

kali@kali:/usr/share/nmap/scripts$ cat script.db  | grep "\"vuln\""
Entry { filename = "afp-path-vuln.nse", categories = { "exploit", "intrusive", "vuln", } }
Entry { filename = "broadcast-avahi-dos.nse", categories = { "broadcast", "dos", "intrusive", "vuln", } }
Entry { filename = "clamav-exec.nse", categories = { "exploit", "vuln", } }
Entry { filename = "distcc-cve2004-2687.nse", categories = { "exploit", "intrusive", "vuln", } }
Entry { filename = "dns-update.nse", categories = { "intrusive", "vuln", } }
...
```

> Listing 4 - The Nmap script database

Each entry has a file name and categories. The file name represents the name of the NSE script in the NSE directory.

Some of the standard NSE scripts are quite outdated. Fortunately, the [*vulners*](https://nmap.org/nsedoc/scripts/vulners.html) script was integrated, which provides current vulnerability information about detected service versions from the [*Vulners Vulnerability Database*](https://vulners.com/). The script itself has the categories *safe*, *vuln*, and *external*.

Before we start our first vulnerability scan with the NSE, we will examine the Nmap *\--script* parameter. This parameter is responsible for determining which NSE scripts get executed in a scan. The arguments for this parameter can be a category, a Boolean expression, a comma-separated list of categories, the full or wildcard-specified name of a NSE script in **script.db**, or an absolute path to a specific script.

Let's start with a Nmap scan using all of the NSE scripts from the *vuln* category. The command we'll use contains the previously mentioned **\--script** parameter with the **vuln** argument, which specifies all the scripts with this category. Furthermore, we'll provide **\-sV** to activate the Nmap's service detection capabilities. Finally, we'll use **\-p** to only scan port 443.

```
kali@kali:~$ sudo nmap -sV -p 443 --script "vuln" 192.168.50.124
[sudo] password for kali: 
Starting Nmap 7.92 ( https://nmap.org )
...
PORT    STATE SERVICE VERSION
443/tcp open  http    Apache httpd 2.4.49 ((Unix))
...
| vulners: 
|   cpe:/a:apache:http_server:2.4.49:
...
        https://vulners.com/githubexploit/DF57E8F1-FE21-5EB9-8FC7-5F2EA267B09D	*EXPLOIT*
|     	CVE-2021-41773	4.3	https://vulners.com/cve/CVE-2021-41773
...
|_http-server-header: Apache/2.4.49 (Unix)
MAC Address: 00:0C:29:C7:81:EA (VMware)
```

> Listing 5 - Using NSE's "vuln" category scripts against the SAMBA machine

Nmap detected the *Apache* service with version 2.4.49 and tried all the NSE scripts from the *vuln* category. Most of the output comes from the vulners script, which uses the information from the detected service and version to provide related vulnerability data.

The vulners script not only shows us information about the CVEs found but also the CVSS scores and links for additional information. For example, Listing 5 shows that Nmap, in combination with the vulners script, detected that the target is vulnerable to [*CVE-2021-41773*](https://nvd.nist.gov/vuln/detail/CVE-2021-41773).

Another useful feature of the vulners script is that it also lists *Proof of Concepts* for the found vulnerabilities, which are marked with "\*EXPLOIT\*". However, without a successful service detection, the vulners script will not provide any results.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Vulnerability Scanning - NSE Vulnerability Scripts - VM #1

#### Labs

1. Follow the steps above and use the *vuln* NSE script category against VM #1. Listing 5 shows that the target is vulnerable to CVE-2021-41773, but the redacted output omits multiple additional found CVEs. Enter one of the other found CVEs from 2021.

Answer

## 7.3.2. Working with NSE Scripts

In the previous section, we learned about the vuln NSE category and the vulners script. While the vulners script provides an overview of all CVEs mapped to the detected version, we sometimes want to check for a specific CVE. This is especially helpful when we want to scan a network for the existence of a vulnerability. If we do this with the vulners script, we will need to review an enormous amount of information. For most modern vulnerabilities, we need to integrate dedicated NSE scripts manually.

Let's practice how to do this with CVE-2021-41773. To find a suitable NSE script, we can use a search engine to find the CVE number plus NSE (**CVE-2021-41773 nse**).

![[OffSec/OSCP/z. images/afe0a120cac0c3c1ce9cd59aa9d0bcca_MD5.jpg]]

Figure 47: Searching for an NSE script for a specific CVE in Google

One of the first search results is a link to a [*GitHub*](https://github.com/RootUp/PersonalStuff/blob/master/http-vuln-cve-2021-41773.nse) page that provides a script to check for this vulnerability. Let's download this script and save it as **/usr/share/nmap/scripts/http-vuln-cve2021-41773.nse** to comply with the naming syntax of the other NSE scripts. Before we can use the script, we'll need to update **script.db** with **\--script-updatedb**.

```
kali@kali:~$ sudo cp /home/kali/Downloads/http-vuln-cve-2021-41773.nse /usr/share/nmap/scripts/http-vuln-cve2021-41773.nse

kali@kali:~$ sudo nmap --script-updatedb
[sudo] password for kali: 
Starting Nmap 7.92 ( https://nmap.org )
NSE: Updating rule database.
NSE: Script Database updated successfully.
Nmap done: 0 IP addresses (0 hosts up) scanned in 0.54 seconds
```

> Listing 6 - Copy the NSE Script and update the script.db database

To use the NSE script, we'll provide the name of the script, target information, and port number. We'll also enable service detection.

```
kali@kali:~$ sudo nmap -sV -p 443 --script "http-vuln-cve2021-41773" 192.168.50.124
Starting Nmap 7.92 ( https://nmap.org )
Host is up (0.00069s latency).

PORT    STATE SERVICE VERSION
443/tcp open  http    Apache httpd 2.4.49 ((Unix))
| http-vuln-cve2021-41773:
|   VULNERABLE:
|   Path traversal and file disclosure vulnerability in Apache HTTP Server 2.4.49
|     State: VULNERABLE
|               A flaw was found in a change made to path normalization in Apache HTTP Server 2.4.49. An attacker could use a path traversal attack to map URLs to files outside the expected document root. If files outside of the document root are not protected by "require all denied" these requests can succeed. Additionally this flaw could leak the source of interpreted files like CGI scripts. This issue is known to be exploited in the wild. This issue only affects Apache 2.4.49 and not earlier versions.
|           
|     Disclosure date: 2021-10-05
|     Check results:
|       
|         Verify arbitrary file read: https://192.168.50.124:443/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd
...
Nmap done: 1 IP address (1 host up) scanned in 6.86 seconds
```

> Listing 7 - CVE-2021-41773 NSE Script

The output indicates that the target is vulnerable to CVE-2021-41773 and provides us with additional background information.

While Nmap is not a vulnerability scanner in the traditional sense, we found that the NSE is a powerful feature that allows us to do lightweight vulnerability scanning. In a penetration test, we can use Nmap when there isn't a full-fledged vulnerability scanner available or when we want to verify findings from other tools.

However, we have the same factors to consider as with any other vulnerability scanner. The NSE script categories can provide useful information, such as if a script is intrusive or safe, but we also need to keep in mind that an NSE script may contain malicious code that gives an attacker full access to our system. For that reason, we always need to verify that the NSE script not only provides the needed functionality but is also safe.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Vulnerability Scanning - Working with NSE Scripts - VM #1

#### Labs

1. **Capstone Labs**: Follow the steps above to perform the vulnerability scan with the custom NSE script on VM #1. Copy the link from the script output after *Verify arbitrary file read:* and use it as a parameter for curl. This will retrieve the content of **/etc/passwd** of the target machine and display it. Be aware that you need to use *http* instead of *https* while keeping port 443 when you paste the link. Embed the last username of the file in the braces of "OS{}" and provide it as the answer to this exercise.

Answer

## 7.4. Wrapping Up

This Module has provided an overview of vulnerability scanning with Nessus and Nmap, and it provided insight into the different types and considerations of a vulnerability scan.

Vulnerability scanning can be extremely helpful during any kind of security assessment. Configured correctly, vulnerability scanning tools provide a wealth of meaningful data. It is important to understand that a manual review of the results is still required and that scanners can only discover vulnerabilities that they are configured for. Finally, we should always keep in mind that vulnerability scanning tools can perform actions that could be detrimental to some networks or targets, so we must exercise caution when using them.