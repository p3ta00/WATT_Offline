# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer

# 8\. Introduction to Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Web Application Assessment Methodology
-   Web Application Enumeration
-   Cross-Site Scripting

In this Module, we'll begin introducing web application attacks. Modern development frameworks and hosting solutions have simplified the process of building and deploying web-based applications. However, these applications usually expose a large attack surface due to multiple dependencies, insecure server configurations, a lack of mature application code, and business-specific application flaws.

Web applications are written using a variety of programming languages and frameworks, each of which can introduce specific types of vulnerabilities. Since the most common vulnerabilities are alike in concept and the various frameworks behave similarly regardless of the underlying technology stack, we'll be able to follow similar exploitation avenues.

## 8.1. Web Application Assessment Methodology

This Learning Unit covers the following Learning Objectives:

-   Understand web application security testing requirements
-   Learn different types and methodologies of web application testing
-   Learn about the OWASP Top10 and most common web vulnerabilities

Before we begin discussing enumeration and exploitation, let's examine the different web application penetration testing methodologies.

As a penetration tester, we can assess a web application using three different methods, depending on the kind of information we have been provided, the scope, and the engagement rules.

_White-box_ testing describes scenarios in which we have unconstrained access to the application's source code, the infrastructure it resides on, and its design documentation. Because this type of testing gives us a more comprehensive view of the application, it requires a specific skill set to find vulnerabilities in source code. The skills required for white-box testing include source code and application logic review, among others. This testing methodology might take a longer time, relative to the size of the code base being reviewed.

Alternatively, _black-box_ testing (also known as a _zero-knowledge_ test) provides no information about the target application, meaning it's essential for the tester to invest significant resources into the enumeration stage. This is the approach taken during most bug bounty engagements.

Grey-box testing occurs whenever we are provided with limited information on the target's scope, including authentication methods, credentials, or details about the framework.

In this Module, we are going to focus on black-box testing to help develop the web application skills we are learning in this course.

In this and the following Modules, we will explore web application vulnerability enumeration and exploitation. Although the complexity of vulnerabilities and attacks varies, we'll demonstrate exploiting several common web application vulnerabilities in the [OWASP Top 10 list](https://owasp.org/www-project-top-ten/).

The OWASP Foundation aims to improve global software security and, as part of this goal, they develop the OWASP Top 10, a periodically compiled list of the most critical security risks to web applications.

Understanding these attack vectors will serve as the basic building blocks to construct more advanced attacks, as we'll learn in other Modules.

## 8.2. Web Application Assessment Tools

This Learning Unit covers the following Learning Objectives:

-   Perform common enumeration techniques on web applications
-   Understand Web Proxies theory
-   Learn how Burp Suite proxy works for web application testing

Before going into the details of web application enumeration, let's familiarize ourselves with the tools of the trade. In this Learning Unit, we are going to revisit Nmap for web services enumeration, along with Wappalyzer, an online service that discloses the technology stack behind an application, and Gobuster, a tool for performing file and web directory discovery. Lastly, we are going to focus on the Burp Suite proxy, which we'll rely on heavily for web application testing during this and upcoming Modules.

## 8.2.1. Fingerprinting Web Servers with Nmap

As covered in a previous Module, Nmap is the go-to tool for initial active enumeration. We should start web application enumeration from its core component, the web server, since this is the common denominator of any web application that exposes its services.

Since we found port 80 open on our target, we can proceed with service discovery. To get started, we'll rely on the **nmap** service scan (**\-sV**) to grab the web server (**\-p80**) banner.

```
kali@kali:~$ sudo nmap -p80  -sV 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 05:13 EDT
Nmap scan report for 192.168.50.20
Host is up (0.11s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu))
```

> Listing 1 - Running Nmap scan to discover web server version

Our scan shows that Apache version 2.4.41 is running on the Ubuntu host.

To take our enumeration further, we use service-specific Nmap NSE scripts, like _http-enum_, which performs an initial fingerprinting of the web server.

```
kali@kali:~$ sudo nmap -p80 --script=http-enum 192.168.50.20
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-29 06:30 EDT
Nmap scan report for 192.168.50.20
Host is up (0.10s latency).

PORT   STATE SERVICE
80/tcp open  http
| http-enum:
|   /login.php: Possible admin folder
|   /db/: BlogWorx Database
|   /css/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /db/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /images/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|   /js/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'
|_  /uploads/: Potentially interesting directory w/ listing on 'apache/2.4.41 (ubuntu)'

Nmap done: 1 IP address (1 host up) scanned in 16.82 seconds
```

> Listing 2 - Running Nmap NSE http enumeration script against the target

As shown above, we discovered several interesting folders that could lead to further details about the target web application.

By using Nmap scripts, we managed to discover more application-specific information that we can add to the web server enumeration we performed earlier.

## 8.2.2. Technology Stack Identification with Wappalyzer

Along with the active information gathering we performed via Nmap, we can also passively fetch a wealth of information about the application technology stack via [_Wappalyzer_](https://www.wappalyzer.com/).

Once we have registered a free account, we can perform a Technology Lookup on the **megacorpone.com** domain.

![Figure 1: Wappalyzer findings](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/653326571abee5e23695f56cf2e90f0d-wappalyzer.png)

Figure 1: Wappalyzer findings

From this quick third-party external analysis, we learned about the OS, the UI framework, the web server, and more. The findings also provide information about JavaScript libraries used by the web application - this can be valuable data, as some versions of JavaScript libraries are known to be affected by several vulnerabilities.

## 8.2.3. Directory Brute Force with Gobuster

Once we have discovered an application running on a web server, our next step is to map all its publicly accessible files and directories. To do this, we would need to perform multiple queries against the target to discover any hidden paths. [Gobuster](https://www.kali.org/tools/gobuster/) is a tool (written in Go language) that can help us with this sort of enumeration. It uses wordlists to discover directories and files on a server through brute forcing.

Due to its brute forcing nature, Gobuster can generate quite a lot of traffic, meaning it will not be helpful when staying under the radar is necessary.

Gobuster supports different enumeration modes, including fuzzing and dns, but for now, we'll only rely on the **dir** mode, which enumerates files and directories. We need to specify the target IP using the **\-u** parameter and a wordlist with **\-w**. The default running threads are 10; we can reduce the amount of traffic by setting a lower number via the **\-t** parameter.

```
kali@kali:~$ gobuster dir -u 192.168.50.20 -w /usr/share/wordlists/dirb/common.txt -t 5
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.50.20
[+] Method:                  GET
[+] Threads:                 5
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2022/03/30 05:16:21 Starting gobuster in directory enumeration mode
===============================================================
/.hta                 (Status: 403) [Size: 278]
/.htaccess            (Status: 403) [Size: 278]
/.htpasswd            (Status: 403) [Size: 278]
/css                  (Status: 301) [Size: 312] [--> http://192.168.50.20/css/]
/db                   (Status: 301) [Size: 311] [--> http://192.168.50.20/db/]
/images               (Status: 301) [Size: 315] [--> http://192.168.50.20/images/]
/index.php            (Status: 302) [Size: 0] [--> ./login.php]
/js                   (Status: 301) [Size: 311] [--> http://192.168.50.20/js/]
/server-status        (Status: 403) [Size: 278]
/uploads              (Status: 301) [Size: 316] [--> http://192.168.50.20/uploads/]

===============================================================
2022/03/30 05:18:08 Finished
===============================================================
```

> Listing 3 - Running Gobuster

Under the **/usr/share/wordlists/dirb/** folder we selected the **common.txt** wordlist, which found ten resources. Four of these resources are inaccessible due to insufficient privileges (Status: 403). However, the remaining six are accessible and deserve further investigation.

## 8.2.4. Security Testing with Burp Suite

[_Burp Suite_](https://portswigger.net/burp) is a GUI-based integrated platform for web application security testing. It provides several different tools via the same user interface.

While the free Community Edition mainly contains tools used for manual testing, the commercial versions include additional features, including a formidable web application vulnerability scanner. Burp Suite has an extensive feature list and is worth investigating, but we will only explore a few basic functions in this section.

We can find Burp Suite Community Edition in Kali under _Applications_ > _03 Web Application Analysis_ > _burpsuite_.

![Figure 2: Starting Burp Suite](https://static.offsec.com/offsec-courses/PEN-200/imgs/web/1f4a0c0d9cc38fb6f007d782aad59c26-webapp_burp_start.png)

Figure 2: Starting Burp Suite

We can also launch it from the command line with **burpsuite**:

```
kali@kali:~$ burpsuite
```

> Listing 4 - Starting Burp Suite from a terminal shell

After our initial launch, we'll first notice a warning that Burp Suite has not been tested on our [_Java Runtime Environment_](https://www.java.com/en/download/help/whatis_java.html) (JRE). Since the Kali team always tests Burp Suite on the Java version shipped with the OS, we can safely ignore this warning.

![Figure 1: Burp Suite JRE warning](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cc8b22666df43611ed00a0916f2c019d-JRE.png)

Figure 1: Burp Suite JRE warning

Once it launches, we'll choose _Temporary project_ and click _Next_.

![Figure 3: Burp Startup](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/847002f4a1489bdd009d9a79bc3df2b1-webapp_burp_01.png)

Figure 3: Burp Startup

We'll leave _Use Burp defaults_ selected and click _Start Burp_.

![Figure 4: Burp Configuration](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/e8c7788412e81bdca407f25445950430-webapp_burp_02.png)

Figure 4: Burp Configuration

After a few moments, the UI will load.

![Figure 5: Burp Suite User Interface](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/964d0764c9fe62249a910dd344dd443c-webapp_burp_03.png)

Figure 5: Burp Suite User Interface

The initial four panes of the interface primarily serve as a summary for the Pro version scanner, so we can ignore them. Instead, we are going to focus on the features present on the tabs in the upper bar.

Let's start with the _Proxy_ tool. In general terms, a web proxy is any dedicated hardware or software meant to intercept requests and/or responses between the web client and the web server. This allows administrators and testers alike to modify any requests that are intercepted by the proxy, both manually and automatically.

Some web proxies are employed to intercept company-wide TLS traffic. Known as TLS inspection devices, these perform decryption and re-encryption of the traffic and thus nullify any privacy layer provided by the HTTPS protocol.

With the Burp Proxy tool, we can intercept any request sent from the browser before it is passed on to the server. We can change almost anything about the request at this point, such as parameter names or form values. We can even add new headers. This lets us test how an application handles unexpected arbitrary input. For example, an input field might have a size limit of 20 characters, but we could use Burp Suite to modify a request to submit 30 characters.

To set up a proxy, we will first click the _Proxy_ tab to reveal several sub-tabs. We'll also disable the _Intercept_ tool, found under the _Intercept_ tab.

When _Intercept_ is enabled, we have to manually click on _Forward_ to send each request to its destination. Alternatively, we can click _Drop_ to _not_ send the request. There are times when we will want to intercept traffic and modify it, but when we are just browsing a site, having to click _Forward_ on each request is very tedious.

![Figure 6: Turning Off Intercept](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3492eb3813a06b0dd6eddf6cbe87d560-burp01.png)

Figure 6: Turning Off Intercept

Next, we can review the proxy listener settings. The _Options_ sub-tab shows what ports are listening for proxy requests.

![Figure 7: Proxy Listeners](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/6339eb250f784e57fcf1fe57cfe81d85-burp02.png)

Figure 7: Proxy Listeners

By default, Burp Suite enables a proxy listener on **localhost:8080**. This is the host and port that our browser must connect to in order to proxy traffic through Burp Suite.

Burp Suite is now shipped with its own Chromium-based native web browser, which is preconfigured to work with all Burp's features. However, for this course we are going to exclusively rely on Kali's Firefox browser because it is a more flexible and modular option.

Let's demonstrate how to configure our local Kali machine with the Firefox browser to use Burp Suite as a proxy.

In Firefox, we can do this by navigating to **about:preferences#general**, scrolling down to _Network Settings_, then clicking _Settings_.

Let's choose the _Manual_ option, setting the appropriate IP address and listening port. In our case, the proxy (Burp) and the browser reside on the same host, so we'll use the loopback IP address 127.0.0.1 and specify port 8080.

In some testing scenarios, we might want to capture the traffic from multiple machines, so the proxy will be configured on a standalone IP. In such cases, we will configure the browser with the external IP address of the proxy.

Finally, we also want to enable this proxy server for all protocol options to ensure that we can intercept every request while testing the target application.

![Figure 8: Firefox Proxy Configuration.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/cb25eb740f85993f49bdcee4c822b762-burp03.png)

Figure 8: Firefox Proxy Configuration.

With Burp configured as a proxy on our browser, we can close any extra open Firefox tabs and browse to **http://www.megacorpone.com**. We should find the intercepted traffic in Burp Suite under _Proxy_ > _HTTP History_.

![Figure 9: Burp Suite HTTP History](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/4ef14903af29e82939ab14dc6ce6e501-burp04.png)

Figure 9: Burp Suite HTTP History

We can now review the various requests our browser performed towards our target website.

If the browser hangs while loading the page, Intercept may be enabled. Switching it off will allow the traffic to flow uninterrupted. As we browse to additional pages, we should observe more requests in the _HTTP History_ tab.

By clicking on one of the requests, the entire dump of client requests and server responses is shown in the lower half of the Burp UI.

![Figure 10: Inspecting the first HTTP request.](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/95e5252bffb4de0f29b0e5cbd68253b8-burp05.png)

Figure 10: Inspecting the first HTTP request.

On the left pane we can visualize the client request details, with the server response on the right pane. With this powerful Burp feature, we can inspect every detail of each request performed, along with the response. We'll make use of this feature often during upcoming Modules.

Why does "detectportal.firefox.com" keep showing up in the proxy history? A [_captive portal_](https://en.wikipedia.org/wiki/Captive_portal) is a web page that serves as a sort of gateway page when attempting to browse the Internet. It is often displayed when accepting a user agreement or authenticating through a browser to a Wi-Fi network. To ignore this, simply enter **about:config** in the address bar. Firefox will present a warning, but we can proceed by clicking _I accept the risk!_. Finally, search for "network.captive-portal-service.enabled" and double-click it to change the value to "false". This will prevent these messages from appearing in the proxy history.

Beside the Proxy feature, the _Repeater_ is another fundamental Burp tool. With the Repeater, we can craft new requests or easily modify the ones in History, resend them, and review the responses. To observe this in action, we can right-click a request from _Proxy_ > _HTTP History_ and select _Send to Repeater_.

![Figure 11: Sending a Request to Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/fe5cd81462a52b4f89fc5bcb5c67607b-burp06.png)

Figure 11: Sending a Request to Repeater

If we click on _Repeater_, we will observe one sub-tab with the request on the left side of the window. We can send multiple requests to Repeater, and it will display them using separate tabs. Let's send the request to the server by clicking _Send_.

![Figure 12: Burp Suite Repeater](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/7fa107a2d26b2cc19ca49975b86269bc-burp07.png)

Figure 12: Burp Suite Repeater

Burp Suite will display the raw server response on the right side of the window, which includes the response headers and un-rendered response content.

![Figure 13: Burp Suite Repeater with Request and Response](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3519e63e6a5a2a5b144aa83e0608a23c-burp08.png)

Figure 13: Burp Suite Repeater with Request and Response

The last feature we will cover is Intruder. First, we'll need to configure our local Kali's /etc/hosts file to statically assign the IP to the _offsecwp_ website we are going to test.

Info

Some web applications will include their hostname in links and redirects. If we don't have an entry in /etc/hosts that matches the web application's hostname, our browser and other tools may not be able to follow these links.

This allows us to access the VM by hostname while bypassing DNS.

```
kali@kali:~$ cat /etc/hosts 
...
192.168.50.16 offsecwp
```

> Listing 5 - Setting up our /etc/hosts file for offsecwp

The [_Intruder_](https://portswigger.net/burp/documentation/desktop/tools/intruder/using) Burp feature, as its name suggests, is designed to automate a variety of attack angles, from the simplest to more complex web application attacks. To learn more about this feature, let's simulate a password brute forcing attack.

Since we are dealing with a new target, we can start a new Burp session and configure the Proxy as we did before. Next, we'll navigate to **http://offsecwp/wp-login.php** from Firefox. Then, we will type "admin" and "test" as respective username and password values, and click _Log in_.

![Figure 14: Simulating a failed WordPress login ](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/feccd244d6f4b88c7cacd650f713d80a-burp09.png)

Figure 14: Simulating a failed WordPress login

Returning to Burp, we'll navigate to _Proxy_ > _HTTP History_, right-click on the POST request to **/wp-login.php** and select _Send to Intruder_.

![Figure 15: Sending the POST request to Intruder](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/5b81caf0153e8c312942e52703825a8a-burp10new.png)

Figure 15: Sending the POST request to Intruder

We can now select the _Intruder_ tab in the upper bar, choose the POST request we want to modify, and move to the _Positions_ sub-tab. Knowing that the user _admin_ is correct, we only need to brute force the password field. First, we'll press _Clear_ on the right bar so that all fields are cleared. We can then select the value of the _pwd_ key and press the _Add_ button on the right.

![Figure 15: Assigning the password value to the Intruder payload generator](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/1377199f64563593c0d812be0dd27fee-burp11.png)

Figure 15: Assigning the password value to the Intruder payload generator

We have now instructed the Intruder to modify only the password value on each new request. Before starting our attack, let's provide Intruder with a wordlist. Knowing that the correct password is "password", we can grab the first 10 values from the **rockyou** wordlist on Kali.

```
kali@kali:~$ cat /usr/share/wordlists/rockyou.txt | head
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

> Listing 6 - Copying the first 10 rockyou wordlist values

Moving to the _Payloads_ sub-tab, we can paste the above wordlist into the _Payload Options: \[Simple list\]_ area.

![Figure 15: Pasting the first 10 rockyou entries](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/9782513cea865bbb817f691c9354cf57-burp12.png)

Figure 15: Pasting the first 10 rockyou entries

With everything ready to start the Intruder attack, let's click on the top right _Start Attack_ button.

We can move past the Burp warning about restricted Intruder features, as this won't impact our attack. After we let the attack complete, we can observe that apart from the initial probing request, it performed 10 requests, one for each entry in the provided wordlist.

![Figure 15: Inspecting Intruder's attack results](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/a3888c57e423a1d424c3ce5203b3bc6b-burp13.png)

Figure 15: Inspecting Intruder's attack results

We'll notice that the WordPress application replied with a different _Status_ code on the 4th request, hinting that this might be the correct password value. Our hypothesis is confirmed once we try to log in to the WordPress administrative console with the discovered password.

![Figure 15: Logging to the WP admin console](https://static.offsec.com/offsec-courses/PEN-200/imgs/webintro/3323fc5d7ed2b4b4b183160489a73b19-burp14.png)

Figure 15: Logging to the WP admin console

Now that we've built a solid foundational knowledge about how Burp and other assessment tools work, let's take the next step and learn how to enumerate a target web application.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Web Application Assessment Tools - Walkthrough VM #1

Web Application Assessment Tools - Module Exercise VM #1

Web Application Assessment Tools - Module Exercise VM #2

#### Labs

1.  We have been tasked to test the SMS Two-Factor authentication of a newly-developed web application. The SMS verification code is made by four digits. Which Burp tool is most suited to perform a brute force attack against the keyspace?

Answer