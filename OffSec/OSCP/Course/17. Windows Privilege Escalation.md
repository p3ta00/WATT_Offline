# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer

# 17\. Windows Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Windows
-   Leveraging Windows Services
-   Abusing other Windows components

During a penetration test, we often gain our initial foothold on a Windows system as an unprivileged user. However, we usually need administrative privileges to search for sensitive information in other users' home directories, examine configuration files on the system, or extract password hashes with [_Mimikatz_](https://github.com/gentilkiwi/mimikatz). The process of elevating our privileges and access from unprivileged to privileged is called [_Privilege Escalation_](https://en.wikipedia.org/wiki/Privilege_escalation).

While this Module focuses on Windows, the next Module will explore privilege escalation techniques on Linux systems. Once we've completed both, we will not only understand how the security models and attack surfaces of the two operating systems differ, but also how we can leverage privilege escalation vectors on each of them.

In this Module, we'll begin with an introduction to Windows privileges and access control mechanisms. Then, we'll cover how to establish situational awareness on the target system by gathering information. Based on this information, we'll perform various privilege escalation attacks. First, we'll search the system for sensitive information left by users and the OS. Next, we'll learn how to abuse Windows services to attempt privilege escalation attacks. Finally, we'll review other components of Windows, which allow us to elevate our privileges through [_Scheduled Tasks_](https://en.wikipedia.org/wiki/Windows_Task_Scheduler). Finally, we'll investigate the use of exploits.

## 17.1. Enumerating Windows

This Learning Unit covers the following Learning Objectives:

-   Understand Windows privileges and access control mechanisms
-   Obtain situational awareness
-   Search for sensitive information on Windows systems
-   Find sensitive information generated by PowerShell
-   Become familiar with automated enumeration tools

Every target can be considered unique due to differences in OS versions, patch levels, system configuration, etc. Therefore, it is important for us to understand how to obtain and leverage information about the target system to achieve privilege escalation. To fully grasp the attack vectors of this Module, we'll first need to get familiar with the Windows privilege structure and access control mechanisms.

While it is very common to use technical attack vectors to achieve privilege escalation, it's often sufficient to merely review information that users and the system leave behind. A couple examples are when a user stores passwords in a text file or Windows records the input of a password in PowerShell. For attackers, this can be a gold mine that leads to higher privileges.

In this Learning Unit, we will start by discussing how Windows privileges and access control mechanisms work. Then, we'll explore methods to establish situational awareness on the system. These methods provide vital information about a target system such as existing users, active network connections, and running applications. Next, we'll examine various areas in Windows where we can search for sensitive information. Finally, we'll review automated tools.

## 17.1.1. Understanding Windows Privileges and Access Control Mechanisms

Privileges on the Windows operating system refer to the permissions of a specific account to perform system-related local operations (e.g. modifying the filesystem or adding users). To grant or deny these operations, Windows needs control mechanisms to identify the source of the operation and determine if the privileges for the operation are sufficient.

In this section, we'll cover four different concepts and mechanisms: [_Security Identifier_](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers) (SID), [_access token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens), [_Mandatory Integrity Control_](https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control), and [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview).

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the [_Local Security Authority_](https://docs.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (LSA), and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

Windows uses only the SID, not usernames, to identify principals for access control management.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

Listing 2 shows that the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called [_well-known SIDs_](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids). These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

While we won't directly work with SIDs in this Module, knowing how Windows identifies principals is necessary to understand access tokens. Additionally, it's vital in the upcoming Active Directory Modules.

Now that we know how Windows identifies principals on a system, let's discuss how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

When a user starts a process or thread, a token will be assigned to these objects. This token, called a _primary token_, specifies which permissions the process or threads have when interacting with another object and is a copy of the access token of the user.

A thread can also have an [_impersonation token_](https://docs.microsoft.com/en-us/windows/win32/secauthz/impersonation-tokens) assigned. Impersonation tokens are used to provide a different security context than the process that owns the thread. This means that the thread interacts with objects on behalf of the impersonation token instead of the primary token of the process.

Beyond SIDs and tokens, Windows enforces [Mandatory Integrity Control](https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control) (MIC), which restricts access to objects based on predefined integrity levels. It uses [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625957.aspx) to control access to securable objects. Integrity levels define how much trust Windows assigns to applications and objects, restricting lower-integrity processes from modifying higher-integrity ones.

Processes and objects inherit the integrity level of the user who creates them. An exception occurs when an executable has a low integrity level; any process it spawns will inherit the same integrity level. Lower-integrity users cannot modify higher-integrity objects, even with sufficient permissions.

From Windows Vista onward, processes run on five integrity levels:

```
- System integrity – Kernel-mode processes with SYSTEM privileges
- High integrity – Processes with administrative privileges
- Medium integrity – Processes running with standard user privileges
- Low integrity level – Restricted processes, often used for security   [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)), such as web browsers.
- Untrusted – The lowest integrity level, assigned to highly restricted processes that pose potential security risks
```

> Listing 4 - Integrity Levels

We can check process integrity levels using [_Process Explorer_](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), verify a user’s integrity level with _whoami /groups_, and inspect file integrity levels with [_icacls_](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls).

Info

Learn more about sandboxing [here](https://en.wikipedia.org/wiki/Sandbox_(software_development)).

For example, the following figure shows two PowerShell processes on a Windows system in Process Explorer. One started as a regular user and the other as an administrative user.

![Figure 1: Different Integrity Levels of PowerShell](https://static.offsec.com/offsec-courses/PEN-200/imgs/winprivesc/f515fd83b000b6539dad81fa0a0e6499-privesc_winpriv_intlevel2.png)

Figure 1: Different Integrity Levels of PowerShell

The PowerShell processes have the integrity level of _High_ and _Medium_. Reviewing Listing 4, we can infer that the _High_ integrity level process is started by the administrative user and the _Medium_ integrity level process by the regular user.

In addition to integrity levels, Windows employs [_User Account Control_](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) (UAC) to further restrict unauthorized privilege escalation. UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. To enforce this security model, Windows issues two access tokens to administrative users at logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. The administrator token is activated only when elevated privileges are explicitly required. To leverage the administrator token, a [UAC consent prompt](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) needs to be confirmed.

This functionality aligns with Windows’ security model, ensuring applications run with appropriate privilege levels. As a core component of Windows security, this mechanism assigns [_integrity levels_](https://msdn.microsoft.com/en-us/library/bb625963.aspx) to application processes and [securable objects](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects). In simple terms, it defines how much trust the OS grants to applications and objects. For example, integrity levels determine whether an application can read from or write to the file system. Certain APIs are inaccessible at lower integrity levels.

From Windows Vista onward, processes run on four integrity levels:

-   System integrity – Kernel-mode processes with SYSTEM privileges
-   High integrity – Administrative processes
-   Medium integrity – Standard user processes
-   Low integrity – Restricted processes, commonly used for [sandboxing](https://en.wikipedia.org/wiki/Sandbox_(software_development)) (e.g., web browsers)

It is important to note that just being a member of the Administrator group does not mean that the processes will be run with high integrity. This is where the UAC enforces privilege separation. By default, processes run at medium integrity.

At medium integrity, users cannot modify system files or registry keys. To do so, they must elevate to high integrity. This is why a user is prompted to elevate their session to perform some actions.

Info

Attackers and penetration testers often seek to bypass UAC to execute processes at high integrity, allowing unrestricted access to system resources.

This overview has introduced key Windows security concepts, including SIDs, access tokens, integrity levels, and UAC. Next, we will explore additional access control mechanisms through practical demonstrations.

#### Labs

1.  What is the RID of the first standard user?

Answer