# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer

# 18\. Linux Privilege Escalation

In this Learning Module, we will cover the following Learning Units:

-   Enumerating Linux
-   Exposed Confidential Information
-   Insecure File Permissions
-   Abusing System Linux components

As with many other attack techniques, escalating privileges requires us to collect knowledge about the target. This is accomplished by enumerating the operating system for any kind of misconfiguration or software vulnerability that can be leveraged for our purposes.

As documented within the [_MITRE ATT&CK Framework_](https://attack.mitre.org/tactics/TA0004), privilege escalation is a tactic comprising different techniques that aim to leverage user permissions to access restricted resources.

In this Module, we will turn our attention to Linux-based targets. We will explore how to enumerate Linux machines and what constitutes Linux privileges. We'll then demonstrate common Linux-based privilege escalation techniques based on insecure file permissions and misconfigured system components.

## 18.1. Enumerating Linux

This Learning Unit covers the following Learning Objectives:

-   Understand Files and Users' Privileges on Linux
-   Perform Manual Enumeration
-   Conduct Automated Enumeration

In this Learning Unit, we'll start with a refresher on the Linux privilege scheme, then move to performing manual and automated enumeration techniques.

## 18.1.1. Understanding Files and Users Privileges on Linux

Before discussing specific privilege escalation techniques, let's recap Linux privileges and access controls.

One of the defining features of Linux and other UNIX derivatives is that most resources, including files, directories, devices, and even network communications are represented in the [filesystem](https://wiki.archlinux.org/index.php/users_and_groups). Put colloquially, "everything is a file".

Every file (and by extension every element of a Linux system) abides by user and group permissions based on three primary properties: _read_ (symbolized by **r**), _write_ (symbolized by **w**), and _execute_ (symbolized by **x**). Each file or directory has specific permissions for three categories of users: the _owner_, the _owner group_, and _others group_.

Each permission (rwx) allows the designated collection of users to perform different actions depending on if the resource is a file or a directory.

For files, _r_ allows reading the file content, _w_ allows changing its content and _x_ allows the file to be run. A directory is handled differently from a file. Read access gives the right to consult the list of its contents (files and directories). Write access allows creating or deleting files. Finally, execute access allows crossing through the directory to access its contents (using the cd command, for example). Being able to cross through a directory without being able to read it gives the user permission to access known entries, but only by knowing their exact name.

Let's examine a simple combination of those file permissions using a real-world example on our local Kali machine, since it's based on the Linux Debian distribution.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

> Listing 1 - Inspecting file permissions and users ownership

For each user category, the three different access permissions are displayed. The very first hyphen we encounter describes the file type. Since it's not strictly related to [file permissions](https://en.wikipedia.org/wiki/File-system_permissions), we can safely ignore it.

The next three characters display the file owner (_root_) permissions, which are _rw-_, meaning the owner has read and write, but no execute privileges. Next, the _shadow_ group owner has only been given read access, as the write and execute flag are unset. Finally, the others group has not been granted any access rights for this file.

We can now apply this introductory knowledge about Linux file permissions while performing privilege escalation enumeration in the next section.

## 18.1.2. Manual Enumeration

Manually enumerating Linux systems can be time consuming. However, this approach allows for a more controlled outcome because it helps identify more peculiar privilege escalation methods that are often overlooked by automated tools.

Furthermore, automated enumeration cannot replace manual investigation because the customized settings of our target environments are likely to be exactly those that are misconfigured.

Some of the commands in this Module may require minor modifications depending on the target operating system version. In addition, not all the commands presented in this section will be reproducible on the dedicated clients.

When gaining initial access to a target, one of the first things we should identify is the user context. We can use the [**id**](http://man7.org/linux/man-pages/man1/id.1.html) command to gather user context information. We can do so by connecting through SSH as the _joe_ user to our Debian lab machine.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

> Listing 2 - Getting information about the current user

The output reveals that we are operating as the _joe_ user, which has a [_User Identifier_](https://en.wikipedia.org/wiki/User_identifier) (UID) and Group Identifier (GID) of 1000. The user joe is also part of other groups that are out of scope for this Module.

To enumerate all users, we can simply read the contents of the **/etc/passwd** file.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

> Listing 3 - Getting information about the users

The **passwd** file lists several user accounts, including accounts used by various services on the target machine such as _www-data_ and _sshd_. This indicates that a web server and an SSH server are likely installed on the system.

We can now zoom in on our current user's data:

-   **Login Name**: "joe" - Indicates the username used for login.
    
-   **Encrypted Password**: "x" - This field typically contains the hashed version of the user's password. In this case, the value _x_ means that the entire password hash is contained in the **/etc/shadow** file (more on that shortly).
    
-   **UID**: "1000" - Aside from the root user that has always a UID of _0_, Linux starts counting regular user IDs from 1000. This value is also called _real user ID_.
    
-   **GID**: "1000" - Represents the user's specific Group ID.
    
-   **Comment**: "joe,,," - This field generally contains a description about the user, often simply repeating username information.
    
-   **Home Folder**: "/home/joe" - Describes the user's home directory prompted upon login.
    
-   **Login Shell**: "/bin/bash" - Indicates the default interactive shell, if one exists.
    

In addition to the _joe_ user, we also notice another user named _eve_, and we can infer this is a standard user since it has a configured home folder **/home/eve**. On the other hand, system services are configured with the **/usr/sbin/nologin** as login shell, where the _nologin_ statement is used to block any remote or local login for service accounts.

Enumerating all users on a target machine can help identify potential high-privilege user accounts we could target to elevate our privileges.

Next, a machine's _hostname_ can often provide clues about its functional roles. Often, the hostnames will include identifiable abbreviations such as _web_ for a web server, _db_ for a database server, _dc_ for a domain controller, etc.

On most Linux distributions, we can find the hostname embedded in the command prompt. However, we should rely only on system commands to retrieve the target's information, since sometimes the prompt's text can be deceiving.

We can discover the hostname with the aptly named [**hostname**](https://linux.die.net/man/1/hostname) command.

```
joe@debian-privesc:~$ hostname
debian-privesc
```

> Listing 4 - Getting information about the hostname

Enterprises often enforce a naming convention scheme for hostnames, so they can be categorized by location, description, operating system, and service level. In our case, the hostname is comprised of only two parts: the OS type and the description.

Identifying the role of a machine can help us focus our information gathering efforts by increasing the context surrounding the host.

At some point during the privilege escalation process, we may need to rely on [_kernel_](https://en.wikipedia.org/wiki/Kernel_(operating_system)) exploits that specifically exploit vulnerabilities in the core of a target's operating system. These types of exploits are built for a very specific type of target, specified by a particular operating system and version combination. Since attacking a target with a mismatched kernel exploit can lead to system instability or even a crash, we must gather precise information about the target.

Any system instability caused by our penetration testing activity would likely alert system administrators prior to any SOC team. For this reason, we should be twice as careful when dealing with kernel exploits and, when possible, test the exploits in a local environment beforehand.

The **/etc/issue** and **/etc/\*-release** files contain information about the operating system release and version. We can also run the [**uname -a**](https://linux.die.net/man/1/uname) command:

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=buster
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

> Listing 5 - Getting the version of the running operating system and architecture

The **issue** and **os-release** files located in the **/etc** directory contain the operating system version (Debian 10) and release-specific information, including the distribution codename (buster). The command **uname -a** outputs the kernel version (4.19.0) and architecture (x86\_64).

Next, let's explore which running processes and services may allow us to elevate our privileges. For this to occur, the process must run in the context of a privileged account and must either have insecure permissions or allow us to interact with it in unintended ways.

We can list system processes (including those run by privileged users) with the [**ps**](http://man7.org/linux/man-pages/man1/ps.1.html) command. We'll use the **a** and **x** flags to list all processes with or without a [_tty_](https://www.linusakesson.net/programming/tty/) and the **u** flag to list the processes in a user-readable format.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

> Listing 6 - Getting a list of running processes on Linux

The output lists several processes running as root that are worth researching for possible vulnerabilities. We'll notice the **ps** command we ran is also listed in the output, owned by the current user. We can also filter the specific user-owned process from the output with the appropriate username.

The next step in our analysis of the target host is to review available network interfaces, routes, and open ports. This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. The presence of specific virtual interfaces may also indicate the existence of virtualization or antivirus software.

An attacker may use a compromised target to pivot or move between connected networks. This will amplify network visibility and allow the attacker to target hosts not directly reachable from the original attack machine.

We can also investigate port bindings to see if a running service is only available on a loopback address, rather than on a routable one. Investigating a privileged program or service listening on the loopback interface could expand our attack surface and increase our probability of a privilege escalation attack's success.

Depending on the version of Linux, we can list the TCP/IP configuration of every network adapter with either [**ifconfig**](https://linux.die.net/man/8/ifconfig) or [**ip**](http://man7.org/linux/man-pages/man8/ip.8.html). While the former command displays interface statistics, the latter provides a compact version of the same information. Both commands accept the **a** flag to display all information available.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

> Listing 7 - Listing the full TCP/IP configuration on all available adapters on Linux

Based on the output above, the Linux client is also connected to more than one network.

We can display network routing tables with either [**route**](https://linux.die.net/man/8/route) or [**routel**](http://man7.org/linux/man-pages/man8/routel.8.html), depending on the Linux distribution and version. Both commands provide similar information.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

> Listing 8 - Printing the routes on Linux

Finally, we can display active network connections and listening ports using either [**netstat**](https://linux.die.net/man/8/netstat) or [**ss**](http://man7.org/linux/man-pages/man8/ss.8.html), both of which accept the same arguments.

For example, we can list all connections with **\-a**, avoid hostname resolution (which may stall the command execution) with **\-n**, and list the process name the connection belongs to with **\-p**. We can combine the arguments and simply run **ss -anp**:

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

> Listing 9 - Listing all active network connections on Linux

The output lists the various listening ports and active sessions, including our own active SSH connection and its listening socket.

Continuing with our baseline enumeration, let's focus next on firewall rules.

In general, we're primarily interested in a firewall's state, profile, and rules during the remote exploitation phase of an assessment. However, this information can also be useful during privilege escalation. For example, if a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface. If we can interact with these services locally, we may be able to exploit them to escalate our privileges on the local system.

During this phase, we can also gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

On Linux-based systems, we must have _root_ privileges to list firewall rules with [_iptables_](https://linux.die.net/man/8/iptables). However, depending on how the firewall is configured, we may be able to glean information about the rules as a standard user.

For example, the [_iptables-persistent_](https://packages.debian.org/sid/iptables-persistent) package on Debian Linux saves firewall rules in specific files under **/etc/iptables** by default. These files are used by the system to restore [_netfilter_](https://www.netfilter.org/) rules at boot time. These files are often left with weak permissions, allowing them to be read by any local user on the target system.

We can also search for files created by the _iptables-save_ command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the _iptables-restore_ command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**/etc**) or grep the file system for iptables commands to locate the file. If the file has insecure permissions, we could use the contents to infer the firewall configuration rules running on the system.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

> Listing 10 - Inspecting custom IP tables

Since this file is read-only by any users other than root, we can inspect its contents. We'll notice a non-default rule that explicitly allows the destination port _1999_. This configuration detail stands out and should be noted for later investigation.

Next, let's examine scheduled tasks that attackers commonly leverage during privilege escalation attacks. Systems acting as servers often periodically execute various automated, scheduled tasks. When these systems are misconfigured, or the user-created files are left with insecure permissions, we can modify these files that will be executed by the scheduling system at a high privilege level.

The Linux-based job scheduler is known as [_cron_](https://en.wikipedia.org/wiki/Cron). Scheduled tasks are listed under the **/etc/cron.\*** directories, where _\*_ represents the frequency at which the task will run. For example, tasks that will be run daily can be found under **/etc/cron.daily**. Each script is listed in its own subdirectory.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

> Listing 11 - Listing all cron jobs

Listing the directory contents, we notice several tasks scheduled to run daily.

It is worth noting that system administrators often add their own scheduled tasks in the **/etc/crontab** file. These tasks should be inspected carefully for insecure file permissions, since most jobs in this file will run as root. To view the current user's scheduled jobs, we can run **crontab** followed by the **\-l** parameter.

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

> Listing 12 - Listing cron jobs for the current user

In the above output, only the commented instructions are present, meaning no cron job has been configured for the user _joe_. However, if we try to run the same command with the **sudo** prefix, we discover that a backup script is scheduled to run every minute.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

> Listing 13 - Listing cron jobs for the root user

Listing cron jobs using sudo reveals jobs run by the _root_ user. In this example, it shows a backup script running as root. If this file has weak permissions, we may be able to leverage it to escalate our privileges.

As we'll learn later in this Module, the _joe_ user has been granted specific sudo permission only to list cron jobs running as the root user. This permission alone cannot be abused to obtain a root shell.

At some point, we may need to leverage an exploit to escalate our local privileges. If so, our search for a working exploit begins with the enumeration of all installed applications, noting the version of each. We can use this information to search for a matching exploit.

Manually searching for this information could be very time consuming and ineffective, so we'll learn how to automate this process in the next section. However, we should know how to manually query installed packages as this is needed to corroborate information obtained during previous enumeration steps.

Linux-based systems use a variety of package managers. For example, Debian-based Linux distributions, like the one in our lab, use [_dpkg_](https://linux.die.net/man/1/dpkg), while Red Hat-based systems use [_rpm_](https://linux.die.net/man/8/rpm).

To list applications installed by dpkg on our Debian system, we can use **dpkg -l**.

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

> Listing 14 - Listing all installed packages on a Debian Linux operating system

This confirms what we expected earlier from enumerating listening ports: the Debian 10 machine is, in fact, running a web server. In this case, it is running Apache2.

As we previously mentioned, files with insufficient access restrictions can create a vulnerability that may grant an attacker elevated privileges. This most often happens when an attacker can modify scripts or binary files that are executed under the context of a privileged account.

Sensitive files that are readable by an unprivileged user may also contain important information such as hard-coded credentials for a database or a service account running with higher privileges.

Since it is not feasible to manually check the permissions of each file and directory, we need to automate this task as much as possible. As a start, we can use [**find**](http://man7.org/linux/man-pages/man1/find.1.html) to identify files with insecure permissions.

In the example below, we are searching for every directory writable by the current user on the target system. We'll search the whole root directory (**/**) and use the **\-writable** argument to specify the attribute we are interested in. We can also use **\-type d** to locate directories, and filter errors with **2>/dev/null**:

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

> Listing 15 - Listing all world writable directories

As shown above, several directories seem to be world-writable, including the **/home/joe/.scripts** directory, which is the location of the cron script we found earlier. This certainly warrants further investigation.

Let's move further with our enumeration. On most systems, drives are automatically mounted at boot time. Because of this, it's easy to forget about unmounted drives that could contain valuable information. We should always look for unmounted drives, and if they exist, check the mount permissions.

On Linux-based systems, we can use [**mount**](https://linux.die.net/man/8/mount) to list all mounted filesystems. In addition, the [**/etc/fstab**](https://geek-university.com/linux/etc-fstab-file) file lists all drives that will be mounted at boot time.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

> Listing 16 - Listing content of /etc/fstab and all mounted drives

The output reveals a swap partition and the primary ext4 disk of this Linux system.

Keep in mind that the system administrator might have used custom configurations or scripts to mount drives that are not listed in the **/etc/fstab** file. Because of this, it's good practice to not only scan **/etc/fstab**, but to also gather information about mounted drives using **mount**.

Furthermore, we can use [**lsblk**](https://linux.die.net/man/8/lsblk) to view all available disks.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 part
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

> Listing 17 - Listing all available drives using lsblk

We'll notice that the _sda_ drive consists of three different numbered partitions. In some situations, showing information for all local disks on the system might reveal partitions that are not mounted. Depending on the system configuration (or misconfiguration), we then might be able to mount those partitions and search for interesting documents, credentials, or other information that could allow us to escalate our privileges or get a better foothold in the network.

Another common privilege escalation technique involves exploitation of device drivers and kernel modules. We will explore actual exploitation tactics later in this Module, but first let's examine some important enumeration techniques.

Since this technique relies on matching vulnerabilities with corresponding exploits, we'll need to gather a list of drivers and kernel modules that are loaded on the target. We can enumerate the loaded kernel modules using **lsmod** without any additional arguments.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

> Listing 18 - Listing loaded drivers

Once we've collected the list of loaded modules and identified those, we want more information about, such as **libata** in the above example, we can use **modinfo** to find out more about the specific module. We should note that this tool requires the full path to run.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

> Listing 19 - Displaying additional information about a module

Once we've obtained a list of drivers and their versions, we are better positioned to find any relevant exploits.

Later in this Module, we will explore various methods of privilege escalation. However, there are a few specific enumerations we should cover in this section that could reveal interesting "shortcuts" to privilege escalation.

Aside from the _rwx_ file permissions described previously, two additional special rights pertain to executable files: _setuid_ and _setgid_. These are symbolized with the letter "s".

If these two rights are set, either an uppercase or lowercase "s" will appear in the permissions. This allows the current user to execute the file with the rights of the _owner_ (setuid) or the _owner's group_ (setgid).

When running an executable, it normally inherits the permissions of the user that runs it. However, if the SUID permissions are set, the binary will run with the permissions of the file owner. This means that if a binary has the SUID bit set and the file is owned by root, any local user will be able to execute that binary with elevated privileges.

When a user or a system-automated script launches a SUID application, it inherits the UID/GID of its initiating script: this is known as effective UID/GID (eUID, eGID), which is the actual user that the OS verifies to grant permissions for a given action.

Any user who manages to subvert a setuid root program to call a command of their choice can effectively impersonate the root user and gains all rights on the system. Penetration testers regularly search for these types of files when they gain access to a system as a way of escalating their privileges.

We can use **find** to search for SUID-marked binaries. In this case, we are starting our search at the root directory (**/**), searching for files (**\-type f**) with the SUID bit set, (**\-perm -u=s**) and discarding all error messages (**2>/dev/null**):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umount
/usr/bin/mount
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

> Listing 20 - Searching for SUID files

In this case, the command found several SUID binaries. Exploitation of SUID binaries will vary based on several factors. For example, if **/bin/cp** (the _copy_ command) were SUID, we could copy and overwrite sensitive files such as **/etc/passwd**.

A comprehensive list of Linux privilege escalation techniques can be found here:

-   [compendium](https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation) by g0tmi1k
-   [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
-   [HackTricks -Linux Privilege Escalation](https://book.hacktricks.xyz/linux-hardening/privilege-escalation)

Having covered the main concepts behind manually enumerating Linux systems for privilege escalation techniques, we are going to learn how to automate the process in bulk in the upcoming section.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Linux Privilege Escalation - Manual Enumeration - VM #1

Linux Privilege Escalation - Manual Enumeration - VM #2

#### Labs

1.  Connect to VM 1 with the provided credentials and replicate the manual enumeration techniques covered in this section. Inspect the target's OS information and its release details. What is the Linux distribution codename?

Answer