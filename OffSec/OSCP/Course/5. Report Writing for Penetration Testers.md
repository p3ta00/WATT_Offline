# 5\. Report Writing for Penetration Testers

We will cover the following Learning Units in this Learning Module:

-   Understanding Note-taking
-   Writing Effective Technical Penetration Testing Reports

This Module is designed to help Penetration Testers understand how to deliver effective reports to their clients.

## 5.1. Understanding Note-Taking

In this Learning Unit we will cover the following Learning Objectives:

-   Review the deliverables for penetration testing engagements
-   Understand the importance of note portability
-   Identify the general structure of pentesting documentation
-   Choose the right note-taking tool
-   Understand the importance of taking screenshots
-   Use tools to take screenshots

## 5.1.1. Penetration Testing Deliverables

A penetration test or [red team exercise](https://www.aon.com/cyber-solutions/thinking/penetration-testing-or-red-teaming/) is difficult to script in advance. This is because the tester cannot consistently anticipate exactly what kind of machines or networks the client will want to be tested.

Even though the outcome of our assessment is often unpredictable, it is often recommended to define a detailed _scope_ during the preliminary meetings with the customer. This process is especially very helpful when prioritizing business critical targets within large networks.

While the general execution plan for a penetration test will often follow a particular model, most pentests tend to follow the maxim ["no plan survives first contact with the enemy"](https://quoteinvestigator.com/2021/05/04/no-plan). This means that any specific activities we might expect to perform during the engagement might not actually happen, since the reality of the testing environment is almost certainly different than our initial ideas and hypotheses about it. It's therefore difficult to report on penetration tests using prepopulated forms. This is especially the case when the testing is carried out with little prior discussion with the client, for example, if the client is looking to surprise their defending teams in some manner.

As such, instead of preparing a report in advance, the penetration test is executed, and notes are taken as it proceeds to ensure that there is a detailed record of what was done. This makes sure that:

-   the penetration test can be repeated if it becomes necessary to demonstrate that an issue is real.
-   the penetration test can be repeated after remediation to confirm that an issue has been fixed.
-   if there's a system failure during the period of the penetration test, the client and tester can determine if the testing was the cause of the failure.

During a penetration test, some activities may not be permitted. We have to be very clear about the [_Rules of Engagement_](https://www.microsoft.com/en-us/msrc/pentest-rules-of-engagement) (RoE) under which the testing is done. When conducting red team testing, a person will often be assigned the role of "referee" to ensure that the rules of engagement are observed. There may be constraints placed on testing such as not carrying out denial of service attacks, or not engaging in social engineering. Furthermore, the testing work may be in response to the client's regulatory compliance requirements and may need to follow a specific methodology such as the [OWASP Penetration Testing Execution Standard](https://owasp.org/www-project-web-security-testing-guide/latest/3-The_OWASP_Testing_Framework/1-Penetration_Testing_Methodologies). Any such constraints need to be very clear from the outset.

## 5.1.2. Note Portability

Portability of penetration testing notes means being able to pass those notes on to others. Writing notes that are concise and coherent is an integral part of successful note-taking and enables the notes to be used not only by ourselves but also by others. Additionally, concise notes can be quickly adapted for technical reporting.

The need for portability is particularly emphasized when a penetration tester must leave an engagement because of sickness, illness, or other issues. Having a shared understanding of how notes should be taken is especially important for large penetration testing teams, where individuals need to be able to understand the details of other team members' engagements at will.

## 5.1.3. The General Structure of Penetration Testing Notes

We need to take a structured approach to note-taking that is both concise and precise. There are an uncountable number of ways in which we might organize our notes, and it would be futile to attempt to provide a one-size-fits all set of recommendations. Nevertheless, here are some principles that often useful to consider:

-   Rather than taking a few general notes assuming that we'll remember how to perform certain actions next time, we should record exactly what we did.
-   This means that every command that we type, every line of code that we modify, and even anywhere we click in the GUI should be recorded so that we can reproduce our actions.
-   Even if we've taken a lot of notes, if looking at them later doesn't help us remember exactly what happened during the assessment, then they won't be particularly useful to us.
-   The notes need to be structured and sufficiently detailed to remove any ambiguity.
-   To write a convincing and substantiated technical report later, we need to provide sufficient technical details within our notes.
-   If the notes are not written coherently, it will be difficult for someone else to repeat the test and get the same results.

The structure we recommend here for note-taking is sufficiently abstract to allow for personal preferences. As a general rule, we would like the notes to remind us of what occurred and allow us to replicate the issues we identify. A note-taking structure that starts broad and drills down into each section is an easy and expandable method of taking notes. The top-down approach guides us to start with the broadest activity, and then narrow down our focus and expand the level of detail until we have everything, we need to replicate exactly what happened.

Let's now look at an example of the notes we might take for a web vulnerability we discovered:

-   **Application Name**: This is important in a multi-application test, and a good habit to get into. The application names also lend itself to building a natural folder and file structure quite nicely.
    
-   **URL**: This is the exact URL that would be used to locate the vulnerability that we've detected.
    
-   **Request Type**: This represents both the type of request (i.e.: GET, POST, OPTIONS, etc.) that was made, as well as any manual changes we made to it. For example, we might intercept a POST request message and change the username or password before forwarding it on.
    
-   **Issue Detail**: This is the overview of the vulnerability that will be triggered by our actions. For example, we may point to a CVE describing the vulnerability if one exists, and/or explain the impact we observe. We may categorize the impact as denial of service, remote code execution, privilege escalation, and so on.
    
-   **Proof of Concept Payload**: This is a string or code block that will trigger the vulnerability. This is the most important part of the note, as it is what will drive the issue home and allow it to be replicated. It should list all of the necessary preconditions and provide the exact code or commands that would need to be used to trigger the vulnerability again.
    

Let's get more specific and review an example of testing for a _Cross-Site Scripting_ (XSS) vulnerability. The target we tested has a web page aptly named **XSSBlog.html**. When we navigate to it, we can enter a blog entry.

![Figure 1: XSS Testing](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/89c0b15a538a12feb35cdbecff45908b-xss1.png)

Figure 1: XSS Testing

When we read back the blog entry, we get the following alert:

![Figure 2: XSS Testing Issue](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/e113a6b758f58011df96c74634acfe7a-xss2.png)

Figure 2: XSS Testing Issue

While making these requests, we keep a record of our actions, as shown below.

```
Testing for Cross-Site Scripting 

Testing Target: 192.168.1.52 
Application:    XSSBlog
Date Started:   31 March 2022

1.  Navigated to the application
    http://192.168.1.52/XSSBlog.html
    Result: Blog page displayed as expected
    
2.  Entered our standard XSS test data: 
    You will rejoice to hear that no disaster has accompanied the
    commencement of an enterprise which you have regarded with such
    evil forebodings.<script>alert("Your computer is infected!");</script> 
    I arrived here yesterday, and my first task is to assure my dear
    sister of my welfare and increasing confidence in the success of
    my undertaking. 

3.  Clicked Submit to post the blog entry.
    Result: Blog entry appeared to save correctly.

4.  Navigated to read the blog post
    http://192.168.1.52/XSSRead.php
    Result: The blog started to display and then the expected alert popped up.

5.  Test indicated the site is vulnerable to XSS.

PoC payload: <script>alert(‘Your computer is infected!')</script>
```

> Listing 1 - Example of a Testing Note.

We now have a simple, fast, and expandable way to take coherent and comprehensive notes that another tester can follow. It's worth repeating that the notes are not themselves the report we will deliver to the client, but they will be invaluable when we attempt to put our report together later.

## 5.1.4. Choosing the Right Note-Taking Tool

There are an enormous number of both free and paid note-taking tools available today. To decide on the right tool for a particular engagement, it is important to understand some requirements. In many cases we want to keep all information local to the computer rather than uploading it anywhere else, so certain tools are precluded from being used. By the same token, if an engagement is source-code heavy then a tool that does not allow for code blocks to be inserted is not going to be appropriate.

While a comprehensive list of desirable properties to keep in mind is nearly impossible to enumerate, some of the more important items to remember are:

-   **Screenshots**: If a lot of screenshots are necessary, consider a tool that allows for inline screenshot insertion.
    
-   **Code blocks**: Code blocks need formatting to be properly and quickly understood.
    
-   **Portability**: Something that can be used cross-OS, or easily transferred to another place should be high on the list of priorities.
    
-   **Directory Structure**: In an engagement with multiple domains or applications, keeping a coherent structure is necessary. While manually setting up a structure is allowed, a tool that can do this automatically makes things easier.
    

Now that we have a good baseline of our requirements, let's consider the use of some note-taking tools.

[_Sublime_](https://www.sublimetext.com/download) is a standard text editor that adds lots of useful features and functionality. One of the most important features it provides is flexible syntax highlighting. Syntax highlighting allows us to place code blocks into a file, and those code blocks will be highlighted according to the programming language's specific syntax rules. However, this often comes with limitations. Highlighting two languages is not possible with one file. In an engagement with a single code type, this is not a problem, but for others, we may prefer to use different options. Additionally, it's not currently possible to inline screenshots at the time of writing.

Another tool we can consider is [_CherryTree_](https://github.com/giuspen/cherrytree). This tool comes as standard in Kali. It contains many of the features that are necessary for note-taking. It uses an SQLite database to store the notes we take, and these can be exported as HTML, PDF, plain text, or as a CherryTree document. CherryTree comes with a lot of built-in formatting, and provides a tree structure to store documents, which it calls "nodes" and "subnodes".

Below is an example of CherryTree being used to store penetration testing notes using a simple tree structure.

![Figure 3: CherryTree](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/9fdaf471923933513da2f372a7bcd371-cherrytree.png)

Figure 3: CherryTree

The final tool we'll consider is the [_Obsidian_](https://obsidian.md/) markdown editor, which contains all the features that we need for note-taking. We can install Obsidian as a s[nap application](https://snapcraft.io/) or in its [Flatpak](https://flatpak.org/) application form. It also comes as an [AppImage](https://appimage.org/), meaning that all we need to do is copy it into our system, mark it as executable, and run it.

```
kali@kali:~$ wget https://github.com/obsidianmd/obsidian-releases/releases/download/v0.14.2/Obsidian-0.14.2.AppImage
....
2022-03-31 15:38:53 (1.28 MB/s) - 'Obsidian-0.14.2.AppImage' saved [113102744/113102744]
kali@kali:~$ chmod +x Obsidian-0.14.2.AppImage
kali@kali:~$ ./Obsidian-0.14.2.AppImage
```

> Listing 2 - Getting and Running Obsidian

When we execute the AppImage, we get a welcome screen, which enables us to open an Obsidian vault or create a new one.

![Figure 4: Obsidian Welcome Screen](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/11f281591fedf5557b3fbc879b313393-obsidian1.png)

Figure 4: Obsidian Welcome Screen

Obsidian stores information in a _Vault_, which is a folder on our system. We can create both markdown files and folders within the Vault. Obsidian's features include a live preview of markdown text, in-line image placement, code blocks, and a multitude of add-ons such as a community-built CSS extension.

An example of directly entering notes in markdown is shown below:

![Figure 5: Taking Notes in Obsidian](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/02ac6e9a81c736c20c086438719ad31f-obsidian2.png)

Figure 5: Taking Notes in Obsidian

Then, it can be previewed live by Obsidian.

![Figure 6: Live Preview of Markdown](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/bb8e145610cfd717ccaadbe0ae2444f1-obsidian3.png)

Figure 6: Live Preview of Markdown

An Obsidian vault can be relocated to another computer and opened from the Welcome menu. Markdown files can simply be dropped into the Vault folders, which will automatically be recognized by Obsidian.

The use of markdown means that we can provide syntax and formatting that is easily copied to most report generation tools, and a PDF can be generated straight from Obsidian itself.

Tool selection is a personal and situational preference. Some tools are better in certain scenarios than others, but there isn't a perfect tool. It is recommended to take time and try out the tools we've covered, read the documentation, get familiar with them, and then decide which tool works for you. Some additional tools can be found referenced on [nil0x42's website](https://github.com/nil0x42/awesome-hacker-note-taking).

## 5.1.5. Taking Screenshots

Screenshots are an important part of note-taking and technical reporting. A good screenshot can explain the issue being discussed briefly and in more detail than a textual description. Screenshots are particularly useful to help present a technically complex or detail-heavy section of a report. As the saying goes, a picture is worth 1000 words. Conversely, a bad screenshot can obfuscate and draw attention away from what the issue is.

Screenshots are an important way to communicate the visual impact of a finding, and can be far more effective than mere text. For example, it's more effective to show a screenshot of an alert box popping up from an XSS payload than to describe it in words. However, it's more difficult to use a screenshot to describe exactly what's happening when we use something like a buffer overflow payload. Just like we want to use the right tool to perform certain attacks, so we also want to use the right tool to show certain results (such as text vs images).

We can use screenshots to supplement our note-taking or to include them in our report to illustrate the steps we took, which will help another tester reproduce the issues. However, we need to be conscious of the audience. While a penetration tester may consider an alert window to demonstrate XSS as perfectly self-explanatory, developers unfamiliar with the vulnerability may not understand its true cause or impact. It's good practice to always support a screenshot with text.

Screenshots have a specific goal, which is to convey information that would take several sentences to describe or to make an impact. The screenshot should contain exactly enough information to justify not using text, but there shouldn't be too much information to make the screenshot confusing.

To return to the example given above in the notes section, we have found reflected XSS in the username field of the application login. We will properly explain the effects of XSS in the actual report. However, the impact of XSS is far easier to show rather than explain without a visual reference as a base. We must include evidence of arbitrary JavaScript execution, as well as visual components of the site (i.e. the URL in the browser window). If necessary, secondary, or lead-up steps can be captured as well.

A well-constructed screenshot is easy to parse visually. Readers should be able to intuitively understand the picture and its caption without any questions. If there is a greater need for surrounding context, that can be added in a paragraph above or below the image, but the image itself should be understood.

Once again, using the example of XSS in our login form, we will include the following components in the screenshot, resizing the window if necessary. Ideally, we would include the URL as well as some company-specific branding and logos on the form. This lets them know the exact webpage and ties the vulnerability to their corporate image.

The actual pop-up executed in the proof-of-concept is necessary as well, substituted for any more advanced payload as the proof of concept is slowly taken further. Finally, we want to ensure that it is all legible. A screenshot that needs to be zoomed in to be properly viewed disrupts the reader's flow. A good screenshot is immediately legible, as shown below.

![Figure 7: Good Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/084ca8e2153f29b8b50b66252f68234c-image1.png)

Figure 7: Good Screenshot

There are several pitfalls we should avoid when using screenshots. We have already discussed making sure the screenshots are legible. We must also ensure there isn't more than one concept illustrated in each screenshot. A screenshot that contains two pieces of pertinent information does not lend itself to being easily understood at a glance. We must also ensure the impact is framed properly in the screenshot. Having the target of the screenshot off-center at the side obfuscates the intent as well. Finally, the caption for the screenshot shouldn't be overly long.

![Figure 8: Bad Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/7ad83ef7c5a28c0c2d9bc318dd1b7dc6-image3.png)

Figure 8: Bad Screenshot

The screenshot above covers the important information with an irrelevant piece of information, which prevents the full impact of the screenshot from being understood by the reader.

To recap, a good screenshot has the following characteristics:

-   is legible
-   contains some visual indication that it applies to the client
-   contains the material that is being described
-   supports the description of the material
-   properly frames the material being described

On the other hand, a bad screenshot is one that:

-   is illegible
-   is generic rather than client-specific
-   contains obfuscated or irrelevant information
-   is improperly framed

Under the screenshot, we include a caption. A caption is not meant to provide additional context for the picture. A caption is there to describe the picture in a few words. Any additional context that is necessary can be provided in a separate paragraph. In most cases, eight to ten words is an appropriate maximum for a caption.

## 5.1.6. Tools to Take Screenshots

We can take screenshots using native operating system capabilities. Windows, Linux, and macOS all provide tools to take screenshots. We can also use special-purpose tools.

For Windows, the PrintScreen key allows us to take a copy of the full screen, and _Alt/PrtSc_ takes a screenshot of the currently active window. This can then be pasted into a Paint, Word, or PowerPoint document and manipulated as required. We'll often want to crop the image to remove any unwanted material, and we can do that in these applications.

We can also invoke the Windows [_Snipping Tool_](https://en.wikipedia.org/wiki/Snipping_Tool) by pressing the Windows key together with B+s.

![Figure 9: Snipping Tool](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/eeb807bbbdb74da2aa7c49bb2ec38baf-image5.png)

Figure 9: Snipping Tool

The Snipping tool allows us to highlight and take a screenshot of any area of the screen we choose.

MacOS provides the capability to take a screenshot using the keyboard Shift/Command combination with the numeric keys 3, 4, or 5 key. To select and save the entire screen, we can use F+B+3. To highlight and select a specific area on the screen, we can simply use F+B+4 or F+B+5.

We can take a screenshot in Linux using the PrintScreen key. This will capture and save the entire screen to the user's **Images/ directory**. B+PrintScreen will allow for area highlighting and selection. In Kali Linux, we can also use the _Screenshot_ tool which is installed by default and comes with many options such as choosing the active window, selecting a region, adding a delay before taking the actual screenshot, etc.

[_Flameshot_](https://github.com/flameshot-org/flameshot) is an OS-agnostic, open-source, feature-rich screen-capturing tool. It comes with both a command-line and GUI interface and has integrated drawing tools to add highlights, pixelation, text, and other modifications to the captured image.

#### Labs

1.  A penetration tester and their client should absolutely agree on what before the engagement starts?

Answer

# 5\. Report Writing for Penetration Testers

We will cover the following Learning Units in this Learning Module:

-   Understanding Note-taking
-   Writing Effective Technical Penetration Testing Reports

This Module is designed to help Penetration Testers understand how to deliver effective reports to their clients.

## 5.1. Understanding Note-Taking

In this Learning Unit we will cover the following Learning Objectives:

-   Review the deliverables for penetration testing engagements
-   Understand the importance of note portability
-   Identify the general structure of pentesting documentation
-   Choose the right note-taking tool
-   Understand the importance of taking screenshots
-   Use tools to take screenshots

## 5.1.1. Penetration Testing Deliverables

A penetration test or [red team exercise](https://www.aon.com/cyber-solutions/thinking/penetration-testing-or-red-teaming/) is difficult to script in advance. This is because the tester cannot consistently anticipate exactly what kind of machines or networks the client will want to be tested.

Even though the outcome of our assessment is often unpredictable, it is often recommended to define a detailed _scope_ during the preliminary meetings with the customer. This process is especially very helpful when prioritizing business critical targets within large networks.

While the general execution plan for a penetration test will often follow a particular model, most pentests tend to follow the maxim ["no plan survives first contact with the enemy"](https://quoteinvestigator.com/2021/05/04/no-plan). This means that any specific activities we might expect to perform during the engagement might not actually happen, since the reality of the testing environment is almost certainly different than our initial ideas and hypotheses about it. It's therefore difficult to report on penetration tests using prepopulated forms. This is especially the case when the testing is carried out with little prior discussion with the client, for example, if the client is looking to surprise their defending teams in some manner.

As such, instead of preparing a report in advance, the penetration test is executed, and notes are taken as it proceeds to ensure that there is a detailed record of what was done. This makes sure that:

-   the penetration test can be repeated if it becomes necessary to demonstrate that an issue is real.
-   the penetration test can be repeated after remediation to confirm that an issue has been fixed.
-   if there's a system failure during the period of the penetration test, the client and tester can determine if the testing was the cause of the failure.

During a penetration test, some activities may not be permitted. We have to be very clear about the [_Rules of Engagement_](https://www.microsoft.com/en-us/msrc/pentest-rules-of-engagement) (RoE) under which the testing is done. When conducting red team testing, a person will often be assigned the role of "referee" to ensure that the rules of engagement are observed. There may be constraints placed on testing such as not carrying out denial of service attacks, or not engaging in social engineering. Furthermore, the testing work may be in response to the client's regulatory compliance requirements and may need to follow a specific methodology such as the [OWASP Penetration Testing Execution Standard](https://owasp.org/www-project-web-security-testing-guide/latest/3-The_OWASP_Testing_Framework/1-Penetration_Testing_Methodologies). Any such constraints need to be very clear from the outset.

## 5.1.2. Note Portability

Portability of penetration testing notes means being able to pass those notes on to others. Writing notes that are concise and coherent is an integral part of successful note-taking and enables the notes to be used not only by ourselves but also by others. Additionally, concise notes can be quickly adapted for technical reporting.

The need for portability is particularly emphasized when a penetration tester must leave an engagement because of sickness, illness, or other issues. Having a shared understanding of how notes should be taken is especially important for large penetration testing teams, where individuals need to be able to understand the details of other team members' engagements at will.

## 5.1.3. The General Structure of Penetration Testing Notes

We need to take a structured approach to note-taking that is both concise and precise. There are an uncountable number of ways in which we might organize our notes, and it would be futile to attempt to provide a one-size-fits all set of recommendations. Nevertheless, here are some principles that often useful to consider:

-   Rather than taking a few general notes assuming that we'll remember how to perform certain actions next time, we should record exactly what we did.
-   This means that every command that we type, every line of code that we modify, and even anywhere we click in the GUI should be recorded so that we can reproduce our actions.
-   Even if we've taken a lot of notes, if looking at them later doesn't help us remember exactly what happened during the assessment, then they won't be particularly useful to us.
-   The notes need to be structured and sufficiently detailed to remove any ambiguity.
-   To write a convincing and substantiated technical report later, we need to provide sufficient technical details within our notes.
-   If the notes are not written coherently, it will be difficult for someone else to repeat the test and get the same results.

The structure we recommend here for note-taking is sufficiently abstract to allow for personal preferences. As a general rule, we would like the notes to remind us of what occurred and allow us to replicate the issues we identify. A note-taking structure that starts broad and drills down into each section is an easy and expandable method of taking notes. The top-down approach guides us to start with the broadest activity, and then narrow down our focus and expand the level of detail until we have everything, we need to replicate exactly what happened.

Let's now look at an example of the notes we might take for a web vulnerability we discovered:

-   **Application Name**: This is important in a multi-application test, and a good habit to get into. The application names also lend itself to building a natural folder and file structure quite nicely.
    
-   **URL**: This is the exact URL that would be used to locate the vulnerability that we've detected.
    
-   **Request Type**: This represents both the type of request (i.e.: GET, POST, OPTIONS, etc.) that was made, as well as any manual changes we made to it. For example, we might intercept a POST request message and change the username or password before forwarding it on.
    
-   **Issue Detail**: This is the overview of the vulnerability that will be triggered by our actions. For example, we may point to a CVE describing the vulnerability if one exists, and/or explain the impact we observe. We may categorize the impact as denial of service, remote code execution, privilege escalation, and so on.
    
-   **Proof of Concept Payload**: This is a string or code block that will trigger the vulnerability. This is the most important part of the note, as it is what will drive the issue home and allow it to be replicated. It should list all of the necessary preconditions and provide the exact code or commands that would need to be used to trigger the vulnerability again.
    

Let's get more specific and review an example of testing for a _Cross-Site Scripting_ (XSS) vulnerability. The target we tested has a web page aptly named **XSSBlog.html**. When we navigate to it, we can enter a blog entry.

![Figure 1: XSS Testing](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/89c0b15a538a12feb35cdbecff45908b-xss1.png)

Figure 1: XSS Testing

When we read back the blog entry, we get the following alert:

![Figure 2: XSS Testing Issue](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/e113a6b758f58011df96c74634acfe7a-xss2.png)

Figure 2: XSS Testing Issue

While making these requests, we keep a record of our actions, as shown below.

```
Testing for Cross-Site Scripting 

Testing Target: 192.168.1.52 
Application:    XSSBlog
Date Started:   31 March 2022

1.  Navigated to the application
    http://192.168.1.52/XSSBlog.html
    Result: Blog page displayed as expected
    
2.  Entered our standard XSS test data: 
    You will rejoice to hear that no disaster has accompanied the
    commencement of an enterprise which you have regarded with such
    evil forebodings.<script>alert("Your computer is infected!");</script> 
    I arrived here yesterday, and my first task is to assure my dear
    sister of my welfare and increasing confidence in the success of
    my undertaking. 

3.  Clicked Submit to post the blog entry.
    Result: Blog entry appeared to save correctly.

4.  Navigated to read the blog post
    http://192.168.1.52/XSSRead.php
    Result: The blog started to display and then the expected alert popped up.

5.  Test indicated the site is vulnerable to XSS.

PoC payload: <script>alert(‘Your computer is infected!')</script>
```

> Listing 1 - Example of a Testing Note.

We now have a simple, fast, and expandable way to take coherent and comprehensive notes that another tester can follow. It's worth repeating that the notes are not themselves the report we will deliver to the client, but they will be invaluable when we attempt to put our report together later.

## 5.1.4. Choosing the Right Note-Taking Tool

There are an enormous number of both free and paid note-taking tools available today. To decide on the right tool for a particular engagement, it is important to understand some requirements. In many cases we want to keep all information local to the computer rather than uploading it anywhere else, so certain tools are precluded from being used. By the same token, if an engagement is source-code heavy then a tool that does not allow for code blocks to be inserted is not going to be appropriate.

While a comprehensive list of desirable properties to keep in mind is nearly impossible to enumerate, some of the more important items to remember are:

-   **Screenshots**: If a lot of screenshots are necessary, consider a tool that allows for inline screenshot insertion.
    
-   **Code blocks**: Code blocks need formatting to be properly and quickly understood.
    
-   **Portability**: Something that can be used cross-OS, or easily transferred to another place should be high on the list of priorities.
    
-   **Directory Structure**: In an engagement with multiple domains or applications, keeping a coherent structure is necessary. While manually setting up a structure is allowed, a tool that can do this automatically makes things easier.
    

Now that we have a good baseline of our requirements, let's consider the use of some note-taking tools.

[_Sublime_](https://www.sublimetext.com/download) is a standard text editor that adds lots of useful features and functionality. One of the most important features it provides is flexible syntax highlighting. Syntax highlighting allows us to place code blocks into a file, and those code blocks will be highlighted according to the programming language's specific syntax rules. However, this often comes with limitations. Highlighting two languages is not possible with one file. In an engagement with a single code type, this is not a problem, but for others, we may prefer to use different options. Additionally, it's not currently possible to inline screenshots at the time of writing.

Another tool we can consider is [_CherryTree_](https://github.com/giuspen/cherrytree). This tool comes as standard in Kali. It contains many of the features that are necessary for note-taking. It uses an SQLite database to store the notes we take, and these can be exported as HTML, PDF, plain text, or as a CherryTree document. CherryTree comes with a lot of built-in formatting, and provides a tree structure to store documents, which it calls "nodes" and "subnodes".

Below is an example of CherryTree being used to store penetration testing notes using a simple tree structure.

![Figure 3: CherryTree](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/9fdaf471923933513da2f372a7bcd371-cherrytree.png)

Figure 3: CherryTree

The final tool we'll consider is the [_Obsidian_](https://obsidian.md/) markdown editor, which contains all the features that we need for note-taking. We can install Obsidian as a s[nap application](https://snapcraft.io/) or in its [Flatpak](https://flatpak.org/) application form. It also comes as an [AppImage](https://appimage.org/), meaning that all we need to do is copy it into our system, mark it as executable, and run it.

```
kali@kali:~$ wget https://github.com/obsidianmd/obsidian-releases/releases/download/v0.14.2/Obsidian-0.14.2.AppImage
....
2022-03-31 15:38:53 (1.28 MB/s) - 'Obsidian-0.14.2.AppImage' saved [113102744/113102744]
kali@kali:~$ chmod +x Obsidian-0.14.2.AppImage
kali@kali:~$ ./Obsidian-0.14.2.AppImage
```

> Listing 2 - Getting and Running Obsidian

When we execute the AppImage, we get a welcome screen, which enables us to open an Obsidian vault or create a new one.

![Figure 4: Obsidian Welcome Screen](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/11f281591fedf5557b3fbc879b313393-obsidian1.png)

Figure 4: Obsidian Welcome Screen

Obsidian stores information in a _Vault_, which is a folder on our system. We can create both markdown files and folders within the Vault. Obsidian's features include a live preview of markdown text, in-line image placement, code blocks, and a multitude of add-ons such as a community-built CSS extension.

An example of directly entering notes in markdown is shown below:

![Figure 5: Taking Notes in Obsidian](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/02ac6e9a81c736c20c086438719ad31f-obsidian2.png)

Figure 5: Taking Notes in Obsidian

Then, it can be previewed live by Obsidian.

![Figure 6: Live Preview of Markdown](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/bb8e145610cfd717ccaadbe0ae2444f1-obsidian3.png)

Figure 6: Live Preview of Markdown

An Obsidian vault can be relocated to another computer and opened from the Welcome menu. Markdown files can simply be dropped into the Vault folders, which will automatically be recognized by Obsidian.

The use of markdown means that we can provide syntax and formatting that is easily copied to most report generation tools, and a PDF can be generated straight from Obsidian itself.

Tool selection is a personal and situational preference. Some tools are better in certain scenarios than others, but there isn't a perfect tool. It is recommended to take time and try out the tools we've covered, read the documentation, get familiar with them, and then decide which tool works for you. Some additional tools can be found referenced on [nil0x42's website](https://github.com/nil0x42/awesome-hacker-note-taking).

## 5.1.5. Taking Screenshots

Screenshots are an important part of note-taking and technical reporting. A good screenshot can explain the issue being discussed briefly and in more detail than a textual description. Screenshots are particularly useful to help present a technically complex or detail-heavy section of a report. As the saying goes, a picture is worth 1000 words. Conversely, a bad screenshot can obfuscate and draw attention away from what the issue is.

Screenshots are an important way to communicate the visual impact of a finding, and can be far more effective than mere text. For example, it's more effective to show a screenshot of an alert box popping up from an XSS payload than to describe it in words. However, it's more difficult to use a screenshot to describe exactly what's happening when we use something like a buffer overflow payload. Just like we want to use the right tool to perform certain attacks, so we also want to use the right tool to show certain results (such as text vs images).

We can use screenshots to supplement our note-taking or to include them in our report to illustrate the steps we took, which will help another tester reproduce the issues. However, we need to be conscious of the audience. While a penetration tester may consider an alert window to demonstrate XSS as perfectly self-explanatory, developers unfamiliar with the vulnerability may not understand its true cause or impact. It's good practice to always support a screenshot with text.

Screenshots have a specific goal, which is to convey information that would take several sentences to describe or to make an impact. The screenshot should contain exactly enough information to justify not using text, but there shouldn't be too much information to make the screenshot confusing.

To return to the example given above in the notes section, we have found reflected XSS in the username field of the application login. We will properly explain the effects of XSS in the actual report. However, the impact of XSS is far easier to show rather than explain without a visual reference as a base. We must include evidence of arbitrary JavaScript execution, as well as visual components of the site (i.e. the URL in the browser window). If necessary, secondary, or lead-up steps can be captured as well.

A well-constructed screenshot is easy to parse visually. Readers should be able to intuitively understand the picture and its caption without any questions. If there is a greater need for surrounding context, that can be added in a paragraph above or below the image, but the image itself should be understood.

Once again, using the example of XSS in our login form, we will include the following components in the screenshot, resizing the window if necessary. Ideally, we would include the URL as well as some company-specific branding and logos on the form. This lets them know the exact webpage and ties the vulnerability to their corporate image.

The actual pop-up executed in the proof-of-concept is necessary as well, substituted for any more advanced payload as the proof of concept is slowly taken further. Finally, we want to ensure that it is all legible. A screenshot that needs to be zoomed in to be properly viewed disrupts the reader's flow. A good screenshot is immediately legible, as shown below.

![Figure 7: Good Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/084ca8e2153f29b8b50b66252f68234c-image1.png)

Figure 7: Good Screenshot

There are several pitfalls we should avoid when using screenshots. We have already discussed making sure the screenshots are legible. We must also ensure there isn't more than one concept illustrated in each screenshot. A screenshot that contains two pieces of pertinent information does not lend itself to being easily understood at a glance. We must also ensure the impact is framed properly in the screenshot. Having the target of the screenshot off-center at the side obfuscates the intent as well. Finally, the caption for the screenshot shouldn't be overly long.

![Figure 8: Bad Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/7ad83ef7c5a28c0c2d9bc318dd1b7dc6-image3.png)

Figure 8: Bad Screenshot

The screenshot above covers the important information with an irrelevant piece of information, which prevents the full impact of the screenshot from being understood by the reader.

To recap, a good screenshot has the following characteristics:

-   is legible
-   contains some visual indication that it applies to the client
-   contains the material that is being described
-   supports the description of the material
-   properly frames the material being described

On the other hand, a bad screenshot is one that:

-   is illegible
-   is generic rather than client-specific
-   contains obfuscated or irrelevant information
-   is improperly framed

Under the screenshot, we include a caption. A caption is not meant to provide additional context for the picture. A caption is there to describe the picture in a few words. Any additional context that is necessary can be provided in a separate paragraph. In most cases, eight to ten words is an appropriate maximum for a caption.

## 5.1.6. Tools to Take Screenshots

We can take screenshots using native operating system capabilities. Windows, Linux, and macOS all provide tools to take screenshots. We can also use special-purpose tools.

For Windows, the PrintScreen key allows us to take a copy of the full screen, and _Alt/PrtSc_ takes a screenshot of the currently active window. This can then be pasted into a Paint, Word, or PowerPoint document and manipulated as required. We'll often want to crop the image to remove any unwanted material, and we can do that in these applications.

We can also invoke the Windows [_Snipping Tool_](https://en.wikipedia.org/wiki/Snipping_Tool) by pressing the Windows key together with B+s.

![Figure 9: Snipping Tool](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/eeb807bbbdb74da2aa7c49bb2ec38baf-image5.png)

Figure 9: Snipping Tool

The Snipping tool allows us to highlight and take a screenshot of any area of the screen we choose.

MacOS provides the capability to take a screenshot using the keyboard Shift/Command combination with the numeric keys 3, 4, or 5 key. To select and save the entire screen, we can use F+B+3. To highlight and select a specific area on the screen, we can simply use F+B+4 or F+B+5.

We can take a screenshot in Linux using the PrintScreen key. This will capture and save the entire screen to the user's **Images/ directory**. B+PrintScreen will allow for area highlighting and selection. In Kali Linux, we can also use the _Screenshot_ tool which is installed by default and comes with many options such as choosing the active window, selecting a region, adding a delay before taking the actual screenshot, etc.

[_Flameshot_](https://github.com/flameshot-org/flameshot) is an OS-agnostic, open-source, feature-rich screen-capturing tool. It comes with both a command-line and GUI interface and has integrated drawing tools to add highlights, pixelation, text, and other modifications to the captured image.

#### Labs

1.  A penetration tester and their client should absolutely agree on what before the engagement starts?

Answer

# 5\. Report Writing for Penetration Testers

We will cover the following Learning Units in this Learning Module:

-   Understanding Note-taking
-   Writing Effective Technical Penetration Testing Reports

This Module is designed to help Penetration Testers understand how to deliver effective reports to their clients.

## 5.1. Understanding Note-Taking

In this Learning Unit we will cover the following Learning Objectives:

-   Review the deliverables for penetration testing engagements
-   Understand the importance of note portability
-   Identify the general structure of pentesting documentation
-   Choose the right note-taking tool
-   Understand the importance of taking screenshots
-   Use tools to take screenshots

## 5.1.1. Penetration Testing Deliverables

A penetration test or [red team exercise](https://www.aon.com/cyber-solutions/thinking/penetration-testing-or-red-teaming/) is difficult to script in advance. This is because the tester cannot consistently anticipate exactly what kind of machines or networks the client will want to be tested.

Even though the outcome of our assessment is often unpredictable, it is often recommended to define a detailed _scope_ during the preliminary meetings with the customer. This process is especially very helpful when prioritizing business critical targets within large networks.

While the general execution plan for a penetration test will often follow a particular model, most pentests tend to follow the maxim ["no plan survives first contact with the enemy"](https://quoteinvestigator.com/2021/05/04/no-plan). This means that any specific activities we might expect to perform during the engagement might not actually happen, since the reality of the testing environment is almost certainly different than our initial ideas and hypotheses about it. It's therefore difficult to report on penetration tests using prepopulated forms. This is especially the case when the testing is carried out with little prior discussion with the client, for example, if the client is looking to surprise their defending teams in some manner.

As such, instead of preparing a report in advance, the penetration test is executed, and notes are taken as it proceeds to ensure that there is a detailed record of what was done. This makes sure that:

-   the penetration test can be repeated if it becomes necessary to demonstrate that an issue is real.
-   the penetration test can be repeated after remediation to confirm that an issue has been fixed.
-   if there's a system failure during the period of the penetration test, the client and tester can determine if the testing was the cause of the failure.

During a penetration test, some activities may not be permitted. We have to be very clear about the [_Rules of Engagement_](https://www.microsoft.com/en-us/msrc/pentest-rules-of-engagement) (RoE) under which the testing is done. When conducting red team testing, a person will often be assigned the role of "referee" to ensure that the rules of engagement are observed. There may be constraints placed on testing such as not carrying out denial of service attacks, or not engaging in social engineering. Furthermore, the testing work may be in response to the client's regulatory compliance requirements and may need to follow a specific methodology such as the [OWASP Penetration Testing Execution Standard](https://owasp.org/www-project-web-security-testing-guide/latest/3-The_OWASP_Testing_Framework/1-Penetration_Testing_Methodologies). Any such constraints need to be very clear from the outset.

## 5.1.2. Note Portability

Portability of penetration testing notes means being able to pass those notes on to others. Writing notes that are concise and coherent is an integral part of successful note-taking and enables the notes to be used not only by ourselves but also by others. Additionally, concise notes can be quickly adapted for technical reporting.

The need for portability is particularly emphasized when a penetration tester must leave an engagement because of sickness, illness, or other issues. Having a shared understanding of how notes should be taken is especially important for large penetration testing teams, where individuals need to be able to understand the details of other team members' engagements at will.

## 5.1.3. The General Structure of Penetration Testing Notes

We need to take a structured approach to note-taking that is both concise and precise. There are an uncountable number of ways in which we might organize our notes, and it would be futile to attempt to provide a one-size-fits all set of recommendations. Nevertheless, here are some principles that often useful to consider:

-   Rather than taking a few general notes assuming that we'll remember how to perform certain actions next time, we should record exactly what we did.
-   This means that every command that we type, every line of code that we modify, and even anywhere we click in the GUI should be recorded so that we can reproduce our actions.
-   Even if we've taken a lot of notes, if looking at them later doesn't help us remember exactly what happened during the assessment, then they won't be particularly useful to us.
-   The notes need to be structured and sufficiently detailed to remove any ambiguity.
-   To write a convincing and substantiated technical report later, we need to provide sufficient technical details within our notes.
-   If the notes are not written coherently, it will be difficult for someone else to repeat the test and get the same results.

The structure we recommend here for note-taking is sufficiently abstract to allow for personal preferences. As a general rule, we would like the notes to remind us of what occurred and allow us to replicate the issues we identify. A note-taking structure that starts broad and drills down into each section is an easy and expandable method of taking notes. The top-down approach guides us to start with the broadest activity, and then narrow down our focus and expand the level of detail until we have everything, we need to replicate exactly what happened.

Let's now look at an example of the notes we might take for a web vulnerability we discovered:

-   **Application Name**: This is important in a multi-application test, and a good habit to get into. The application names also lend itself to building a natural folder and file structure quite nicely.
    
-   **URL**: This is the exact URL that would be used to locate the vulnerability that we've detected.
    
-   **Request Type**: This represents both the type of request (i.e.: GET, POST, OPTIONS, etc.) that was made, as well as any manual changes we made to it. For example, we might intercept a POST request message and change the username or password before forwarding it on.
    
-   **Issue Detail**: This is the overview of the vulnerability that will be triggered by our actions. For example, we may point to a CVE describing the vulnerability if one exists, and/or explain the impact we observe. We may categorize the impact as denial of service, remote code execution, privilege escalation, and so on.
    
-   **Proof of Concept Payload**: This is a string or code block that will trigger the vulnerability. This is the most important part of the note, as it is what will drive the issue home and allow it to be replicated. It should list all of the necessary preconditions and provide the exact code or commands that would need to be used to trigger the vulnerability again.
    

Let's get more specific and review an example of testing for a _Cross-Site Scripting_ (XSS) vulnerability. The target we tested has a web page aptly named **XSSBlog.html**. When we navigate to it, we can enter a blog entry.

![Figure 1: XSS Testing](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/89c0b15a538a12feb35cdbecff45908b-xss1.png)

Figure 1: XSS Testing

When we read back the blog entry, we get the following alert:

![Figure 2: XSS Testing Issue](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/e113a6b758f58011df96c74634acfe7a-xss2.png)

Figure 2: XSS Testing Issue

While making these requests, we keep a record of our actions, as shown below.

```
Testing for Cross-Site Scripting 

Testing Target: 192.168.1.52 
Application:    XSSBlog
Date Started:   31 March 2022

1.  Navigated to the application
    http://192.168.1.52/XSSBlog.html
    Result: Blog page displayed as expected
    
2.  Entered our standard XSS test data: 
    You will rejoice to hear that no disaster has accompanied the
    commencement of an enterprise which you have regarded with such
    evil forebodings.<script>alert("Your computer is infected!");</script> 
    I arrived here yesterday, and my first task is to assure my dear
    sister of my welfare and increasing confidence in the success of
    my undertaking. 

3.  Clicked Submit to post the blog entry.
    Result: Blog entry appeared to save correctly.

4.  Navigated to read the blog post
    http://192.168.1.52/XSSRead.php
    Result: The blog started to display and then the expected alert popped up.

5.  Test indicated the site is vulnerable to XSS.

PoC payload: <script>alert(‘Your computer is infected!')</script>
```

> Listing 1 - Example of a Testing Note.

We now have a simple, fast, and expandable way to take coherent and comprehensive notes that another tester can follow. It's worth repeating that the notes are not themselves the report we will deliver to the client, but they will be invaluable when we attempt to put our report together later.

## 5.1.4. Choosing the Right Note-Taking Tool

There are an enormous number of both free and paid note-taking tools available today. To decide on the right tool for a particular engagement, it is important to understand some requirements. In many cases we want to keep all information local to the computer rather than uploading it anywhere else, so certain tools are precluded from being used. By the same token, if an engagement is source-code heavy then a tool that does not allow for code blocks to be inserted is not going to be appropriate.

While a comprehensive list of desirable properties to keep in mind is nearly impossible to enumerate, some of the more important items to remember are:

-   **Screenshots**: If a lot of screenshots are necessary, consider a tool that allows for inline screenshot insertion.
    
-   **Code blocks**: Code blocks need formatting to be properly and quickly understood.
    
-   **Portability**: Something that can be used cross-OS, or easily transferred to another place should be high on the list of priorities.
    
-   **Directory Structure**: In an engagement with multiple domains or applications, keeping a coherent structure is necessary. While manually setting up a structure is allowed, a tool that can do this automatically makes things easier.
    

Now that we have a good baseline of our requirements, let's consider the use of some note-taking tools.

[_Sublime_](https://www.sublimetext.com/download) is a standard text editor that adds lots of useful features and functionality. One of the most important features it provides is flexible syntax highlighting. Syntax highlighting allows us to place code blocks into a file, and those code blocks will be highlighted according to the programming language's specific syntax rules. However, this often comes with limitations. Highlighting two languages is not possible with one file. In an engagement with a single code type, this is not a problem, but for others, we may prefer to use different options. Additionally, it's not currently possible to inline screenshots at the time of writing.

Another tool we can consider is [_CherryTree_](https://github.com/giuspen/cherrytree). This tool comes as standard in Kali. It contains many of the features that are necessary for note-taking. It uses an SQLite database to store the notes we take, and these can be exported as HTML, PDF, plain text, or as a CherryTree document. CherryTree comes with a lot of built-in formatting, and provides a tree structure to store documents, which it calls "nodes" and "subnodes".

Below is an example of CherryTree being used to store penetration testing notes using a simple tree structure.

![Figure 3: CherryTree](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/9fdaf471923933513da2f372a7bcd371-cherrytree.png)

Figure 3: CherryTree

The final tool we'll consider is the [_Obsidian_](https://obsidian.md/) markdown editor, which contains all the features that we need for note-taking. We can install Obsidian as a s[nap application](https://snapcraft.io/) or in its [Flatpak](https://flatpak.org/) application form. It also comes as an [AppImage](https://appimage.org/), meaning that all we need to do is copy it into our system, mark it as executable, and run it.

```
kali@kali:~$ wget https://github.com/obsidianmd/obsidian-releases/releases/download/v0.14.2/Obsidian-0.14.2.AppImage
....
2022-03-31 15:38:53 (1.28 MB/s) - 'Obsidian-0.14.2.AppImage' saved [113102744/113102744]
kali@kali:~$ chmod +x Obsidian-0.14.2.AppImage
kali@kali:~$ ./Obsidian-0.14.2.AppImage
```

> Listing 2 - Getting and Running Obsidian

When we execute the AppImage, we get a welcome screen, which enables us to open an Obsidian vault or create a new one.

![Figure 4: Obsidian Welcome Screen](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/11f281591fedf5557b3fbc879b313393-obsidian1.png)

Figure 4: Obsidian Welcome Screen

Obsidian stores information in a _Vault_, which is a folder on our system. We can create both markdown files and folders within the Vault. Obsidian's features include a live preview of markdown text, in-line image placement, code blocks, and a multitude of add-ons such as a community-built CSS extension.

An example of directly entering notes in markdown is shown below:

![Figure 5: Taking Notes in Obsidian](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/02ac6e9a81c736c20c086438719ad31f-obsidian2.png)

Figure 5: Taking Notes in Obsidian

Then, it can be previewed live by Obsidian.

![Figure 6: Live Preview of Markdown](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/bb8e145610cfd717ccaadbe0ae2444f1-obsidian3.png)

Figure 6: Live Preview of Markdown

An Obsidian vault can be relocated to another computer and opened from the Welcome menu. Markdown files can simply be dropped into the Vault folders, which will automatically be recognized by Obsidian.

The use of markdown means that we can provide syntax and formatting that is easily copied to most report generation tools, and a PDF can be generated straight from Obsidian itself.

Tool selection is a personal and situational preference. Some tools are better in certain scenarios than others, but there isn't a perfect tool. It is recommended to take time and try out the tools we've covered, read the documentation, get familiar with them, and then decide which tool works for you. Some additional tools can be found referenced on [nil0x42's website](https://github.com/nil0x42/awesome-hacker-note-taking).

## 5.1.5. Taking Screenshots

Screenshots are an important part of note-taking and technical reporting. A good screenshot can explain the issue being discussed briefly and in more detail than a textual description. Screenshots are particularly useful to help present a technically complex or detail-heavy section of a report. As the saying goes, a picture is worth 1000 words. Conversely, a bad screenshot can obfuscate and draw attention away from what the issue is.

Screenshots are an important way to communicate the visual impact of a finding, and can be far more effective than mere text. For example, it's more effective to show a screenshot of an alert box popping up from an XSS payload than to describe it in words. However, it's more difficult to use a screenshot to describe exactly what's happening when we use something like a buffer overflow payload. Just like we want to use the right tool to perform certain attacks, so we also want to use the right tool to show certain results (such as text vs images).

We can use screenshots to supplement our note-taking or to include them in our report to illustrate the steps we took, which will help another tester reproduce the issues. However, we need to be conscious of the audience. While a penetration tester may consider an alert window to demonstrate XSS as perfectly self-explanatory, developers unfamiliar with the vulnerability may not understand its true cause or impact. It's good practice to always support a screenshot with text.

Screenshots have a specific goal, which is to convey information that would take several sentences to describe or to make an impact. The screenshot should contain exactly enough information to justify not using text, but there shouldn't be too much information to make the screenshot confusing.

To return to the example given above in the notes section, we have found reflected XSS in the username field of the application login. We will properly explain the effects of XSS in the actual report. However, the impact of XSS is far easier to show rather than explain without a visual reference as a base. We must include evidence of arbitrary JavaScript execution, as well as visual components of the site (i.e. the URL in the browser window). If necessary, secondary, or lead-up steps can be captured as well.

A well-constructed screenshot is easy to parse visually. Readers should be able to intuitively understand the picture and its caption without any questions. If there is a greater need for surrounding context, that can be added in a paragraph above or below the image, but the image itself should be understood.

Once again, using the example of XSS in our login form, we will include the following components in the screenshot, resizing the window if necessary. Ideally, we would include the URL as well as some company-specific branding and logos on the form. This lets them know the exact webpage and ties the vulnerability to their corporate image.

The actual pop-up executed in the proof-of-concept is necessary as well, substituted for any more advanced payload as the proof of concept is slowly taken further. Finally, we want to ensure that it is all legible. A screenshot that needs to be zoomed in to be properly viewed disrupts the reader's flow. A good screenshot is immediately legible, as shown below.

![Figure 7: Good Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/084ca8e2153f29b8b50b66252f68234c-image1.png)

Figure 7: Good Screenshot

There are several pitfalls we should avoid when using screenshots. We have already discussed making sure the screenshots are legible. We must also ensure there isn't more than one concept illustrated in each screenshot. A screenshot that contains two pieces of pertinent information does not lend itself to being easily understood at a glance. We must also ensure the impact is framed properly in the screenshot. Having the target of the screenshot off-center at the side obfuscates the intent as well. Finally, the caption for the screenshot shouldn't be overly long.

![Figure 8: Bad Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/7ad83ef7c5a28c0c2d9bc318dd1b7dc6-image3.png)

Figure 8: Bad Screenshot

The screenshot above covers the important information with an irrelevant piece of information, which prevents the full impact of the screenshot from being understood by the reader.

To recap, a good screenshot has the following characteristics:

-   is legible
-   contains some visual indication that it applies to the client
-   contains the material that is being described
-   supports the description of the material
-   properly frames the material being described

On the other hand, a bad screenshot is one that:

-   is illegible
-   is generic rather than client-specific
-   contains obfuscated or irrelevant information
-   is improperly framed

Under the screenshot, we include a caption. A caption is not meant to provide additional context for the picture. A caption is there to describe the picture in a few words. Any additional context that is necessary can be provided in a separate paragraph. In most cases, eight to ten words is an appropriate maximum for a caption.

## 5.1.6. Tools to Take Screenshots

We can take screenshots using native operating system capabilities. Windows, Linux, and macOS all provide tools to take screenshots. We can also use special-purpose tools.

For Windows, the PrintScreen key allows us to take a copy of the full screen, and _Alt/PrtSc_ takes a screenshot of the currently active window. This can then be pasted into a Paint, Word, or PowerPoint document and manipulated as required. We'll often want to crop the image to remove any unwanted material, and we can do that in these applications.

We can also invoke the Windows [_Snipping Tool_](https://en.wikipedia.org/wiki/Snipping_Tool) by pressing the Windows key together with B+s.

![Figure 9: Snipping Tool](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/eeb807bbbdb74da2aa7c49bb2ec38baf-image5.png)

Figure 9: Snipping Tool

The Snipping tool allows us to highlight and take a screenshot of any area of the screen we choose.

MacOS provides the capability to take a screenshot using the keyboard Shift/Command combination with the numeric keys 3, 4, or 5 key. To select and save the entire screen, we can use F+B+3. To highlight and select a specific area on the screen, we can simply use F+B+4 or F+B+5.

We can take a screenshot in Linux using the PrintScreen key. This will capture and save the entire screen to the user's **Images/ directory**. B+PrintScreen will allow for area highlighting and selection. In Kali Linux, we can also use the _Screenshot_ tool which is installed by default and comes with many options such as choosing the active window, selecting a region, adding a delay before taking the actual screenshot, etc.

[_Flameshot_](https://github.com/flameshot-org/flameshot) is an OS-agnostic, open-source, feature-rich screen-capturing tool. It comes with both a command-line and GUI interface and has integrated drawing tools to add highlights, pixelation, text, and other modifications to the captured image.

#### Labs

1.  A penetration tester and their client should absolutely agree on what before the engagement starts?

Answer

# 5\. Report Writing for Penetration Testers

We will cover the following Learning Units in this Learning Module:

-   Understanding Note-taking
-   Writing Effective Technical Penetration Testing Reports

This Module is designed to help Penetration Testers understand how to deliver effective reports to their clients.

## 5.1. Understanding Note-Taking

In this Learning Unit we will cover the following Learning Objectives:

-   Review the deliverables for penetration testing engagements
-   Understand the importance of note portability
-   Identify the general structure of pentesting documentation
-   Choose the right note-taking tool
-   Understand the importance of taking screenshots
-   Use tools to take screenshots

## 5.1.1. Penetration Testing Deliverables

A penetration test or [red team exercise](https://www.aon.com/cyber-solutions/thinking/penetration-testing-or-red-teaming/) is difficult to script in advance. This is because the tester cannot consistently anticipate exactly what kind of machines or networks the client will want to be tested.

Even though the outcome of our assessment is often unpredictable, it is often recommended to define a detailed _scope_ during the preliminary meetings with the customer. This process is especially very helpful when prioritizing business critical targets within large networks.

While the general execution plan for a penetration test will often follow a particular model, most pentests tend to follow the maxim ["no plan survives first contact with the enemy"](https://quoteinvestigator.com/2021/05/04/no-plan). This means that any specific activities we might expect to perform during the engagement might not actually happen, since the reality of the testing environment is almost certainly different than our initial ideas and hypotheses about it. It's therefore difficult to report on penetration tests using prepopulated forms. This is especially the case when the testing is carried out with little prior discussion with the client, for example, if the client is looking to surprise their defending teams in some manner.

As such, instead of preparing a report in advance, the penetration test is executed, and notes are taken as it proceeds to ensure that there is a detailed record of what was done. This makes sure that:

-   the penetration test can be repeated if it becomes necessary to demonstrate that an issue is real.
-   the penetration test can be repeated after remediation to confirm that an issue has been fixed.
-   if there's a system failure during the period of the penetration test, the client and tester can determine if the testing was the cause of the failure.

During a penetration test, some activities may not be permitted. We have to be very clear about the [_Rules of Engagement_](https://www.microsoft.com/en-us/msrc/pentest-rules-of-engagement) (RoE) under which the testing is done. When conducting red team testing, a person will often be assigned the role of "referee" to ensure that the rules of engagement are observed. There may be constraints placed on testing such as not carrying out denial of service attacks, or not engaging in social engineering. Furthermore, the testing work may be in response to the client's regulatory compliance requirements and may need to follow a specific methodology such as the [OWASP Penetration Testing Execution Standard](https://owasp.org/www-project-web-security-testing-guide/latest/3-The_OWASP_Testing_Framework/1-Penetration_Testing_Methodologies). Any such constraints need to be very clear from the outset.

## 5.1.2. Note Portability

Portability of penetration testing notes means being able to pass those notes on to others. Writing notes that are concise and coherent is an integral part of successful note-taking and enables the notes to be used not only by ourselves but also by others. Additionally, concise notes can be quickly adapted for technical reporting.

The need for portability is particularly emphasized when a penetration tester must leave an engagement because of sickness, illness, or other issues. Having a shared understanding of how notes should be taken is especially important for large penetration testing teams, where individuals need to be able to understand the details of other team members' engagements at will.

## 5.1.3. The General Structure of Penetration Testing Notes

We need to take a structured approach to note-taking that is both concise and precise. There are an uncountable number of ways in which we might organize our notes, and it would be futile to attempt to provide a one-size-fits all set of recommendations. Nevertheless, here are some principles that often useful to consider:

-   Rather than taking a few general notes assuming that we'll remember how to perform certain actions next time, we should record exactly what we did.
-   This means that every command that we type, every line of code that we modify, and even anywhere we click in the GUI should be recorded so that we can reproduce our actions.
-   Even if we've taken a lot of notes, if looking at them later doesn't help us remember exactly what happened during the assessment, then they won't be particularly useful to us.
-   The notes need to be structured and sufficiently detailed to remove any ambiguity.
-   To write a convincing and substantiated technical report later, we need to provide sufficient technical details within our notes.
-   If the notes are not written coherently, it will be difficult for someone else to repeat the test and get the same results.

The structure we recommend here for note-taking is sufficiently abstract to allow for personal preferences. As a general rule, we would like the notes to remind us of what occurred and allow us to replicate the issues we identify. A note-taking structure that starts broad and drills down into each section is an easy and expandable method of taking notes. The top-down approach guides us to start with the broadest activity, and then narrow down our focus and expand the level of detail until we have everything, we need to replicate exactly what happened.

Let's now look at an example of the notes we might take for a web vulnerability we discovered:

-   **Application Name**: This is important in a multi-application test, and a good habit to get into. The application names also lend itself to building a natural folder and file structure quite nicely.
    
-   **URL**: This is the exact URL that would be used to locate the vulnerability that we've detected.
    
-   **Request Type**: This represents both the type of request (i.e.: GET, POST, OPTIONS, etc.) that was made, as well as any manual changes we made to it. For example, we might intercept a POST request message and change the username or password before forwarding it on.
    
-   **Issue Detail**: This is the overview of the vulnerability that will be triggered by our actions. For example, we may point to a CVE describing the vulnerability if one exists, and/or explain the impact we observe. We may categorize the impact as denial of service, remote code execution, privilege escalation, and so on.
    
-   **Proof of Concept Payload**: This is a string or code block that will trigger the vulnerability. This is the most important part of the note, as it is what will drive the issue home and allow it to be replicated. It should list all of the necessary preconditions and provide the exact code or commands that would need to be used to trigger the vulnerability again.
    

Let's get more specific and review an example of testing for a _Cross-Site Scripting_ (XSS) vulnerability. The target we tested has a web page aptly named **XSSBlog.html**. When we navigate to it, we can enter a blog entry.

![Figure 1: XSS Testing](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/89c0b15a538a12feb35cdbecff45908b-xss1.png)

Figure 1: XSS Testing

When we read back the blog entry, we get the following alert:

![Figure 2: XSS Testing Issue](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/e113a6b758f58011df96c74634acfe7a-xss2.png)

Figure 2: XSS Testing Issue

While making these requests, we keep a record of our actions, as shown below.

```
Testing for Cross-Site Scripting 

Testing Target: 192.168.1.52 
Application:    XSSBlog
Date Started:   31 March 2022

1.  Navigated to the application
    http://192.168.1.52/XSSBlog.html
    Result: Blog page displayed as expected
    
2.  Entered our standard XSS test data: 
    You will rejoice to hear that no disaster has accompanied the
    commencement of an enterprise which you have regarded with such
    evil forebodings.<script>alert("Your computer is infected!");</script> 
    I arrived here yesterday, and my first task is to assure my dear
    sister of my welfare and increasing confidence in the success of
    my undertaking. 

3.  Clicked Submit to post the blog entry.
    Result: Blog entry appeared to save correctly.

4.  Navigated to read the blog post
    http://192.168.1.52/XSSRead.php
    Result: The blog started to display and then the expected alert popped up.

5.  Test indicated the site is vulnerable to XSS.

PoC payload: <script>alert(‘Your computer is infected!')</script>
```

> Listing 1 - Example of a Testing Note.

We now have a simple, fast, and expandable way to take coherent and comprehensive notes that another tester can follow. It's worth repeating that the notes are not themselves the report we will deliver to the client, but they will be invaluable when we attempt to put our report together later.

## 5.1.4. Choosing the Right Note-Taking Tool

There are an enormous number of both free and paid note-taking tools available today. To decide on the right tool for a particular engagement, it is important to understand some requirements. In many cases we want to keep all information local to the computer rather than uploading it anywhere else, so certain tools are precluded from being used. By the same token, if an engagement is source-code heavy then a tool that does not allow for code blocks to be inserted is not going to be appropriate.

While a comprehensive list of desirable properties to keep in mind is nearly impossible to enumerate, some of the more important items to remember are:

-   **Screenshots**: If a lot of screenshots are necessary, consider a tool that allows for inline screenshot insertion.
    
-   **Code blocks**: Code blocks need formatting to be properly and quickly understood.
    
-   **Portability**: Something that can be used cross-OS, or easily transferred to another place should be high on the list of priorities.
    
-   **Directory Structure**: In an engagement with multiple domains or applications, keeping a coherent structure is necessary. While manually setting up a structure is allowed, a tool that can do this automatically makes things easier.
    

Now that we have a good baseline of our requirements, let's consider the use of some note-taking tools.

[_Sublime_](https://www.sublimetext.com/download) is a standard text editor that adds lots of useful features and functionality. One of the most important features it provides is flexible syntax highlighting. Syntax highlighting allows us to place code blocks into a file, and those code blocks will be highlighted according to the programming language's specific syntax rules. However, this often comes with limitations. Highlighting two languages is not possible with one file. In an engagement with a single code type, this is not a problem, but for others, we may prefer to use different options. Additionally, it's not currently possible to inline screenshots at the time of writing.

Another tool we can consider is [_CherryTree_](https://github.com/giuspen/cherrytree). This tool comes as standard in Kali. It contains many of the features that are necessary for note-taking. It uses an SQLite database to store the notes we take, and these can be exported as HTML, PDF, plain text, or as a CherryTree document. CherryTree comes with a lot of built-in formatting, and provides a tree structure to store documents, which it calls "nodes" and "subnodes".

Below is an example of CherryTree being used to store penetration testing notes using a simple tree structure.

![Figure 3: CherryTree](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/9fdaf471923933513da2f372a7bcd371-cherrytree.png)

Figure 3: CherryTree

The final tool we'll consider is the [_Obsidian_](https://obsidian.md/) markdown editor, which contains all the features that we need for note-taking. We can install Obsidian as a s[nap application](https://snapcraft.io/) or in its [Flatpak](https://flatpak.org/) application form. It also comes as an [AppImage](https://appimage.org/), meaning that all we need to do is copy it into our system, mark it as executable, and run it.

```
kali@kali:~$ wget https://github.com/obsidianmd/obsidian-releases/releases/download/v0.14.2/Obsidian-0.14.2.AppImage
....
2022-03-31 15:38:53 (1.28 MB/s) - 'Obsidian-0.14.2.AppImage' saved [113102744/113102744]
kali@kali:~$ chmod +x Obsidian-0.14.2.AppImage
kali@kali:~$ ./Obsidian-0.14.2.AppImage
```

> Listing 2 - Getting and Running Obsidian

When we execute the AppImage, we get a welcome screen, which enables us to open an Obsidian vault or create a new one.

![Figure 4: Obsidian Welcome Screen](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/11f281591fedf5557b3fbc879b313393-obsidian1.png)

Figure 4: Obsidian Welcome Screen

Obsidian stores information in a _Vault_, which is a folder on our system. We can create both markdown files and folders within the Vault. Obsidian's features include a live preview of markdown text, in-line image placement, code blocks, and a multitude of add-ons such as a community-built CSS extension.

An example of directly entering notes in markdown is shown below:

![Figure 5: Taking Notes in Obsidian](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/02ac6e9a81c736c20c086438719ad31f-obsidian2.png)

Figure 5: Taking Notes in Obsidian

Then, it can be previewed live by Obsidian.

![Figure 6: Live Preview of Markdown](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/bb8e145610cfd717ccaadbe0ae2444f1-obsidian3.png)

Figure 6: Live Preview of Markdown

An Obsidian vault can be relocated to another computer and opened from the Welcome menu. Markdown files can simply be dropped into the Vault folders, which will automatically be recognized by Obsidian.

The use of markdown means that we can provide syntax and formatting that is easily copied to most report generation tools, and a PDF can be generated straight from Obsidian itself.

Tool selection is a personal and situational preference. Some tools are better in certain scenarios than others, but there isn't a perfect tool. It is recommended to take time and try out the tools we've covered, read the documentation, get familiar with them, and then decide which tool works for you. Some additional tools can be found referenced on [nil0x42's website](https://github.com/nil0x42/awesome-hacker-note-taking).

## 5.1.5. Taking Screenshots

Screenshots are an important part of note-taking and technical reporting. A good screenshot can explain the issue being discussed briefly and in more detail than a textual description. Screenshots are particularly useful to help present a technically complex or detail-heavy section of a report. As the saying goes, a picture is worth 1000 words. Conversely, a bad screenshot can obfuscate and draw attention away from what the issue is.

Screenshots are an important way to communicate the visual impact of a finding, and can be far more effective than mere text. For example, it's more effective to show a screenshot of an alert box popping up from an XSS payload than to describe it in words. However, it's more difficult to use a screenshot to describe exactly what's happening when we use something like a buffer overflow payload. Just like we want to use the right tool to perform certain attacks, so we also want to use the right tool to show certain results (such as text vs images).

We can use screenshots to supplement our note-taking or to include them in our report to illustrate the steps we took, which will help another tester reproduce the issues. However, we need to be conscious of the audience. While a penetration tester may consider an alert window to demonstrate XSS as perfectly self-explanatory, developers unfamiliar with the vulnerability may not understand its true cause or impact. It's good practice to always support a screenshot with text.

Screenshots have a specific goal, which is to convey information that would take several sentences to describe or to make an impact. The screenshot should contain exactly enough information to justify not using text, but there shouldn't be too much information to make the screenshot confusing.

To return to the example given above in the notes section, we have found reflected XSS in the username field of the application login. We will properly explain the effects of XSS in the actual report. However, the impact of XSS is far easier to show rather than explain without a visual reference as a base. We must include evidence of arbitrary JavaScript execution, as well as visual components of the site (i.e. the URL in the browser window). If necessary, secondary, or lead-up steps can be captured as well.

A well-constructed screenshot is easy to parse visually. Readers should be able to intuitively understand the picture and its caption without any questions. If there is a greater need for surrounding context, that can be added in a paragraph above or below the image, but the image itself should be understood.

Once again, using the example of XSS in our login form, we will include the following components in the screenshot, resizing the window if necessary. Ideally, we would include the URL as well as some company-specific branding and logos on the form. This lets them know the exact webpage and ties the vulnerability to their corporate image.

The actual pop-up executed in the proof-of-concept is necessary as well, substituted for any more advanced payload as the proof of concept is slowly taken further. Finally, we want to ensure that it is all legible. A screenshot that needs to be zoomed in to be properly viewed disrupts the reader's flow. A good screenshot is immediately legible, as shown below.

![Figure 7: Good Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/084ca8e2153f29b8b50b66252f68234c-image1.png)

Figure 7: Good Screenshot

There are several pitfalls we should avoid when using screenshots. We have already discussed making sure the screenshots are legible. We must also ensure there isn't more than one concept illustrated in each screenshot. A screenshot that contains two pieces of pertinent information does not lend itself to being easily understood at a glance. We must also ensure the impact is framed properly in the screenshot. Having the target of the screenshot off-center at the side obfuscates the intent as well. Finally, the caption for the screenshot shouldn't be overly long.

![Figure 8: Bad Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/7ad83ef7c5a28c0c2d9bc318dd1b7dc6-image3.png)

Figure 8: Bad Screenshot

The screenshot above covers the important information with an irrelevant piece of information, which prevents the full impact of the screenshot from being understood by the reader.

To recap, a good screenshot has the following characteristics:

-   is legible
-   contains some visual indication that it applies to the client
-   contains the material that is being described
-   supports the description of the material
-   properly frames the material being described

On the other hand, a bad screenshot is one that:

-   is illegible
-   is generic rather than client-specific
-   contains obfuscated or irrelevant information
-   is improperly framed

Under the screenshot, we include a caption. A caption is not meant to provide additional context for the picture. A caption is there to describe the picture in a few words. Any additional context that is necessary can be provided in a separate paragraph. In most cases, eight to ten words is an appropriate maximum for a caption.

## 5.1.6. Tools to Take Screenshots

We can take screenshots using native operating system capabilities. Windows, Linux, and macOS all provide tools to take screenshots. We can also use special-purpose tools.

For Windows, the PrintScreen key allows us to take a copy of the full screen, and _Alt/PrtSc_ takes a screenshot of the currently active window. This can then be pasted into a Paint, Word, or PowerPoint document and manipulated as required. We'll often want to crop the image to remove any unwanted material, and we can do that in these applications.

We can also invoke the Windows [_Snipping Tool_](https://en.wikipedia.org/wiki/Snipping_Tool) by pressing the Windows key together with B+s.

![Figure 9: Snipping Tool](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/eeb807bbbdb74da2aa7c49bb2ec38baf-image5.png)

Figure 9: Snipping Tool

The Snipping tool allows us to highlight and take a screenshot of any area of the screen we choose.

MacOS provides the capability to take a screenshot using the keyboard Shift/Command combination with the numeric keys 3, 4, or 5 key. To select and save the entire screen, we can use F+B+3. To highlight and select a specific area on the screen, we can simply use F+B+4 or F+B+5.

We can take a screenshot in Linux using the PrintScreen key. This will capture and save the entire screen to the user's **Images/ directory**. B+PrintScreen will allow for area highlighting and selection. In Kali Linux, we can also use the _Screenshot_ tool which is installed by default and comes with many options such as choosing the active window, selecting a region, adding a delay before taking the actual screenshot, etc.

[_Flameshot_](https://github.com/flameshot-org/flameshot) is an OS-agnostic, open-source, feature-rich screen-capturing tool. It comes with both a command-line and GUI interface and has integrated drawing tools to add highlights, pixelation, text, and other modifications to the captured image.

#### Labs

1.  A penetration tester and their client should absolutely agree on what before the engagement starts?

Answer

# 5\. Report Writing for Penetration Testers

We will cover the following Learning Units in this Learning Module:

-   Understanding Note-taking
-   Writing Effective Technical Penetration Testing Reports

This Module is designed to help Penetration Testers understand how to deliver effective reports to their clients.

## 5.1. Understanding Note-Taking

In this Learning Unit we will cover the following Learning Objectives:

-   Review the deliverables for penetration testing engagements
-   Understand the importance of note portability
-   Identify the general structure of pentesting documentation
-   Choose the right note-taking tool
-   Understand the importance of taking screenshots
-   Use tools to take screenshots

## 5.1.1. Penetration Testing Deliverables

A penetration test or [red team exercise](https://www.aon.com/cyber-solutions/thinking/penetration-testing-or-red-teaming/) is difficult to script in advance. This is because the tester cannot consistently anticipate exactly what kind of machines or networks the client will want to be tested.

Even though the outcome of our assessment is often unpredictable, it is often recommended to define a detailed _scope_ during the preliminary meetings with the customer. This process is especially very helpful when prioritizing business critical targets within large networks.

While the general execution plan for a penetration test will often follow a particular model, most pentests tend to follow the maxim ["no plan survives first contact with the enemy"](https://quoteinvestigator.com/2021/05/04/no-plan). This means that any specific activities we might expect to perform during the engagement might not actually happen, since the reality of the testing environment is almost certainly different than our initial ideas and hypotheses about it. It's therefore difficult to report on penetration tests using prepopulated forms. This is especially the case when the testing is carried out with little prior discussion with the client, for example, if the client is looking to surprise their defending teams in some manner.

As such, instead of preparing a report in advance, the penetration test is executed, and notes are taken as it proceeds to ensure that there is a detailed record of what was done. This makes sure that:

-   the penetration test can be repeated if it becomes necessary to demonstrate that an issue is real.
-   the penetration test can be repeated after remediation to confirm that an issue has been fixed.
-   if there's a system failure during the period of the penetration test, the client and tester can determine if the testing was the cause of the failure.

During a penetration test, some activities may not be permitted. We have to be very clear about the [_Rules of Engagement_](https://www.microsoft.com/en-us/msrc/pentest-rules-of-engagement) (RoE) under which the testing is done. When conducting red team testing, a person will often be assigned the role of "referee" to ensure that the rules of engagement are observed. There may be constraints placed on testing such as not carrying out denial of service attacks, or not engaging in social engineering. Furthermore, the testing work may be in response to the client's regulatory compliance requirements and may need to follow a specific methodology such as the [OWASP Penetration Testing Execution Standard](https://owasp.org/www-project-web-security-testing-guide/latest/3-The_OWASP_Testing_Framework/1-Penetration_Testing_Methodologies). Any such constraints need to be very clear from the outset.

## 5.1.2. Note Portability

Portability of penetration testing notes means being able to pass those notes on to others. Writing notes that are concise and coherent is an integral part of successful note-taking and enables the notes to be used not only by ourselves but also by others. Additionally, concise notes can be quickly adapted for technical reporting.

The need for portability is particularly emphasized when a penetration tester must leave an engagement because of sickness, illness, or other issues. Having a shared understanding of how notes should be taken is especially important for large penetration testing teams, where individuals need to be able to understand the details of other team members' engagements at will.

## 5.1.3. The General Structure of Penetration Testing Notes

We need to take a structured approach to note-taking that is both concise and precise. There are an uncountable number of ways in which we might organize our notes, and it would be futile to attempt to provide a one-size-fits all set of recommendations. Nevertheless, here are some principles that often useful to consider:

-   Rather than taking a few general notes assuming that we'll remember how to perform certain actions next time, we should record exactly what we did.
-   This means that every command that we type, every line of code that we modify, and even anywhere we click in the GUI should be recorded so that we can reproduce our actions.
-   Even if we've taken a lot of notes, if looking at them later doesn't help us remember exactly what happened during the assessment, then they won't be particularly useful to us.
-   The notes need to be structured and sufficiently detailed to remove any ambiguity.
-   To write a convincing and substantiated technical report later, we need to provide sufficient technical details within our notes.
-   If the notes are not written coherently, it will be difficult for someone else to repeat the test and get the same results.

The structure we recommend here for note-taking is sufficiently abstract to allow for personal preferences. As a general rule, we would like the notes to remind us of what occurred and allow us to replicate the issues we identify. A note-taking structure that starts broad and drills down into each section is an easy and expandable method of taking notes. The top-down approach guides us to start with the broadest activity, and then narrow down our focus and expand the level of detail until we have everything, we need to replicate exactly what happened.

Let's now look at an example of the notes we might take for a web vulnerability we discovered:

-   **Application Name**: This is important in a multi-application test, and a good habit to get into. The application names also lend itself to building a natural folder and file structure quite nicely.
    
-   **URL**: This is the exact URL that would be used to locate the vulnerability that we've detected.
    
-   **Request Type**: This represents both the type of request (i.e.: GET, POST, OPTIONS, etc.) that was made, as well as any manual changes we made to it. For example, we might intercept a POST request message and change the username or password before forwarding it on.
    
-   **Issue Detail**: This is the overview of the vulnerability that will be triggered by our actions. For example, we may point to a CVE describing the vulnerability if one exists, and/or explain the impact we observe. We may categorize the impact as denial of service, remote code execution, privilege escalation, and so on.
    
-   **Proof of Concept Payload**: This is a string or code block that will trigger the vulnerability. This is the most important part of the note, as it is what will drive the issue home and allow it to be replicated. It should list all of the necessary preconditions and provide the exact code or commands that would need to be used to trigger the vulnerability again.
    

Let's get more specific and review an example of testing for a _Cross-Site Scripting_ (XSS) vulnerability. The target we tested has a web page aptly named **XSSBlog.html**. When we navigate to it, we can enter a blog entry.

![Figure 1: XSS Testing](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/89c0b15a538a12feb35cdbecff45908b-xss1.png)

Figure 1: XSS Testing

When we read back the blog entry, we get the following alert:

![Figure 2: XSS Testing Issue](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/e113a6b758f58011df96c74634acfe7a-xss2.png)

Figure 2: XSS Testing Issue

While making these requests, we keep a record of our actions, as shown below.

```
Testing for Cross-Site Scripting 

Testing Target: 192.168.1.52 
Application:    XSSBlog
Date Started:   31 March 2022

1.  Navigated to the application
    http://192.168.1.52/XSSBlog.html
    Result: Blog page displayed as expected
    
2.  Entered our standard XSS test data: 
    You will rejoice to hear that no disaster has accompanied the
    commencement of an enterprise which you have regarded with such
    evil forebodings.<script>alert("Your computer is infected!");</script> 
    I arrived here yesterday, and my first task is to assure my dear
    sister of my welfare and increasing confidence in the success of
    my undertaking. 

3.  Clicked Submit to post the blog entry.
    Result: Blog entry appeared to save correctly.

4.  Navigated to read the blog post
    http://192.168.1.52/XSSRead.php
    Result: The blog started to display and then the expected alert popped up.

5.  Test indicated the site is vulnerable to XSS.

PoC payload: <script>alert(‘Your computer is infected!')</script>
```

> Listing 1 - Example of a Testing Note.

We now have a simple, fast, and expandable way to take coherent and comprehensive notes that another tester can follow. It's worth repeating that the notes are not themselves the report we will deliver to the client, but they will be invaluable when we attempt to put our report together later.

## 5.1.4. Choosing the Right Note-Taking Tool

There are an enormous number of both free and paid note-taking tools available today. To decide on the right tool for a particular engagement, it is important to understand some requirements. In many cases we want to keep all information local to the computer rather than uploading it anywhere else, so certain tools are precluded from being used. By the same token, if an engagement is source-code heavy then a tool that does not allow for code blocks to be inserted is not going to be appropriate.

While a comprehensive list of desirable properties to keep in mind is nearly impossible to enumerate, some of the more important items to remember are:

-   **Screenshots**: If a lot of screenshots are necessary, consider a tool that allows for inline screenshot insertion.
    
-   **Code blocks**: Code blocks need formatting to be properly and quickly understood.
    
-   **Portability**: Something that can be used cross-OS, or easily transferred to another place should be high on the list of priorities.
    
-   **Directory Structure**: In an engagement with multiple domains or applications, keeping a coherent structure is necessary. While manually setting up a structure is allowed, a tool that can do this automatically makes things easier.
    

Now that we have a good baseline of our requirements, let's consider the use of some note-taking tools.

[_Sublime_](https://www.sublimetext.com/download) is a standard text editor that adds lots of useful features and functionality. One of the most important features it provides is flexible syntax highlighting. Syntax highlighting allows us to place code blocks into a file, and those code blocks will be highlighted according to the programming language's specific syntax rules. However, this often comes with limitations. Highlighting two languages is not possible with one file. In an engagement with a single code type, this is not a problem, but for others, we may prefer to use different options. Additionally, it's not currently possible to inline screenshots at the time of writing.

Another tool we can consider is [_CherryTree_](https://github.com/giuspen/cherrytree). This tool comes as standard in Kali. It contains many of the features that are necessary for note-taking. It uses an SQLite database to store the notes we take, and these can be exported as HTML, PDF, plain text, or as a CherryTree document. CherryTree comes with a lot of built-in formatting, and provides a tree structure to store documents, which it calls "nodes" and "subnodes".

Below is an example of CherryTree being used to store penetration testing notes using a simple tree structure.

![Figure 3: CherryTree](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/9fdaf471923933513da2f372a7bcd371-cherrytree.png)

Figure 3: CherryTree

The final tool we'll consider is the [_Obsidian_](https://obsidian.md/) markdown editor, which contains all the features that we need for note-taking. We can install Obsidian as a s[nap application](https://snapcraft.io/) or in its [Flatpak](https://flatpak.org/) application form. It also comes as an [AppImage](https://appimage.org/), meaning that all we need to do is copy it into our system, mark it as executable, and run it.

```
kali@kali:~$ wget https://github.com/obsidianmd/obsidian-releases/releases/download/v0.14.2/Obsidian-0.14.2.AppImage
....
2022-03-31 15:38:53 (1.28 MB/s) - 'Obsidian-0.14.2.AppImage' saved [113102744/113102744]
kali@kali:~$ chmod +x Obsidian-0.14.2.AppImage
kali@kali:~$ ./Obsidian-0.14.2.AppImage
```

> Listing 2 - Getting and Running Obsidian

When we execute the AppImage, we get a welcome screen, which enables us to open an Obsidian vault or create a new one.

![Figure 4: Obsidian Welcome Screen](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/11f281591fedf5557b3fbc879b313393-obsidian1.png)

Figure 4: Obsidian Welcome Screen

Obsidian stores information in a _Vault_, which is a folder on our system. We can create both markdown files and folders within the Vault. Obsidian's features include a live preview of markdown text, in-line image placement, code blocks, and a multitude of add-ons such as a community-built CSS extension.

An example of directly entering notes in markdown is shown below:

![Figure 5: Taking Notes in Obsidian](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/02ac6e9a81c736c20c086438719ad31f-obsidian2.png)

Figure 5: Taking Notes in Obsidian

Then, it can be previewed live by Obsidian.

![Figure 6: Live Preview of Markdown](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/bb8e145610cfd717ccaadbe0ae2444f1-obsidian3.png)

Figure 6: Live Preview of Markdown

An Obsidian vault can be relocated to another computer and opened from the Welcome menu. Markdown files can simply be dropped into the Vault folders, which will automatically be recognized by Obsidian.

The use of markdown means that we can provide syntax and formatting that is easily copied to most report generation tools, and a PDF can be generated straight from Obsidian itself.

Tool selection is a personal and situational preference. Some tools are better in certain scenarios than others, but there isn't a perfect tool. It is recommended to take time and try out the tools we've covered, read the documentation, get familiar with them, and then decide which tool works for you. Some additional tools can be found referenced on [nil0x42's website](https://github.com/nil0x42/awesome-hacker-note-taking).

## 5.1.5. Taking Screenshots

Screenshots are an important part of note-taking and technical reporting. A good screenshot can explain the issue being discussed briefly and in more detail than a textual description. Screenshots are particularly useful to help present a technically complex or detail-heavy section of a report. As the saying goes, a picture is worth 1000 words. Conversely, a bad screenshot can obfuscate and draw attention away from what the issue is.

Screenshots are an important way to communicate the visual impact of a finding, and can be far more effective than mere text. For example, it's more effective to show a screenshot of an alert box popping up from an XSS payload than to describe it in words. However, it's more difficult to use a screenshot to describe exactly what's happening when we use something like a buffer overflow payload. Just like we want to use the right tool to perform certain attacks, so we also want to use the right tool to show certain results (such as text vs images).

We can use screenshots to supplement our note-taking or to include them in our report to illustrate the steps we took, which will help another tester reproduce the issues. However, we need to be conscious of the audience. While a penetration tester may consider an alert window to demonstrate XSS as perfectly self-explanatory, developers unfamiliar with the vulnerability may not understand its true cause or impact. It's good practice to always support a screenshot with text.

Screenshots have a specific goal, which is to convey information that would take several sentences to describe or to make an impact. The screenshot should contain exactly enough information to justify not using text, but there shouldn't be too much information to make the screenshot confusing.

To return to the example given above in the notes section, we have found reflected XSS in the username field of the application login. We will properly explain the effects of XSS in the actual report. However, the impact of XSS is far easier to show rather than explain without a visual reference as a base. We must include evidence of arbitrary JavaScript execution, as well as visual components of the site (i.e. the URL in the browser window). If necessary, secondary, or lead-up steps can be captured as well.

A well-constructed screenshot is easy to parse visually. Readers should be able to intuitively understand the picture and its caption without any questions. If there is a greater need for surrounding context, that can be added in a paragraph above or below the image, but the image itself should be understood.

Once again, using the example of XSS in our login form, we will include the following components in the screenshot, resizing the window if necessary. Ideally, we would include the URL as well as some company-specific branding and logos on the form. This lets them know the exact webpage and ties the vulnerability to their corporate image.

The actual pop-up executed in the proof-of-concept is necessary as well, substituted for any more advanced payload as the proof of concept is slowly taken further. Finally, we want to ensure that it is all legible. A screenshot that needs to be zoomed in to be properly viewed disrupts the reader's flow. A good screenshot is immediately legible, as shown below.

![Figure 7: Good Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/084ca8e2153f29b8b50b66252f68234c-image1.png)

Figure 7: Good Screenshot

There are several pitfalls we should avoid when using screenshots. We have already discussed making sure the screenshots are legible. We must also ensure there isn't more than one concept illustrated in each screenshot. A screenshot that contains two pieces of pertinent information does not lend itself to being easily understood at a glance. We must also ensure the impact is framed properly in the screenshot. Having the target of the screenshot off-center at the side obfuscates the intent as well. Finally, the caption for the screenshot shouldn't be overly long.

![Figure 8: Bad Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/7ad83ef7c5a28c0c2d9bc318dd1b7dc6-image3.png)

Figure 8: Bad Screenshot

The screenshot above covers the important information with an irrelevant piece of information, which prevents the full impact of the screenshot from being understood by the reader.

To recap, a good screenshot has the following characteristics:

-   is legible
-   contains some visual indication that it applies to the client
-   contains the material that is being described
-   supports the description of the material
-   properly frames the material being described

On the other hand, a bad screenshot is one that:

-   is illegible
-   is generic rather than client-specific
-   contains obfuscated or irrelevant information
-   is improperly framed

Under the screenshot, we include a caption. A caption is not meant to provide additional context for the picture. A caption is there to describe the picture in a few words. Any additional context that is necessary can be provided in a separate paragraph. In most cases, eight to ten words is an appropriate maximum for a caption.

## 5.1.6. Tools to Take Screenshots

We can take screenshots using native operating system capabilities. Windows, Linux, and macOS all provide tools to take screenshots. We can also use special-purpose tools.

For Windows, the PrintScreen key allows us to take a copy of the full screen, and _Alt/PrtSc_ takes a screenshot of the currently active window. This can then be pasted into a Paint, Word, or PowerPoint document and manipulated as required. We'll often want to crop the image to remove any unwanted material, and we can do that in these applications.

We can also invoke the Windows [_Snipping Tool_](https://en.wikipedia.org/wiki/Snipping_Tool) by pressing the Windows key together with B+s.

![Figure 9: Snipping Tool](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/eeb807bbbdb74da2aa7c49bb2ec38baf-image5.png)

Figure 9: Snipping Tool

The Snipping tool allows us to highlight and take a screenshot of any area of the screen we choose.

MacOS provides the capability to take a screenshot using the keyboard Shift/Command combination with the numeric keys 3, 4, or 5 key. To select and save the entire screen, we can use F+B+3. To highlight and select a specific area on the screen, we can simply use F+B+4 or F+B+5.

We can take a screenshot in Linux using the PrintScreen key. This will capture and save the entire screen to the user's **Images/ directory**. B+PrintScreen will allow for area highlighting and selection. In Kali Linux, we can also use the _Screenshot_ tool which is installed by default and comes with many options such as choosing the active window, selecting a region, adding a delay before taking the actual screenshot, etc.

[_Flameshot_](https://github.com/flameshot-org/flameshot) is an OS-agnostic, open-source, feature-rich screen-capturing tool. It comes with both a command-line and GUI interface and has integrated drawing tools to add highlights, pixelation, text, and other modifications to the captured image.

#### Labs

1.  A penetration tester and their client should absolutely agree on what before the engagement starts?

Answer

# 5\. Report Writing for Penetration Testers

We will cover the following Learning Units in this Learning Module:

-   Understanding Note-taking
-   Writing Effective Technical Penetration Testing Reports

This Module is designed to help Penetration Testers understand how to deliver effective reports to their clients.

## 5.1. Understanding Note-Taking

In this Learning Unit we will cover the following Learning Objectives:

-   Review the deliverables for penetration testing engagements
-   Understand the importance of note portability
-   Identify the general structure of pentesting documentation
-   Choose the right note-taking tool
-   Understand the importance of taking screenshots
-   Use tools to take screenshots

## 5.1.1. Penetration Testing Deliverables

A penetration test or [red team exercise](https://www.aon.com/cyber-solutions/thinking/penetration-testing-or-red-teaming/) is difficult to script in advance. This is because the tester cannot consistently anticipate exactly what kind of machines or networks the client will want to be tested.

Even though the outcome of our assessment is often unpredictable, it is often recommended to define a detailed _scope_ during the preliminary meetings with the customer. This process is especially very helpful when prioritizing business critical targets within large networks.

While the general execution plan for a penetration test will often follow a particular model, most pentests tend to follow the maxim ["no plan survives first contact with the enemy"](https://quoteinvestigator.com/2021/05/04/no-plan). This means that any specific activities we might expect to perform during the engagement might not actually happen, since the reality of the testing environment is almost certainly different than our initial ideas and hypotheses about it. It's therefore difficult to report on penetration tests using prepopulated forms. This is especially the case when the testing is carried out with little prior discussion with the client, for example, if the client is looking to surprise their defending teams in some manner.

As such, instead of preparing a report in advance, the penetration test is executed, and notes are taken as it proceeds to ensure that there is a detailed record of what was done. This makes sure that:

-   the penetration test can be repeated if it becomes necessary to demonstrate that an issue is real.
-   the penetration test can be repeated after remediation to confirm that an issue has been fixed.
-   if there's a system failure during the period of the penetration test, the client and tester can determine if the testing was the cause of the failure.

During a penetration test, some activities may not be permitted. We have to be very clear about the [_Rules of Engagement_](https://www.microsoft.com/en-us/msrc/pentest-rules-of-engagement) (RoE) under which the testing is done. When conducting red team testing, a person will often be assigned the role of "referee" to ensure that the rules of engagement are observed. There may be constraints placed on testing such as not carrying out denial of service attacks, or not engaging in social engineering. Furthermore, the testing work may be in response to the client's regulatory compliance requirements and may need to follow a specific methodology such as the [OWASP Penetration Testing Execution Standard](https://owasp.org/www-project-web-security-testing-guide/latest/3-The_OWASP_Testing_Framework/1-Penetration_Testing_Methodologies). Any such constraints need to be very clear from the outset.

## 5.1.2. Note Portability

Portability of penetration testing notes means being able to pass those notes on to others. Writing notes that are concise and coherent is an integral part of successful note-taking and enables the notes to be used not only by ourselves but also by others. Additionally, concise notes can be quickly adapted for technical reporting.

The need for portability is particularly emphasized when a penetration tester must leave an engagement because of sickness, illness, or other issues. Having a shared understanding of how notes should be taken is especially important for large penetration testing teams, where individuals need to be able to understand the details of other team members' engagements at will.

## 5.1.3. The General Structure of Penetration Testing Notes

We need to take a structured approach to note-taking that is both concise and precise. There are an uncountable number of ways in which we might organize our notes, and it would be futile to attempt to provide a one-size-fits all set of recommendations. Nevertheless, here are some principles that often useful to consider:

-   Rather than taking a few general notes assuming that we'll remember how to perform certain actions next time, we should record exactly what we did.
-   This means that every command that we type, every line of code that we modify, and even anywhere we click in the GUI should be recorded so that we can reproduce our actions.
-   Even if we've taken a lot of notes, if looking at them later doesn't help us remember exactly what happened during the assessment, then they won't be particularly useful to us.
-   The notes need to be structured and sufficiently detailed to remove any ambiguity.
-   To write a convincing and substantiated technical report later, we need to provide sufficient technical details within our notes.
-   If the notes are not written coherently, it will be difficult for someone else to repeat the test and get the same results.

The structure we recommend here for note-taking is sufficiently abstract to allow for personal preferences. As a general rule, we would like the notes to remind us of what occurred and allow us to replicate the issues we identify. A note-taking structure that starts broad and drills down into each section is an easy and expandable method of taking notes. The top-down approach guides us to start with the broadest activity, and then narrow down our focus and expand the level of detail until we have everything, we need to replicate exactly what happened.

Let's now look at an example of the notes we might take for a web vulnerability we discovered:

-   **Application Name**: This is important in a multi-application test, and a good habit to get into. The application names also lend itself to building a natural folder and file structure quite nicely.
    
-   **URL**: This is the exact URL that would be used to locate the vulnerability that we've detected.
    
-   **Request Type**: This represents both the type of request (i.e.: GET, POST, OPTIONS, etc.) that was made, as well as any manual changes we made to it. For example, we might intercept a POST request message and change the username or password before forwarding it on.
    
-   **Issue Detail**: This is the overview of the vulnerability that will be triggered by our actions. For example, we may point to a CVE describing the vulnerability if one exists, and/or explain the impact we observe. We may categorize the impact as denial of service, remote code execution, privilege escalation, and so on.
    
-   **Proof of Concept Payload**: This is a string or code block that will trigger the vulnerability. This is the most important part of the note, as it is what will drive the issue home and allow it to be replicated. It should list all of the necessary preconditions and provide the exact code or commands that would need to be used to trigger the vulnerability again.
    

Let's get more specific and review an example of testing for a _Cross-Site Scripting_ (XSS) vulnerability. The target we tested has a web page aptly named **XSSBlog.html**. When we navigate to it, we can enter a blog entry.

![Figure 1: XSS Testing](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/89c0b15a538a12feb35cdbecff45908b-xss1.png)

Figure 1: XSS Testing

When we read back the blog entry, we get the following alert:

![Figure 2: XSS Testing Issue](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/e113a6b758f58011df96c74634acfe7a-xss2.png)

Figure 2: XSS Testing Issue

While making these requests, we keep a record of our actions, as shown below.

```
Testing for Cross-Site Scripting 

Testing Target: 192.168.1.52 
Application:    XSSBlog
Date Started:   31 March 2022

1.  Navigated to the application
    http://192.168.1.52/XSSBlog.html
    Result: Blog page displayed as expected
    
2.  Entered our standard XSS test data: 
    You will rejoice to hear that no disaster has accompanied the
    commencement of an enterprise which you have regarded with such
    evil forebodings.<script>alert("Your computer is infected!");</script> 
    I arrived here yesterday, and my first task is to assure my dear
    sister of my welfare and increasing confidence in the success of
    my undertaking. 

3.  Clicked Submit to post the blog entry.
    Result: Blog entry appeared to save correctly.

4.  Navigated to read the blog post
    http://192.168.1.52/XSSRead.php
    Result: The blog started to display and then the expected alert popped up.

5.  Test indicated the site is vulnerable to XSS.

PoC payload: <script>alert(‘Your computer is infected!')</script>
```

> Listing 1 - Example of a Testing Note.

We now have a simple, fast, and expandable way to take coherent and comprehensive notes that another tester can follow. It's worth repeating that the notes are not themselves the report we will deliver to the client, but they will be invaluable when we attempt to put our report together later.

## 5.1.4. Choosing the Right Note-Taking Tool

There are an enormous number of both free and paid note-taking tools available today. To decide on the right tool for a particular engagement, it is important to understand some requirements. In many cases we want to keep all information local to the computer rather than uploading it anywhere else, so certain tools are precluded from being used. By the same token, if an engagement is source-code heavy then a tool that does not allow for code blocks to be inserted is not going to be appropriate.

While a comprehensive list of desirable properties to keep in mind is nearly impossible to enumerate, some of the more important items to remember are:

-   **Screenshots**: If a lot of screenshots are necessary, consider a tool that allows for inline screenshot insertion.
    
-   **Code blocks**: Code blocks need formatting to be properly and quickly understood.
    
-   **Portability**: Something that can be used cross-OS, or easily transferred to another place should be high on the list of priorities.
    
-   **Directory Structure**: In an engagement with multiple domains or applications, keeping a coherent structure is necessary. While manually setting up a structure is allowed, a tool that can do this automatically makes things easier.
    

Now that we have a good baseline of our requirements, let's consider the use of some note-taking tools.

[_Sublime_](https://www.sublimetext.com/download) is a standard text editor that adds lots of useful features and functionality. One of the most important features it provides is flexible syntax highlighting. Syntax highlighting allows us to place code blocks into a file, and those code blocks will be highlighted according to the programming language's specific syntax rules. However, this often comes with limitations. Highlighting two languages is not possible with one file. In an engagement with a single code type, this is not a problem, but for others, we may prefer to use different options. Additionally, it's not currently possible to inline screenshots at the time of writing.

Another tool we can consider is [_CherryTree_](https://github.com/giuspen/cherrytree). This tool comes as standard in Kali. It contains many of the features that are necessary for note-taking. It uses an SQLite database to store the notes we take, and these can be exported as HTML, PDF, plain text, or as a CherryTree document. CherryTree comes with a lot of built-in formatting, and provides a tree structure to store documents, which it calls "nodes" and "subnodes".

Below is an example of CherryTree being used to store penetration testing notes using a simple tree structure.

![Figure 3: CherryTree](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/9fdaf471923933513da2f372a7bcd371-cherrytree.png)

Figure 3: CherryTree

The final tool we'll consider is the [_Obsidian_](https://obsidian.md/) markdown editor, which contains all the features that we need for note-taking. We can install Obsidian as a s[nap application](https://snapcraft.io/) or in its [Flatpak](https://flatpak.org/) application form. It also comes as an [AppImage](https://appimage.org/), meaning that all we need to do is copy it into our system, mark it as executable, and run it.

```
kali@kali:~$ wget https://github.com/obsidianmd/obsidian-releases/releases/download/v0.14.2/Obsidian-0.14.2.AppImage
....
2022-03-31 15:38:53 (1.28 MB/s) - 'Obsidian-0.14.2.AppImage' saved [113102744/113102744]
kali@kali:~$ chmod +x Obsidian-0.14.2.AppImage
kali@kali:~$ ./Obsidian-0.14.2.AppImage
```

> Listing 2 - Getting and Running Obsidian

When we execute the AppImage, we get a welcome screen, which enables us to open an Obsidian vault or create a new one.

![Figure 4: Obsidian Welcome Screen](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/11f281591fedf5557b3fbc879b313393-obsidian1.png)

Figure 4: Obsidian Welcome Screen

Obsidian stores information in a _Vault_, which is a folder on our system. We can create both markdown files and folders within the Vault. Obsidian's features include a live preview of markdown text, in-line image placement, code blocks, and a multitude of add-ons such as a community-built CSS extension.

An example of directly entering notes in markdown is shown below:

![Figure 5: Taking Notes in Obsidian](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/02ac6e9a81c736c20c086438719ad31f-obsidian2.png)

Figure 5: Taking Notes in Obsidian

Then, it can be previewed live by Obsidian.

![Figure 6: Live Preview of Markdown](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/bb8e145610cfd717ccaadbe0ae2444f1-obsidian3.png)

Figure 6: Live Preview of Markdown

An Obsidian vault can be relocated to another computer and opened from the Welcome menu. Markdown files can simply be dropped into the Vault folders, which will automatically be recognized by Obsidian.

The use of markdown means that we can provide syntax and formatting that is easily copied to most report generation tools, and a PDF can be generated straight from Obsidian itself.

Tool selection is a personal and situational preference. Some tools are better in certain scenarios than others, but there isn't a perfect tool. It is recommended to take time and try out the tools we've covered, read the documentation, get familiar with them, and then decide which tool works for you. Some additional tools can be found referenced on [nil0x42's website](https://github.com/nil0x42/awesome-hacker-note-taking).

## 5.1.5. Taking Screenshots

Screenshots are an important part of note-taking and technical reporting. A good screenshot can explain the issue being discussed briefly and in more detail than a textual description. Screenshots are particularly useful to help present a technically complex or detail-heavy section of a report. As the saying goes, a picture is worth 1000 words. Conversely, a bad screenshot can obfuscate and draw attention away from what the issue is.

Screenshots are an important way to communicate the visual impact of a finding, and can be far more effective than mere text. For example, it's more effective to show a screenshot of an alert box popping up from an XSS payload than to describe it in words. However, it's more difficult to use a screenshot to describe exactly what's happening when we use something like a buffer overflow payload. Just like we want to use the right tool to perform certain attacks, so we also want to use the right tool to show certain results (such as text vs images).

We can use screenshots to supplement our note-taking or to include them in our report to illustrate the steps we took, which will help another tester reproduce the issues. However, we need to be conscious of the audience. While a penetration tester may consider an alert window to demonstrate XSS as perfectly self-explanatory, developers unfamiliar with the vulnerability may not understand its true cause or impact. It's good practice to always support a screenshot with text.

Screenshots have a specific goal, which is to convey information that would take several sentences to describe or to make an impact. The screenshot should contain exactly enough information to justify not using text, but there shouldn't be too much information to make the screenshot confusing.

To return to the example given above in the notes section, we have found reflected XSS in the username field of the application login. We will properly explain the effects of XSS in the actual report. However, the impact of XSS is far easier to show rather than explain without a visual reference as a base. We must include evidence of arbitrary JavaScript execution, as well as visual components of the site (i.e. the URL in the browser window). If necessary, secondary, or lead-up steps can be captured as well.

A well-constructed screenshot is easy to parse visually. Readers should be able to intuitively understand the picture and its caption without any questions. If there is a greater need for surrounding context, that can be added in a paragraph above or below the image, but the image itself should be understood.

Once again, using the example of XSS in our login form, we will include the following components in the screenshot, resizing the window if necessary. Ideally, we would include the URL as well as some company-specific branding and logos on the form. This lets them know the exact webpage and ties the vulnerability to their corporate image.

The actual pop-up executed in the proof-of-concept is necessary as well, substituted for any more advanced payload as the proof of concept is slowly taken further. Finally, we want to ensure that it is all legible. A screenshot that needs to be zoomed in to be properly viewed disrupts the reader's flow. A good screenshot is immediately legible, as shown below.

![Figure 7: Good Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/084ca8e2153f29b8b50b66252f68234c-image1.png)

Figure 7: Good Screenshot

There are several pitfalls we should avoid when using screenshots. We have already discussed making sure the screenshots are legible. We must also ensure there isn't more than one concept illustrated in each screenshot. A screenshot that contains two pieces of pertinent information does not lend itself to being easily understood at a glance. We must also ensure the impact is framed properly in the screenshot. Having the target of the screenshot off-center at the side obfuscates the intent as well. Finally, the caption for the screenshot shouldn't be overly long.

![Figure 8: Bad Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/7ad83ef7c5a28c0c2d9bc318dd1b7dc6-image3.png)

Figure 8: Bad Screenshot

The screenshot above covers the important information with an irrelevant piece of information, which prevents the full impact of the screenshot from being understood by the reader.

To recap, a good screenshot has the following characteristics:

-   is legible
-   contains some visual indication that it applies to the client
-   contains the material that is being described
-   supports the description of the material
-   properly frames the material being described

On the other hand, a bad screenshot is one that:

-   is illegible
-   is generic rather than client-specific
-   contains obfuscated or irrelevant information
-   is improperly framed

Under the screenshot, we include a caption. A caption is not meant to provide additional context for the picture. A caption is there to describe the picture in a few words. Any additional context that is necessary can be provided in a separate paragraph. In most cases, eight to ten words is an appropriate maximum for a caption.

## 5.1.6. Tools to Take Screenshots

We can take screenshots using native operating system capabilities. Windows, Linux, and macOS all provide tools to take screenshots. We can also use special-purpose tools.

For Windows, the PrintScreen key allows us to take a copy of the full screen, and _Alt/PrtSc_ takes a screenshot of the currently active window. This can then be pasted into a Paint, Word, or PowerPoint document and manipulated as required. We'll often want to crop the image to remove any unwanted material, and we can do that in these applications.

We can also invoke the Windows [_Snipping Tool_](https://en.wikipedia.org/wiki/Snipping_Tool) by pressing the Windows key together with B+s.

![Figure 9: Snipping Tool](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/eeb807bbbdb74da2aa7c49bb2ec38baf-image5.png)

Figure 9: Snipping Tool

The Snipping tool allows us to highlight and take a screenshot of any area of the screen we choose.

MacOS provides the capability to take a screenshot using the keyboard Shift/Command combination with the numeric keys 3, 4, or 5 key. To select and save the entire screen, we can use F+B+3. To highlight and select a specific area on the screen, we can simply use F+B+4 or F+B+5.

We can take a screenshot in Linux using the PrintScreen key. This will capture and save the entire screen to the user's **Images/ directory**. B+PrintScreen will allow for area highlighting and selection. In Kali Linux, we can also use the _Screenshot_ tool which is installed by default and comes with many options such as choosing the active window, selecting a region, adding a delay before taking the actual screenshot, etc.

[_Flameshot_](https://github.com/flameshot-org/flameshot) is an OS-agnostic, open-source, feature-rich screen-capturing tool. It comes with both a command-line and GUI interface and has integrated drawing tools to add highlights, pixelation, text, and other modifications to the captured image.

#### Labs

1.  A penetration tester and their client should absolutely agree on what before the engagement starts?

Answer

# 5\. Report Writing for Penetration Testers

We will cover the following Learning Units in this Learning Module:

-   Understanding Note-taking
-   Writing Effective Technical Penetration Testing Reports

This Module is designed to help Penetration Testers understand how to deliver effective reports to their clients.

## 5.1. Understanding Note-Taking

In this Learning Unit we will cover the following Learning Objectives:

-   Review the deliverables for penetration testing engagements
-   Understand the importance of note portability
-   Identify the general structure of pentesting documentation
-   Choose the right note-taking tool
-   Understand the importance of taking screenshots
-   Use tools to take screenshots

## 5.1.1. Penetration Testing Deliverables

A penetration test or [red team exercise](https://www.aon.com/cyber-solutions/thinking/penetration-testing-or-red-teaming/) is difficult to script in advance. This is because the tester cannot consistently anticipate exactly what kind of machines or networks the client will want to be tested.

Even though the outcome of our assessment is often unpredictable, it is often recommended to define a detailed _scope_ during the preliminary meetings with the customer. This process is especially very helpful when prioritizing business critical targets within large networks.

While the general execution plan for a penetration test will often follow a particular model, most pentests tend to follow the maxim ["no plan survives first contact with the enemy"](https://quoteinvestigator.com/2021/05/04/no-plan). This means that any specific activities we might expect to perform during the engagement might not actually happen, since the reality of the testing environment is almost certainly different than our initial ideas and hypotheses about it. It's therefore difficult to report on penetration tests using prepopulated forms. This is especially the case when the testing is carried out with little prior discussion with the client, for example, if the client is looking to surprise their defending teams in some manner.

As such, instead of preparing a report in advance, the penetration test is executed, and notes are taken as it proceeds to ensure that there is a detailed record of what was done. This makes sure that:

-   the penetration test can be repeated if it becomes necessary to demonstrate that an issue is real.
-   the penetration test can be repeated after remediation to confirm that an issue has been fixed.
-   if there's a system failure during the period of the penetration test, the client and tester can determine if the testing was the cause of the failure.

During a penetration test, some activities may not be permitted. We have to be very clear about the [_Rules of Engagement_](https://www.microsoft.com/en-us/msrc/pentest-rules-of-engagement) (RoE) under which the testing is done. When conducting red team testing, a person will often be assigned the role of "referee" to ensure that the rules of engagement are observed. There may be constraints placed on testing such as not carrying out denial of service attacks, or not engaging in social engineering. Furthermore, the testing work may be in response to the client's regulatory compliance requirements and may need to follow a specific methodology such as the [OWASP Penetration Testing Execution Standard](https://owasp.org/www-project-web-security-testing-guide/latest/3-The_OWASP_Testing_Framework/1-Penetration_Testing_Methodologies). Any such constraints need to be very clear from the outset.

## 5.1.2. Note Portability

Portability of penetration testing notes means being able to pass those notes on to others. Writing notes that are concise and coherent is an integral part of successful note-taking and enables the notes to be used not only by ourselves but also by others. Additionally, concise notes can be quickly adapted for technical reporting.

The need for portability is particularly emphasized when a penetration tester must leave an engagement because of sickness, illness, or other issues. Having a shared understanding of how notes should be taken is especially important for large penetration testing teams, where individuals need to be able to understand the details of other team members' engagements at will.

## 5.1.3. The General Structure of Penetration Testing Notes

We need to take a structured approach to note-taking that is both concise and precise. There are an uncountable number of ways in which we might organize our notes, and it would be futile to attempt to provide a one-size-fits all set of recommendations. Nevertheless, here are some principles that often useful to consider:

-   Rather than taking a few general notes assuming that we'll remember how to perform certain actions next time, we should record exactly what we did.
-   This means that every command that we type, every line of code that we modify, and even anywhere we click in the GUI should be recorded so that we can reproduce our actions.
-   Even if we've taken a lot of notes, if looking at them later doesn't help us remember exactly what happened during the assessment, then they won't be particularly useful to us.
-   The notes need to be structured and sufficiently detailed to remove any ambiguity.
-   To write a convincing and substantiated technical report later, we need to provide sufficient technical details within our notes.
-   If the notes are not written coherently, it will be difficult for someone else to repeat the test and get the same results.

The structure we recommend here for note-taking is sufficiently abstract to allow for personal preferences. As a general rule, we would like the notes to remind us of what occurred and allow us to replicate the issues we identify. A note-taking structure that starts broad and drills down into each section is an easy and expandable method of taking notes. The top-down approach guides us to start with the broadest activity, and then narrow down our focus and expand the level of detail until we have everything, we need to replicate exactly what happened.

Let's now look at an example of the notes we might take for a web vulnerability we discovered:

-   **Application Name**: This is important in a multi-application test, and a good habit to get into. The application names also lend itself to building a natural folder and file structure quite nicely.
    
-   **URL**: This is the exact URL that would be used to locate the vulnerability that we've detected.
    
-   **Request Type**: This represents both the type of request (i.e.: GET, POST, OPTIONS, etc.) that was made, as well as any manual changes we made to it. For example, we might intercept a POST request message and change the username or password before forwarding it on.
    
-   **Issue Detail**: This is the overview of the vulnerability that will be triggered by our actions. For example, we may point to a CVE describing the vulnerability if one exists, and/or explain the impact we observe. We may categorize the impact as denial of service, remote code execution, privilege escalation, and so on.
    
-   **Proof of Concept Payload**: This is a string or code block that will trigger the vulnerability. This is the most important part of the note, as it is what will drive the issue home and allow it to be replicated. It should list all of the necessary preconditions and provide the exact code or commands that would need to be used to trigger the vulnerability again.
    

Let's get more specific and review an example of testing for a _Cross-Site Scripting_ (XSS) vulnerability. The target we tested has a web page aptly named **XSSBlog.html**. When we navigate to it, we can enter a blog entry.

![Figure 1: XSS Testing](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/89c0b15a538a12feb35cdbecff45908b-xss1.png)

Figure 1: XSS Testing

When we read back the blog entry, we get the following alert:

![Figure 2: XSS Testing Issue](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/e113a6b758f58011df96c74634acfe7a-xss2.png)

Figure 2: XSS Testing Issue

While making these requests, we keep a record of our actions, as shown below.

```
Testing for Cross-Site Scripting 

Testing Target: 192.168.1.52 
Application:    XSSBlog
Date Started:   31 March 2022

1.  Navigated to the application
    http://192.168.1.52/XSSBlog.html
    Result: Blog page displayed as expected
    
2.  Entered our standard XSS test data: 
    You will rejoice to hear that no disaster has accompanied the
    commencement of an enterprise which you have regarded with such
    evil forebodings.<script>alert("Your computer is infected!");</script> 
    I arrived here yesterday, and my first task is to assure my dear
    sister of my welfare and increasing confidence in the success of
    my undertaking. 

3.  Clicked Submit to post the blog entry.
    Result: Blog entry appeared to save correctly.

4.  Navigated to read the blog post
    http://192.168.1.52/XSSRead.php
    Result: The blog started to display and then the expected alert popped up.

5.  Test indicated the site is vulnerable to XSS.

PoC payload: <script>alert(‘Your computer is infected!')</script>
```

> Listing 1 - Example of a Testing Note.

We now have a simple, fast, and expandable way to take coherent and comprehensive notes that another tester can follow. It's worth repeating that the notes are not themselves the report we will deliver to the client, but they will be invaluable when we attempt to put our report together later.

## 5.1.4. Choosing the Right Note-Taking Tool

There are an enormous number of both free and paid note-taking tools available today. To decide on the right tool for a particular engagement, it is important to understand some requirements. In many cases we want to keep all information local to the computer rather than uploading it anywhere else, so certain tools are precluded from being used. By the same token, if an engagement is source-code heavy then a tool that does not allow for code blocks to be inserted is not going to be appropriate.

While a comprehensive list of desirable properties to keep in mind is nearly impossible to enumerate, some of the more important items to remember are:

-   **Screenshots**: If a lot of screenshots are necessary, consider a tool that allows for inline screenshot insertion.
    
-   **Code blocks**: Code blocks need formatting to be properly and quickly understood.
    
-   **Portability**: Something that can be used cross-OS, or easily transferred to another place should be high on the list of priorities.
    
-   **Directory Structure**: In an engagement with multiple domains or applications, keeping a coherent structure is necessary. While manually setting up a structure is allowed, a tool that can do this automatically makes things easier.
    

Now that we have a good baseline of our requirements, let's consider the use of some note-taking tools.

[_Sublime_](https://www.sublimetext.com/download) is a standard text editor that adds lots of useful features and functionality. One of the most important features it provides is flexible syntax highlighting. Syntax highlighting allows us to place code blocks into a file, and those code blocks will be highlighted according to the programming language's specific syntax rules. However, this often comes with limitations. Highlighting two languages is not possible with one file. In an engagement with a single code type, this is not a problem, but for others, we may prefer to use different options. Additionally, it's not currently possible to inline screenshots at the time of writing.

Another tool we can consider is [_CherryTree_](https://github.com/giuspen/cherrytree). This tool comes as standard in Kali. It contains many of the features that are necessary for note-taking. It uses an SQLite database to store the notes we take, and these can be exported as HTML, PDF, plain text, or as a CherryTree document. CherryTree comes with a lot of built-in formatting, and provides a tree structure to store documents, which it calls "nodes" and "subnodes".

Below is an example of CherryTree being used to store penetration testing notes using a simple tree structure.

![Figure 3: CherryTree](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/9fdaf471923933513da2f372a7bcd371-cherrytree.png)

Figure 3: CherryTree

The final tool we'll consider is the [_Obsidian_](https://obsidian.md/) markdown editor, which contains all the features that we need for note-taking. We can install Obsidian as a s[nap application](https://snapcraft.io/) or in its [Flatpak](https://flatpak.org/) application form. It also comes as an [AppImage](https://appimage.org/), meaning that all we need to do is copy it into our system, mark it as executable, and run it.

```
kali@kali:~$ wget https://github.com/obsidianmd/obsidian-releases/releases/download/v0.14.2/Obsidian-0.14.2.AppImage
....
2022-03-31 15:38:53 (1.28 MB/s) - 'Obsidian-0.14.2.AppImage' saved [113102744/113102744]
kali@kali:~$ chmod +x Obsidian-0.14.2.AppImage
kali@kali:~$ ./Obsidian-0.14.2.AppImage
```

> Listing 2 - Getting and Running Obsidian

When we execute the AppImage, we get a welcome screen, which enables us to open an Obsidian vault or create a new one.

![Figure 4: Obsidian Welcome Screen](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/11f281591fedf5557b3fbc879b313393-obsidian1.png)

Figure 4: Obsidian Welcome Screen

Obsidian stores information in a _Vault_, which is a folder on our system. We can create both markdown files and folders within the Vault. Obsidian's features include a live preview of markdown text, in-line image placement, code blocks, and a multitude of add-ons such as a community-built CSS extension.

An example of directly entering notes in markdown is shown below:

![Figure 5: Taking Notes in Obsidian](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/02ac6e9a81c736c20c086438719ad31f-obsidian2.png)

Figure 5: Taking Notes in Obsidian

Then, it can be previewed live by Obsidian.

![Figure 6: Live Preview of Markdown](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/bb8e145610cfd717ccaadbe0ae2444f1-obsidian3.png)

Figure 6: Live Preview of Markdown

An Obsidian vault can be relocated to another computer and opened from the Welcome menu. Markdown files can simply be dropped into the Vault folders, which will automatically be recognized by Obsidian.

The use of markdown means that we can provide syntax and formatting that is easily copied to most report generation tools, and a PDF can be generated straight from Obsidian itself.

Tool selection is a personal and situational preference. Some tools are better in certain scenarios than others, but there isn't a perfect tool. It is recommended to take time and try out the tools we've covered, read the documentation, get familiar with them, and then decide which tool works for you. Some additional tools can be found referenced on [nil0x42's website](https://github.com/nil0x42/awesome-hacker-note-taking).

## 5.1.5. Taking Screenshots

Screenshots are an important part of note-taking and technical reporting. A good screenshot can explain the issue being discussed briefly and in more detail than a textual description. Screenshots are particularly useful to help present a technically complex or detail-heavy section of a report. As the saying goes, a picture is worth 1000 words. Conversely, a bad screenshot can obfuscate and draw attention away from what the issue is.

Screenshots are an important way to communicate the visual impact of a finding, and can be far more effective than mere text. For example, it's more effective to show a screenshot of an alert box popping up from an XSS payload than to describe it in words. However, it's more difficult to use a screenshot to describe exactly what's happening when we use something like a buffer overflow payload. Just like we want to use the right tool to perform certain attacks, so we also want to use the right tool to show certain results (such as text vs images).

We can use screenshots to supplement our note-taking or to include them in our report to illustrate the steps we took, which will help another tester reproduce the issues. However, we need to be conscious of the audience. While a penetration tester may consider an alert window to demonstrate XSS as perfectly self-explanatory, developers unfamiliar with the vulnerability may not understand its true cause or impact. It's good practice to always support a screenshot with text.

Screenshots have a specific goal, which is to convey information that would take several sentences to describe or to make an impact. The screenshot should contain exactly enough information to justify not using text, but there shouldn't be too much information to make the screenshot confusing.

To return to the example given above in the notes section, we have found reflected XSS in the username field of the application login. We will properly explain the effects of XSS in the actual report. However, the impact of XSS is far easier to show rather than explain without a visual reference as a base. We must include evidence of arbitrary JavaScript execution, as well as visual components of the site (i.e. the URL in the browser window). If necessary, secondary, or lead-up steps can be captured as well.

A well-constructed screenshot is easy to parse visually. Readers should be able to intuitively understand the picture and its caption without any questions. If there is a greater need for surrounding context, that can be added in a paragraph above or below the image, but the image itself should be understood.

Once again, using the example of XSS in our login form, we will include the following components in the screenshot, resizing the window if necessary. Ideally, we would include the URL as well as some company-specific branding and logos on the form. This lets them know the exact webpage and ties the vulnerability to their corporate image.

The actual pop-up executed in the proof-of-concept is necessary as well, substituted for any more advanced payload as the proof of concept is slowly taken further. Finally, we want to ensure that it is all legible. A screenshot that needs to be zoomed in to be properly viewed disrupts the reader's flow. A good screenshot is immediately legible, as shown below.

![Figure 7: Good Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/084ca8e2153f29b8b50b66252f68234c-image1.png)

Figure 7: Good Screenshot

There are several pitfalls we should avoid when using screenshots. We have already discussed making sure the screenshots are legible. We must also ensure there isn't more than one concept illustrated in each screenshot. A screenshot that contains two pieces of pertinent information does not lend itself to being easily understood at a glance. We must also ensure the impact is framed properly in the screenshot. Having the target of the screenshot off-center at the side obfuscates the intent as well. Finally, the caption for the screenshot shouldn't be overly long.

![Figure 8: Bad Screenshot](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/7ad83ef7c5a28c0c2d9bc318dd1b7dc6-image3.png)

Figure 8: Bad Screenshot

The screenshot above covers the important information with an irrelevant piece of information, which prevents the full impact of the screenshot from being understood by the reader.

To recap, a good screenshot has the following characteristics:

-   is legible
-   contains some visual indication that it applies to the client
-   contains the material that is being described
-   supports the description of the material
-   properly frames the material being described

On the other hand, a bad screenshot is one that:

-   is illegible
-   is generic rather than client-specific
-   contains obfuscated or irrelevant information
-   is improperly framed

Under the screenshot, we include a caption. A caption is not meant to provide additional context for the picture. A caption is there to describe the picture in a few words. Any additional context that is necessary can be provided in a separate paragraph. In most cases, eight to ten words is an appropriate maximum for a caption.

## 5.1.6. Tools to Take Screenshots

We can take screenshots using native operating system capabilities. Windows, Linux, and macOS all provide tools to take screenshots. We can also use special-purpose tools.

For Windows, the PrintScreen key allows us to take a copy of the full screen, and _Alt/PrtSc_ takes a screenshot of the currently active window. This can then be pasted into a Paint, Word, or PowerPoint document and manipulated as required. We'll often want to crop the image to remove any unwanted material, and we can do that in these applications.

We can also invoke the Windows [_Snipping Tool_](https://en.wikipedia.org/wiki/Snipping_Tool) by pressing the Windows key together with B+s.

![Figure 9: Snipping Tool](https://static.offsec.com/offsec-courses/LIBRARY/imgs/notetaking/eeb807bbbdb74da2aa7c49bb2ec38baf-image5.png)

Figure 9: Snipping Tool

The Snipping tool allows us to highlight and take a screenshot of any area of the screen we choose.

MacOS provides the capability to take a screenshot using the keyboard Shift/Command combination with the numeric keys 3, 4, or 5 key. To select and save the entire screen, we can use F+B+3. To highlight and select a specific area on the screen, we can simply use F+B+4 or F+B+5.

We can take a screenshot in Linux using the PrintScreen key. This will capture and save the entire screen to the user's **Images/ directory**. B+PrintScreen will allow for area highlighting and selection. In Kali Linux, we can also use the _Screenshot_ tool which is installed by default and comes with many options such as choosing the active window, selecting a region, adding a delay before taking the actual screenshot, etc.

[_Flameshot_](https://github.com/flameshot-org/flameshot) is an OS-agnostic, open-source, feature-rich screen-capturing tool. It comes with both a command-line and GUI interface and has integrated drawing tools to add highlights, pixelation, text, and other modifications to the captured image.

#### Labs

1.  A penetration tester and their client should absolutely agree on what before the engagement starts?

Answer