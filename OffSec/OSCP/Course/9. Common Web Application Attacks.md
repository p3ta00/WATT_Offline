# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)

# 9\. Common Web Application Attacks

In this Learning Module, we will cover the following Learning Units:

-   Directory Traversal
-   File Inclusion Vulnerabilities
-   File Upload Attack Vulnerabilities
-   Command Injection

Web development is currently one of the most in-demand skills in IT.<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2687-1" id="fnref-local_id_2687-1">1</a></sup> The combination of a shortage of skilled web developers, time constraints in projects, and rapidly changing technologies helps certain vulnerabilities occur repeatedly in a broad range of web applications. Regardless of the underlying technology stack, several common web application vulnerabilities can be found in a multitude of deployed applications.

In this Module, we cover four common web application attacks. We'll begin with Directory Traversal and File Inclusion attacks. Next, we'll learn how to abuse File Upload vulnerabilities with executable and non-executable files. Finally, we will explore Command Injection attacks.

<sup>1</sup>

(Computer Science, 2021), [https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/](https://www.computerscience.org/web-development/careers/web-developer/career-outlook-and-salary/) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2687-1)

## 9.1. Directory Traversal

This Learning Unit covers the following Learning Objectives:

-   Understand absolute and relative paths
-   Learn how to exploit directory traversal vulnerabilities
-   Use encoding for special characters

In this Learning Unit, we will examine Directory Traversal vulnerabilities. Before we explore how to exploit this kind of vulnerability, we'll need to cover relative and absolute paths. We will also use the encoding of special characters to perform Directory Traversal attacks.

## 9.1.1. Absolute vs Relative Paths

In this section, we'll learn the difference between absolute and relative paths. To successfully exploit the vulnerabilities we'll face later in this Module, we need to specify paths to files we want to display, upload, include, or execute. Depending on the web application and vulnerability, we'll use either absolute or relative paths. It is vital for us to understand the difference between these and how we can use them to specify file paths.

To reference an absolute path, we specify the full file system path including all subdirectories. We can refer to an absolute path from any location in the filesystem. Absolute paths start with a forward slash (**/**), specifying the _root file system_<sup class="footnote-ref"><a href="https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fn-local_id_2722-1" id="fnref-local_id_2722-1">1</a></sup> on Linux. From there, we can navigate through the file system.

Let's use absolute pathing to show the contents of a file. Beginning with the **/home/kali/** path, let's display the contents of **/etc/passwd**.

We'll begin in the home directory of the _kali_ user with the **pwd** command. Our second command, **ls /**, lists all files and directories in the root file system. The output showing **etc** is located there. By specifying the **/** before **etc** in the third command, we use an absolute path originating from the root file system. This means we can use **/etc/passwd** from any location in the filesystem. If we were to omit the leading slash, the terminal would search for the **etc** directory in the home directory of the _kali_ user, since this is our current directory in the terminal.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls /
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var


kali@kali:~$ cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 1 - Display content of /etc/passwd with an absolute path

Next, let's use relative pathing to achieve the same goal. We'll display the contents of **/etc/passwd** using relative paths from the home directory of the _kali_ user. To move back one directory, we can use **../**. To move more than one directory backwards, we can combine multiple **../** sequences.

We can use the **ls** command combined with one **../** sequence to list the contents of the **/home** directory, since **../** specifies one directory back. We'll then use two **../** sequences to list the contents of the root file system, which contains the **etc** directory.

```
kali@kali:~$ pwd
/home/kali

kali@kali:~$ ls ../
kali

kali@kali:~$ ls ../../
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

> Listing 2 - Using **../** to get to the root file system

From this point, we can navigate as usual through the file system. We can add **etc** to two **../** sequences to list all files and directories in the absolute path **/etc**. In the last command, we use **cat** to display the contents of the **passwd** file by combining the relative path (**../../etc/passwd**).

```
kali@kali:~$ ls ../../etc
adduser.conf            debian_version  hostname        logrotate.d     passwd 
...
logrotate.conf  pam.d           rmt          sudoers       zsh


kali@kali:~$ cat ../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 3 - Display contents of /etc/passwd with a relative path

Let's analyze another example. While we can use the **cat ../../etc/passwd** command shown in listing 3 to display the contents of **/etc/passwd**, we can achieve the same results using extra **../** sequences.

```
kali@kali:~$ cat ../../../../../../../../../../../etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh
```

> Listing 4 - Adding more "../" to the relative path

The number of **../** sequences is only relevant until we reach the root file system. Theoretically, we can add as many **../** as we want, since there is nowhere further back to go from **/**. This can be useful in certain situations, such as when we don't know our current working directory. In this case, we could specify a large number of **../** to ensure we reach the root file system from a relative pathing perspective.

<sup>1</sup>

(IBM, 2021), [https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system](https://www.ibm.com/docs/pl/aix/7.1?topic=tree-root-file-system) [↩︎](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#fnref-local_id_2722-1)

#### Labs

1.  How many **../** do you need to go from the **/var/log/** directory to the root file system (**/**)? Enter the number below.

Answer[View hints](https://portal.offsec.com/courses/pen-200-44065/learning/vulnerability-scanning-48659/wrapping-up-48703/wrapping-up-48710#)