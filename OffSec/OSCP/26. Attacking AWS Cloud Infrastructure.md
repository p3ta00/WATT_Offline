*Continuous Integration* (CI) and *Continuous Delivery* (CD) systems are vital components of modern cloud-based environments, including those on AWS. These systems facilitate the automated, repeatable, and tested deployment of applications, ensuring greater stability and efficiency. To achieve this, CI/CD pipelines must have access to application source code, secrets, and various AWS services and environments for deployment.

However, the integration of these systems into AWS environments expands their attack surface, making *CI/CD* pipelines a prime target for malicious actors. Compromising a vulnerable CI/CD system within AWS can lead to privilege escalation, allowing attackers to move deeper into the cloud infrastructure.

Because CI/CD systems are massive targets for attackers, organizations like OWASP have created "Top 10" lists for the biggest security risks in CI/CD systems, shown below. These lists help organizations identify and mitigate vulnerabilities that could be exploited within their AWS infrastructure.

- CICD-SEC-1: Insufficient Flow Control Mechanisms
- CICD-SEC-2: Inadequate Identity and Access Management
- CICD-SEC-3: Dependency Chain Abuse
- CICD-SEC-4: Poisoned Pipeline Execution (PPE)
- CICD-SEC-5: Insufficient PBAC (Pipeline-Based Access Controls)
- CICD-SEC-6: Insufficient Credential Hygiene
- CICD-SEC-7: Insecure System Configuration
- CICD-SEC-8: Ungoverned Usage of 3rd Party Services
- CICD-SEC-9: Improper Artifact Integrity Validation
- CICD-SEC-10: Insufficient Logging and Visibility

This Module is divided into two parts: the first half focused on the **Leaked Secrets to Poisoned Pipeline**, and the second half about **Dependency Chain Abuse**.

In order to maintain a consistent lab, we won't be covering CICD-SEC-8 as it requires a third-party service, such as GitHub. However, the concepts we'll examine can also be applied to that risk. Furthermore, won't be covering CICD-SEC-10 because visibility requires manual intervention, which is out of scope for this Module.

In the first part, we will focus on *CICD-SEC-4: Poisoned Pipeline Execution (PPE)*, *CICD-SEC-5: Insufficient PBAC (Pipeline-Based Access Controls)*, and *CICD-SEC-6: Insufficient Credential Hygiene*.

*Poisoned Pipeline Execution (PPE)* is when an attacker gains control of the build/deploy script, potentially leading to a reverse shell or secret theft.

*Insufficient Pipeline-Based Access Controls (PBAC)* means the pipeline lacks proper protection of secrets and sensitive assets, which can lead to compromise.

*Insufficient Credential Hygiene* refers to weak controls over secrets and tokens, making them vulnerable to leaks or escalation.

Lastly, we'll exploit an AWS S3 bucket misconfiguration to access Git credentials, modify the pipeline, and inject a payload to steal secrets and compromise the environment.

In the second half of this module, we'll cover *CICD-SEC-3: Dependency Chain Abuse*, *CICD-SEC-5: Insufficient Pipeline-Based Access Controls*, *CICD-SEC-7: Insecure System Configuration*, and *CICD-SEC-9: Improper Artifact Integrity Validation*.

*Dependency Chain Abuse* occurs when a malicious actor tricks the build system into downloading harmful code, either by hijacking an official dependency or creating similarly named packages.

*Insufficient Pipeline-Based Access Controls* means pipelines have excessive permissions, making systems vulnerable to compromise.

*Insecure System Configuration* involves misconfigurations or insecure code in pipeline applications.

*Improper Artifact Integrity Validation* allows attackers to inject malicious code into the pipeline without proper checks.

These risks, highlighted by OWASP, often overlap and serve as general guidelines for potential pipeline vulnerabilities.

In this module, we'll find public info referencing a dependency missing from the public repository. We'll exploit this by publishing a malicious package, which will be downloaded by the builder, allowing our code to run in production.

Once in production, we'll scan the network, discover more services, and tunnel into the automation server. There, we'll create an account, exploit a plugin vulnerability to get AWS keys, and continue until we find an S3 bucket with a [*Terraform state*](https://developer.hashicorp.com/terraform/language/state) state file containing admin AWS keys.

As mentioned, we'll cover the material in two halves during this Learning Module. We will explore the following Learning Units:

Leaked Secrets to Poisoned Pipeline:

- Lab Design
- Information Gathering
- Dependency Chain Attack
- Compromising the Environment

Dependency Chain Abuse:

- Information Gathering
- Dependency Chain Attack
- Compromising the Environment

## 26.1. About the Public Cloud Labs

Before we jump in, let's run through a standard disclaimer.

This Module uses OffSec's Public Cloud Labs for challenges and walkthroughs. **OffSec's Public Cloud Labs** are a type of lab environment that will complement the learning experience with hands-on practice. In contrast to our more common VM labs found elsewhere in OffSec Learning materials (in which learners will connect to the lab through a VPN), learners using the Public Cloud Labs will interact directly with the cloud environment through the Internet.

OffSec believes strongly in the advantages of learning and practicing in a hands-on environment, and we believe that the OffSec Public Cloud Labs represent an excellent opportunity for both new learners and practitioners who want to stay sharp.

Please note the following:

1. The lab environment should not be used for activities not described or requested in the learning materials you encounter. It is not designed to serve as a playground to test additional items that are out of the scope of the learning module.
2. The lab environment should not be used to take action against any asset external to the lab. This is specifically noteworthy because some modules may describe or even demonstrate attacks against vulnerable cloud deployments for the purpose of describing how those deployments can be secured.
3. Existing rules and requirements against sharing OffSec training materials still apply. Credentials and other details of the lab are not meant to be shared. OffSec monitors activity in the Public Cloud Labs (including resource usage) and monitors for abnormal events that are not related to activities described in the learning modules.

Warning

Activities that are flagged as suspicious will result in an investigation. If the investigation determines that a student acted outside of the guidelines described above, or otherwise intentionally abused the OffSec Public Cloud Labs, OffSec may choose to rescind that learner's access to the OffSec Public Cloud Labs and/or terminate the learner's account.

Progress between sessions is not saved. Note that a Public Cloud Lab that is restarted will return to its original state. After an hour has elapsed, the Public Cloud Lab will prompt to determine if the session is still active. If there is no response, the lab session will end. Learners can continue to manually extend a session for up to ten hours. The learning material is designed to accommodate the limitations of the environment. No learner is expected or required to complete all of the activities in a module within a single lab session. Even so, learners may choose to break up their learning into multiple sessions with the labs. We recommend making a note of the series of commands and actions that were completed previously to facilitate the restoration of the lab environment to the state it was in when the learner left. This is especially important when working through complex labs that require multiple actions.

## 26.2. Leaked Secrets to Poisoned Pipeline - Lab Design

In order to create a realistic lab design, multiple services need to be started at once. This includes the *Source Code Management* service, the automation server, any required repository services, the actual application, and any infrastructure needed to support the application. Because of this, the lab may take about 5 to 10 minutes to fully start.

In order to support the labs, we've included a few other auxiliary components that will help in exploiting the CI/CD system. When the lab starts, we will provide a DNS server that can be configured in your personal Kali machine. This DNS system will be preconfigured with all the hosts in the lab.

Since we will be exploiting applications in the cloud, we'll also provide a Kali instance with a public IP to capture shells. This instance will be accessible via SSH using the username *kali* and a randomly selected password for each lab.

This Kali instance contains the [kali-linux-headless](https://www.kali.org/docs/general-use/metapackages/) metapackage, which installs all the default tools but does not install a GUI. We'll also add the DNS configuration to this instance to avoid extra configuration. While we can complete most of this lab on this instance, any part that requires a GUI (loading a web page in a browser, for example) should be done on your own personal Kali instance.

The components of this lab include:

- **Gitea:** This is the Source Code Management (SCM) service. While this is a self-hosted option, the attack in this scenario would be conducted similarly if this were a public SCM like GitHub or GitLab.
- **Jenkins:** This is the automation service. While we will have to use Jenkins-specific syntax for understanding and writing pipeline workflows, the general ideas apply to most other automation services.
- **Application:** This is a generic application that we will be targeting.

The components will be accessible on the following subdomains when querying the custom DNS server:

| Component | Subdomain |
| --- | --- |
| Gitea | git.offseclab.io |
| Jenkins | automation.offseclab.io |
| Application | app.offseclab.io |

## 26.2.1. Accessing the Labs

After completing this section, we'll be able to start the lab. This provides us with:

- A DNS server's IP address
- A Kali IP address
- A Kali Password
- An AWS account with no permissions (more on this later)

In order to access the services, we will need to configure our personal Kali machine (not the cloud instance) to use the provided DNS server. For this example, our DNS server will be hosted on 203.0.113.84.

Info

No extra VPN pack is needed to reach the AWS lab DNS. Make sure that you don't have active VPN connection on your Kali machine.

We'll start by listing the connections on our Kali machine. Let's use the **nmcli** tool with the **connection** subcommand to list the active connections. Your output may differ depending on how Kali is connected (via Wi-Fi, VM, etc).

```fence
kali@kali:~$ nmcli connection
NAME                UUID                                  TYPE      DEVICE 
Wired connection 1  67f8ac63-7383-4dfd-ae42-262991b260d7  ethernet  eth0   
lo                  1284e5c4-6819-4896-8ad4-edeae32c64ce  loopback  lo 
```

> Listing 1 - Listing Network Connections

Our main network connection is named "Wired connection 1". We'll use this in the next command to set the DNS configuration. Then, we'll add the **modify** subcommand to **nmcli** and specify the name of the connection we want to modify. Let's set the **ipv4.dns** setting to the IP of our DNS server. Once set, we'll use **systemctl** to restart the **NetworkManager** service.

```fence
kali@kali:~$ sudo nmcli connection modify "Wired connection 1" ipv4.dns "203.0.113.84"

kali@kali:~$ sudo systemctl restart NetworkManager
```

> Listing 2 - Setting DNS Server

Tip

The hosted DNS server will only respond to the **offseclab.io** domain. You may specify additional DNS servers, like 1.1.1.1 or 8.8.8.8, by adding them in a comma-separated list with the command above; for example, "203.0.113.84, 1.1.1.1, 8.8.8.8".

Once configured, we can confirm that the change propagated by verifying the DNS IP in our **/etc/resolv.conf** file. We'll also use **nslookup** to check if the DNS server is responding to the appropriate requests.

```fence
kali@kali:~$ cat /etc/resolv.conf
# Generated by NetworkManager
search localdomain
nameserver 203.0.113.84
...

kali@kali:~$ nslookup git.offseclab.io
Server:         203.0.113.84
Address:        203.0.113.84#53

Non-authoritative answer:
Name:   git.offseclab.io
Address: 198.18.53.73
```

> Listing 3 - Verifying Changes for DNS

Based on the Listing above, we wrote our changes to the **resolv.conf** file and successfully queried one of the DNS entries.

Each lab restart will provide us with a new DNS IP and we'll need to run the above commands to set it. Because the DNS server will be destroyed at the end of the lab, we'll need to delete this entry from our settings by running the *nmcli* command in Listing 2 with an empty string instead of the IP. We'll demonstrate this in the Wrapping Up section.

## 26.3. Enumeration

As with every security assessment, we should start with gathering as much information as we can about the target. Gathering this information is crucial for being able to properly exploit an application.

This Learning Unit covers the following Learning Objective:

- Understand How to Enumerate a CI/CD System

## 26.3.1. Enumerating Jenkins

We know that we have an application, Git server, and automation server. Let's enumerate the automation server.

We'll start by visiting the application at [automation.offseclab.io](http://automation.offseclab.io/).

![Figure 1: Jenkins in Browser](https://static.offsec.com/offsec-courses/PEN-200/images/attacking_cicd_1/9f9421b2604cba47a267716987ac2f6b-aacicd1_jenkins_home.png)

Figure 1: Jenkins in Browser

The homepage automatically redirects us to a login page. Typically, if Jenkins had self-registration enabled, we would find the option to register here. Since we don't have that option, we can conclude that most of the automation assets are behind authentication. However, that won't stop us from enumerating as much as we can from the target.

Metasploit contains a module to enumerate Jenkins. Let's use that to gather a baseline about the target. We'll start by initializing the Metasploit database using **msfdb init**.

```fence
kali@kali:~$ sudo msfdb init
[+] Starting database
[+] Creating database user 'msf'
[+] Creating databases 'msf'
[+] Creating databases 'msf_test'
[+] Creating configuration file '/usr/share/metasploit-framework/config/database.yml'
[+] Creating initial database schema
```

> Listing 4 - Initializing the Metasploit Database

Once complete, we can start Metasploit by using the **msfconsole** command and the **\--quiet** flag to ensure the large startup banner isn't displayed.

When Metasploit starts, we'll **use** the **jenkins\_enum** module and run **show options** so we know what we need to configure.

```fence
kali@kali:~$ msfconsole --quiet

msf6 > use auxiliary/scanner/http/jenkins_enum

msf6 auxiliary(scanner/http/jenkins_enum) > show options
                                                                                                                            
Module options (auxiliary/scanner/http/jenkins_enum):                                                                       
                                                                                                                            
   Name       Current Setting  Required  Description                                                                        
   ----       ---------------  --------  -----------                                                                        
   Proxies                     no        A proxy chain of format type:host:port[,type:host:port][...]                       
   RHOSTS                      yes       The target host(s), see https://docs.metasploit.com/docs/using-metasploit/basics/  
                                         using-metasploit.html                                                              
   RPORT      80               yes       The target port (TCP)                                                              
   SSL        false            no        Negotiate SSL/TLS for outgoing connections                                         
   TARGETURI  /jenkins/        yes       The path to the Jenkins-CI application                                             
   THREADS    1                yes       The number of concurrent threads (max one per host)                                
   VHOST                       no        HTTP server virtual host                                                           
                                                                                                                            

View the full module info with the info, or info -d command.
```

> Listing 5 - Selecting Module and Viewing Options

We'll need to configure the *RHOSTS* and the *TARGETURI* options. We know that the host is the URL we've been using to visit the page. While the default target URI is **/jenkins/**, we'll find that Jenkins is running on the root directory. Let's set the TARGETURI to the root of the page.

```fence
msf6 auxiliary(scanner/http/jenkins_enum) > set RHOSTS automation.offseclab.io
RHOSTS => automation.offseclab.io

msf6 auxiliary(scanner/http/jenkins_enum) > set TARGETURI /
TARGETURI => /
```

> Listing 6 - Configuring the Module

Next, we need to **run** the module to collect the information.

```fence
msf6 auxiliary(scanner/http/jenkins_enum) > run

[+] 198.18.53.73:80      - Jenkins Version 2.385
[*] /script restricted (403)
[*] /view/All/newJob restricted (403)
[*] /asynchPeople/ restricted (403)
[*] /systemInfo restricted (403)
[*] Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
```

> Listing 7 - Running the Module

Unfortunately, the authentication blocked the rest of the scan, so we've only gathered the version. This information is nevertheless useful as we can search for public exploits.

There is an endless amount of enumeration we can attempt. However, to avoid spending too much time on one target, let's move on to the git server.

#### Labs

1. Run a directory busting attack and discover the hidden endpoint on jenkins. This endpoint will return a flag.

Answer